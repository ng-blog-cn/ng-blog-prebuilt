{
  "id": "tutorial/toh-pt6",
  "title": "HTTP 服务",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"http\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http\"><i class=\"material-icons\">link</i></a>HTTP</h1>\n<h1 translation-result=\"\" id=\"http-服务\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-服务\"><i class=\"material-icons\">link</i></a>HTTP 服务</h1>\n<p translation-origin=\"off\">In this page, you'll make the following improvements.</p>\n<p translation-result=\"\">在这一章中，我们将进行如下增强：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Get the hero data from a server.</p>\n<p translation-result=\"\">从服务器获取英雄数据。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Let users add, edit, and delete hero names.</p>\n<p translation-result=\"\">让用户添加、编辑和删除英雄名。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Save the changes to the server.</p>\n<p translation-result=\"\">把这些更改保存到服务器。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">You'll teach the app to make corresponding HTTP calls to a remote server's web API.</p>\n<p translation-result=\"\">我们要让应用能够对远端服务器提供的Web API发起相应的HTTP调用。</p>\n<p translation-origin=\"off\">When you're done with this page, the app should look like this <live-example></live-example>.</p>\n<p translation-result=\"\">当我们完成这一章时，应用会变成这样：<live-example></live-example>。</p>\n<h2 translation-origin=\"off\" id=\"where-you-left-off\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#where-you-left-off\"><i class=\"material-icons\">link</i></a>Where you left off</h2>\n<h2 translation-result=\"\" id=\"延续上一步教程\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#延续上一步教程\"><i class=\"material-icons\">link</i></a>延续上一步教程</h2>\n<p translation-origin=\"off\">In the <a href=\"tutorial/toh-pt5\">previous page</a>, you learned to navigate between the dashboard and the fixed heroes list,\nediting a selected hero along the way.\nThat's the starting point for this page.</p>\n<p translation-result=\"\">在<a href=\"tutorial/toh-pt5\">前一章</a>中，我们学会了在仪表盘和固定的英雄列表之间导航，并编辑选定的英雄。这也就是本章的起点。</p>\n<h2 translation-origin=\"off\" id=\"keep-the-app-transpiling-and-running\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#keep-the-app-transpiling-and-running\"><i class=\"material-icons\">link</i></a>Keep the app transpiling and running</h2>\n<h2 translation-result=\"\" id=\"保持应用的转译与运行\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#保持应用的转译与运行\"><i class=\"material-icons\">link</i></a>保持应用的转译与运行</h2>\n<p translation-origin=\"off\">Enter the following command in the terminal window:</p>\n<p translation-result=\"\">在终端窗口输入如下命令：</p>\n<code-example language=\"sh\" class=\"code-shell\">\n  npm start\n</code-example>\n<p translation-origin=\"off\">This command runs the TypeScript compiler in \"watch mode\", recompiling automatically when the code changes.\nThe command simultaneously launches the app in a browser and refreshes the browser when the code changes.</p>\n<p translation-result=\"\">这个命令会在“监听”模式下运行TypeScript编译器，当代码变化时，它会自动重新编译。\n同时，该命令还会在浏览器中启动该应用，并且当代码变化时刷新浏览器。</p>\n<p translation-origin=\"off\">You can keep building the Tour of Heroes without pausing to recompile or refresh the browser.</p>\n<p translation-result=\"\">在后续构建《英雄指南》过程中，应用能持续运行，而不用中断服务来编译或刷新浏览器。</p>\n<h2 translation-origin=\"off\" id=\"providing-http-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#providing-http-services\"><i class=\"material-icons\">link</i></a>Providing HTTP Services</h2>\n<h2 translation-result=\"\" id=\"提供-http-服务\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#提供-http-服务\"><i class=\"material-icons\">link</i></a>提供 HTTP 服务</h2>\n<p translation-origin=\"off\">The <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> is not a core NgModule.\n<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> is Angular's optional approach to web access. It exists as a separate add-on module called <code>@angular/http</code>\nand is shipped in a separate script file as part of the Angular npm package.</p>\n<p translation-result=\"\"><code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code><strong><em>并不是</em></strong> Angular 的核心模块。\n它是 Angular 用来进行 Web 访问的一种可选方式，并位于一个名叫 <code>@angular/http</code> 的独立附属模块中，并作为 Angular 的 npm 包之一而发布出来。</p>\n<p translation-origin=\"off\">You're ready to import from <code>@angular/http</code> because <code>systemjs.config</code> configured <em>SystemJS</em> to load that library when you need it.</p>\n<p translation-result=\"\"><code>systemjs.config</code>中已经配置好了 <em>SystemJS</em>，并在必要时加载它，因此我们已经准备好从<code>@angular/http</code>中导入它了。</p>\n<h2 translation-origin=\"off\" id=\"register-for-http-services\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#register-for-http-services\"><i class=\"material-icons\">link</i></a>Register for HTTP services</h2>\n<h2 translation-result=\"\" id=\"注册-http-服务\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#注册-http-服务\"><i class=\"material-icons\">link</i></a>注册 <em>HTTP</em> 服务</h2>\n<p translation-origin=\"off\">The app will depend on the Angular <code>http</code> service, which itself depends on other supporting services.\nThe <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> from the <code>@angular/http</code> library holds providers for a complete set of HTTP services.</p>\n<p translation-result=\"\">我们的应用将会依赖于 Angular 的<code>http</code>服务，它本身又依赖于其它支持类服务。\n来自<code>@angular/http</code>库中的<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>保存着这些 HTTP 相关服务提供商的全集。</p>\n<p translation-origin=\"off\">To allow access to these services from anywhere in the app,\nadd <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> to the <code>imports</code> list of the <code>AppModule</code>.</p>\n<p translation-result=\"\">我们要能从本应用的任何地方访问这些服务，就要把<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>添加到<code>AppModule</code>的<code>imports</code>列表中。\n这里同时也是我们引导应用及其根组件<code>AppComponent</code>的地方。</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"v1\" title=\"src/app/app.module.ts (v1)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }      from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }   from '@angular/forms';\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> }    from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\n\nimport { AppComponent }         from './app.component';\nimport { DashboardComponent }   from './dashboard.component';\nimport { HeroesComponent }      from './heroes.component';\nimport { HeroDetailComponent }  from './hero-detail.component';\nimport { HeroService }          from './hero.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroDetailComponent,\n    HeroesComponent,\n  ],\n  providers: [ HeroService ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p translation-origin=\"off\">Notice that you also supply <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> as part of the <em>imports</em> array in root NgModule <code>AppModule</code>.</p>\n<p translation-result=\"\">注意，现在<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>已经是根模块<code>AppModule</code>的<code>imports</code>数组的一部分了。</p>\n<h2 translation-origin=\"off\" id=\"simulate-the-web-api\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#simulate-the-web-api\"><i class=\"material-icons\">link</i></a>Simulate the web API</h2>\n<h2 translation-result=\"\" id=\"模拟web-api\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#模拟web-api\"><i class=\"material-icons\">link</i></a>模拟web API</h2>\n<p translation-origin=\"off\">We recommend registering app-wide services in the root\n<code>AppModule</code> <em>providers</em>.</p>\n<p translation-result=\"\">我们建议在根模块<code>AppModule</code>的<code>providers</code>数组中注册全应用级的服务。</p>\n<p translation-origin=\"off\">Until you have a web server that can handle requests for hero data,\nthe HTTP client will fetch and save data from\na mock service, the <em>in-memory web API</em>.</p>\n<p translation-result=\"\">在拥有一个能处理Web请求的服务器之前，我们可以先用HTTP客户端通过一个模拟（Mock）服务（内存Web API）来获取和保存数据。</p>\n<p translation-origin=\"off\">Update <code>src/app/app.module.ts</code> with this version, which uses the mock service:</p>\n<p translation-result=\"\">修改<code>src/app/app.module.ts</code>，让它使用这个模拟服务：</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"v2\" title=\"src/app/app.module.ts (v2)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }      from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }   from '@angular/forms';\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> }    from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\n\n// Imports for loading &#x26; configuring the in-memory web api\nimport { InMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService }  from './in-memory-data.service';\n\nimport { AppComponent }         from './app.component';\nimport { DashboardComponent }   from './dashboard.component';\nimport { HeroesComponent }      from './heroes.component';\nimport { HeroDetailComponent }  from './hero-detail.component';\nimport { HeroService }          from './hero.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    InMemoryWebApiModule.forRoot(InMemoryDataService),\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroDetailComponent,\n    HeroesComponent,\n  ],\n  providers: [ HeroService ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p translation-origin=\"off\">Rather than require a real API server, this example simulates communication with the remote server by adding the\n<a href=\"https://github.com/angular/in-memory-web-api\" title=\"In-memory Web API\">InMemoryWebApiModule</a>\nto the module <code>imports</code>, effectively  replacing the <code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code> client's XHR backend service with an in-memory alternative.</p>\n<p translation-result=\"\">导入<code>InMemoryWebApiModule</code>并将其加入到模块的<code>imports</code>数组。\n<code>InMemoryWebApiModule</code>将<code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code>客户端默认的后端服务 —\n这是一个辅助服务，负责与远程服务器对话 —\n替换成了<em>内存 Web API</em>服务：</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"in-mem-web-api\">\nInMemoryWebApiModule.forRoot(InMemoryDataService),\n\n</code-example>\n<p translation-origin=\"off\">The <code>forRoot()</code> configuration method takes an <code>InMemoryDataService</code> class\nthat primes the in-memory database.\nAdd the file <code>in-memory-data.service.ts</code> in <code>app</code> with the following content:</p>\n<p translation-result=\"\"><code>forRoot()</code>配置方法需要<code>InMemoryDataService</code>类实例，用来向内存数据库填充数据：\n往<code>app</code>目录下新增一个文件<code>in-memory-data.service.ts</code>，填写下列内容：</p>\n<code-example path=\"toh-pt6/src/app/in-memory-data.service.ts\" region=\"init\" title=\"src/app/in-memory-data.service.ts\" linenums=\"false\">\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 0,  name: 'Zero' },\n      { id: 11, name: 'Mr. Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">This file replaces <code>mock-heroes.ts</code>, which is now safe to delete.\nAdded hero \"Zero\" to confirm that the data service can handle a hero with <code>id==0</code>.</p>\n<p translation-result=\"\">这个文件已经替换了<code>mock-heroes.ts</code>，可以删除<code>mock-heroes.ts</code>了。</p>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">  The in-memory web API is only useful in the early stages of development and for demonstrations such as this Tour of Heroes.\nDon't worry about the details of this backend substitution; you can\nskip it when you have a real web API server.</p>\n<p translation-result=\"\">  内存Web API只在开发的早期阶段或写《英雄指南》这样的演示程序时才有用。有了它，你将来替换后端实现时就不用关心这些细节问题了。如果你已经有了一个真实的Web API服务器，尽管跳过它吧。</p>\n</div>\n<h2 translation-origin=\"off\" id=\"heroes-and-http\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#heroes-and-http\"><i class=\"material-icons\">link</i></a>Heroes and HTTP</h2>\n<h2 translation-result=\"\" id=\"英雄与-http\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#英雄与-http\"><i class=\"material-icons\">link</i></a>英雄与 HTTP</h2>\n<p translation-origin=\"off\">In the current <code>HeroService</code> implementation, a Promise resolved with mock heroes is returned.</p>\n<p translation-result=\"\">在目前的<code>HeroService</code>的实现中，返回的是一个能解析（resolve）成模拟英雄列表的承诺（Promise）。</p>\n<code-example path=\"toh-pt4/src/app/hero.service.ts\" region=\"get-heroes\" title=\"src/app/hero.service.ts (old getHeroes)\">\ngetHeroes(): Promise&#x3C;Hero[]> {\n  return Promise.resolve(HEROES);\n}\n\n</code-example>\n<p translation-origin=\"off\">This was implemented in anticipation of ultimately\nfetching heroes with an HTTP client, which must be an asynchronous operation.</p>\n<p translation-result=\"\">我们返回一个承诺 (Promise)，它用模拟版的英雄列表进行解析。\n它当时可能看起来显得有点过于复杂，不过我们预料到总有这么一天会通过 HTTP 客户端来获取英雄数据，\n而且我们知道，那一定是一个异步操作。</p>\n<p translation-origin=\"off\">Now convert <code>getHeroes()</code> to use HTTP.</p>\n<p translation-result=\"\">现在，我们把<code>getHeroes()</code>换成使用 HTTP。</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHeroes\" title=\"src/app/hero.service.ts (updated getHeroes and new class members)\">\nprivate heroesUrl = 'api/heroes';  // URL to web api\n\nconstructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) { }\n\ngetHeroes(): Promise&#x3C;Hero[]> {\n  return this.http.get(this.heroesUrl)\n             .toPromise()\n             .then(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero[])\n             .catch(this.handleError);\n}\n\nprivate handleError(error: any): Promise&#x3C;any> {\n  console.error('An error occurred', error); // for demo purposes only\n  return Promise.reject(error.message || error);\n}\n\n</code-example>\n<p translation-origin=\"off\">Update the import statements as follows:</p>\n<p translation-result=\"\">更新后的导入声明如下：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"imports\" title=\"src/app/hero.service.ts (updated imports)\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { <a href=\"api/http/Headers\" class=\"code-anchor\">Headers</a>, <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> } from '@angular/http';\n\nimport 'rxjs/add/operator/toPromise';\n\nimport { Hero } from './hero';\n\n</code-example>\n<p translation-origin=\"off\">Refresh the browser. The hero data should successfully load from the\nmock server.</p>\n<p translation-result=\"\">刷新浏览器后，英雄数据就会从模拟服务器被成功读取。</p>\n<a id=\"http-promise\"></a>\n<h3 translation-origin=\"off\" id=\"http-promise\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-promise\"><i class=\"material-icons\">link</i></a>HTTP Promise</h3>\n<h3 translation-result=\"\" id=\"http-承诺（promise）\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#http-承诺（promise）\"><i class=\"material-icons\">link</i></a>Http 承诺（Promise）</h3>\n<p translation-origin=\"off\">The Angular <code>http.get</code> returns an RxJS <code>Observable</code>.\n<em>Observables</em> are a powerful way to manage asynchronous data flows.\nYou'll read about <a href=\"tutorial/toh-pt6#observables\">Observables</a> later in this page.</p>\n<p translation-result=\"\">Angular 的<code>http.get</code>返回一个 RxJS 的<code>Observable</code>对象。\n<em>Observable（可观察对象）</em>是一个管理异步数据流的强力方式。\n后面我们还会进一步学习<a href=\"tutorial/toh-pt6#observables\">可观察对象</a>。</p>\n<p translation-origin=\"off\">For now, you've converted the <code>Observable</code> to a <code>Promise</code> using the <code>toPromise</code> operator.</p>\n<p translation-result=\"\"><em>现在</em>，我们先利用<code>toPromise</code>操作符把<code>Observable</code>直接转换成<code>Promise</code>对象，回到已经熟悉的地盘。</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"to-promise\">\n.toPromise()\n\n</code-example>\n<p translation-origin=\"off\">The Angular <code>Observable</code> doesn't have a <code>toPromise</code> operator out of the box.</p>\n<p translation-result=\"\">不幸的是，Angular 的<code>Observable</code>并没有一个<code>toPromise</code>操作符... 没有打包在一起发布。Angular的<code>Observable</code>只是一个骨架实现。</p>\n<p translation-origin=\"off\">There are many operators like <code>toPromise</code> that extend <code>Observable</code> with useful capabilities.\nTo use those capabilities, you have to add the operators themselves.\nThat's as easy as importing them from the RxJS library like this:</p>\n<p translation-result=\"\">有很多像<code>toPromise</code>这样的操作符，用于扩展<code>Observable</code>，为其添加有用的能力。\n如果我们希望得到那些能力，就得自己添加那些操作符。\n那很容易，只要从 RxJS 库中导入它们就可以了，就像这样：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"rxjs\">\nimport 'rxjs/add/operator/toPromise';\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">  You'll add more operators, and learn why you must do so, <a href=\"tutorial/toh-pt6#rxjs-imports\">later in this tutorial</a>.</p>\n<p translation-result=\"\">我们还要添加更多的操作符，并且必须这么做，要了解其中的原因，参见<a href=\"tutorial/toh-pt6#rxjs-imports\">本章稍后的部分</a>。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"extracting-the-data-in-the-then-callback\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#extracting-the-data-in-the-then-callback\"><i class=\"material-icons\">link</i></a>Extracting the data in the <em>then</em> callback</h3>\n<h3 translation-result=\"\" id=\"在-then-回调中提取出数据\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#在-then-回调中提取出数据\"><i class=\"material-icons\">link</i></a>在 <em>then</em> 回调中提取出数据</h3>\n<p translation-origin=\"off\">In the <em>Promise</em>'s <code>then()</code> callback , you call the <code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> method of the HTTP <code><a href=\"api/http/Response\" class=\"code-anchor\">Response</a></code> to extract the\ndata within the response.</p>\n<p translation-result=\"\">在 <em>promise</em> 的<code>then()</code>回调中，我们调用 HTTP 的<code>Reponse</code>对象的<code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>方法，以提取出其中的数据。</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"to-data\">\n.then(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero[])\n\n</code-example>\n<p translation-origin=\"off\">The response JSON has a single <code>data</code> property, which\nholds the array of heroes that the caller wants.\nSo you grab that array and return it as the resolved Promise value.</p>\n<p translation-result=\"\">这个由<code><a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>方法返回的对象只有一个<code>data</code>属性。\n这个<code>data</code>属性保存了<em>英雄</em>数组，这个数组才是调用者真正想要的。\n所以我们取得这个数组，并且把它作为承诺的值进行解析。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">  Note the shape of the data that the server returns.\nThis particular in-memory web API example returns an object with a <code>data</code> property.\nYour API might return something else. Adjust the code to match your web API.</p>\n<p translation-result=\"\">仔细看看这个由服务器返回的数据的形态。\n这个<em>内存 Web API</em> 的范例中所做的是返回一个带有<code>data</code>属性的对象。\n你的 API 也可以返回其它东西。请调整这些代码以匹配<em>你的 Web API</em>。</p>\n</div>\n<p translation-origin=\"off\">The caller is unaware that you fetched the heroes from the (mock) server.\nIt receives a Promise of <em>heroes</em> just as it did before.</p>\n<p translation-result=\"\">调用者并不知道这些实现机制，它仍然像以前那样接收一个包含<em>英雄数据</em>的承诺。\n它也不知道我们已经改成了从服务器获取英雄数据。\n它也不必了解把 HTTP 响应转换成英雄数据时所作的这些复杂变换。\n看到美妙之处了吧，这正是将数据访问委托组一个服务的目的。</p>\n<h3 translation-origin=\"off\" id=\"error-handling\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#error-handling\"><i class=\"material-icons\">link</i></a>Error Handling</h3>\n<h3 translation-result=\"\" id=\"错误处理\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#错误处理\"><i class=\"material-icons\">link</i></a>错误处理</h3>\n<p translation-origin=\"off\">At the end of <code>getHeroes()</code>, you <code>catch</code> server failures and pass them to an error handler.</p>\n<p translation-result=\"\">在<code>getHeroes()</code>的最后，我们<code>catch</code>了服务器的失败信息，并把它们传给了错误处理器：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"catch\">\n.catch(this.handleError);\n\n</code-example>\n<p translation-origin=\"off\">This is a critical step.\nYou must anticipate HTTP failures, as they happen frequently for reasons beyond your control.</p>\n<p translation-result=\"\">这是一个关键的步骤！\n我们必须预料到 HTTP 请求会失败，因为有太多我们无法控制的原因可能导致它们频繁出现各种错误。</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"handleError\">\nprivate handleError(error: any): Promise&#x3C;any> {\n  console.error('An error occurred', error); // for demo purposes only\n  return Promise.reject(error.message || error);\n}\n\n</code-example>\n<p translation-origin=\"off\">This demo service logs the error to the console; in real life,\nyou would handle the error in code. For a demo, this works.</p>\n<p translation-result=\"\">在这个范例服务中，我们把错误记录到控制台中；在真实世界中，我们应该用代码对错误进行处理。但对于演示来说，这就够了。</p>\n<p translation-origin=\"off\">The code also includes an error to\nthe caller in a rejected promise, so that the caller can display a proper error message to the user.</p>\n<p translation-result=\"\">我们还要通过一个被拒绝 (rejected) 的承诺来把该错误用一个用户友好的格式返回给调用者，\n以便调用者能把一个合适的错误信息显示给用户。</p>\n<h3 translation-origin=\"off\" id=\"get-hero-by-id\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#get-hero-by-id\"><i class=\"material-icons\">link</i></a>Get hero by id</h3>\n<h3 translation-result=\"\" id=\"通过id获取英雄\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#通过id获取英雄\"><i class=\"material-icons\">link</i></a>通过id获取英雄</h3>\n<p translation-origin=\"off\">When the <code>HeroDetailComponent</code> asks the <code>HeroService</code> to fetch a hero,\nthe <code>HeroService</code> currently fetches all heroes and\nfilters for the one with the matching <code>id</code>.\nThat's fine for a simulation, but it's wasteful to ask a real server for all heroes when you only want one.\nMost web APIs support a <em>get-by-id</em> request in the form <code>api/hero/:id</code> (such as <code>api/hero/11</code>).</p>\n<p translation-result=\"\">当<code>HeroDetailComponent</code>向<code>HeroService</code>请求获取一个英雄时，<code>HeroService</code>会获取所有英雄，并从中过滤出与<code>id</code>匹配的那一个。\n这对于例子来说倒是无可厚非，\n不过在真实服务中，这种为了获取一个英雄而请求全部英雄的做法就有点浪费了，\n许多Web API支持<em>get-by-id</em>请求，形如：<code>api/hero/:id</code>（如：<code>api/hero/11</code>）。</p>\n<p translation-origin=\"off\">Update the <code>HeroService.getHero()</code> method to make a <em>get-by-id</em> request:</p>\n<p translation-result=\"\">修改 <code>HeroService.getHero()</code> 方法来发起一个 <em>get-by-id</em> 请求：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"getHero\" title=\"src/app/hero.service.ts\">\ngetHero(id: number): Promise&#x3C;Hero> {\n  const url = `${this.heroesUrl}/${id}`;\n  return this.http.get(url)\n    .toPromise()\n    .then(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero)\n    .catch(this.handleError);\n}\n\n</code-example>\n<p translation-origin=\"off\">This request is almost the same as <code>getHeroes()</code>.\nThe hero id in the URL identifies which hero the server should update.</p>\n<p translation-result=\"\">此方法基本上与<code>getHeroes</code>方法一致，通过在URL中添加英雄的id来告诉服务器应该获取<em>那个</em>英雄，\n匹配<code>api/hero/:id</code>模式。</p>\n<p translation-origin=\"off\">Also, the <code>data</code> in the response is a single hero object rather than an array.</p>\n<p translation-result=\"\">我们还要把响应中返回的<code>data</code>改为一个英雄对象，而不再是对象数组。组。</p>\n<h3 translation-origin=\"off\" id=\"unchanged-getheroes-api\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#unchanged-getheroes-api\"><i class=\"material-icons\">link</i></a>Unchanged <em>getHeroes</em> API</h3>\n<h3 translation-result=\"\" id=\"getheroes-api-没变\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#getheroes-api-没变\"><i class=\"material-icons\">link</i></a><code>getHeroes</code> API 没变</h3>\n<p translation-origin=\"off\">Although you made significant internal changes to <code>getHeroes()</code> and <code>getHero()</code>,\nthe public signatures didn't change.\nYou still return a Promise from both methods.\nYou won't have to update any of the components that call them.</p>\n<p translation-result=\"\">尽管我们在<code>getHeroes()</code>和<code>getHero()</code>方法的<em>内部</em>做了重大修改，\n但是他们的公共签名却没有变。这两个方法仍然返回的是一个Promise对象，\n所以并不需要修改任何调用他们的组件。</p>\n<p translation-origin=\"off\">Now it's time to add the ability to create and delete heroes.</p>\n<p translation-result=\"\">现在，我们该支持创建和删除英雄了。</p>\n<h2 translation-origin=\"off\" id=\"updating-hero-details\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#updating-hero-details\"><i class=\"material-icons\">link</i></a>Updating hero details</h2>\n<h2 translation-result=\"\" id=\"更新英雄详情\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#更新英雄详情\"><i class=\"material-icons\">link</i></a>更新英雄详情</h2>\n<p translation-origin=\"off\">Try editing a hero's name in the hero detail view.\nAs you type, the hero name is updated in the view heading.\nBut if you click the Back button, the changes are lost.</p>\n<p translation-result=\"\">我们已经可以在英雄详情中编辑英雄的名字了。来试试吧。在输入的时候，页头上的英雄名字也会随之更新。\n不过当我们点了<code>Back（后退）</code>按钮时，这些修改就丢失了。</p>\n<p translation-origin=\"off\">Updates weren't lost before. What changed?\nWhen the app used a list of mock heroes, updates were applied directly to the\nhero objects within the single, app-wide, shared list. Now that you're fetching data\nfrom a server, if you want changes to persist, you must write them back to\nthe server.</p>\n<p translation-result=\"\">以前是不会丢失更新的，怎么回事？\n当该应用使用模拟出来的英雄列表时，修改的是一份全局共享的英雄列表，而现在改成了从服务器获取数据。\n如果我们希望这些更改被持久化，我们就得把它们写回服务器。</p>\n<h3 translation-origin=\"off\" id=\"add-the-ability-to-save-hero-details\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-the-ability-to-save-hero-details\"><i class=\"material-icons\">link</i></a>Add the ability to save hero details</h3>\n<h3 translation-result=\"\" id=\"保存英雄详情\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#保存英雄详情\"><i class=\"material-icons\">link</i></a>保存英雄详情</h3>\n<p translation-origin=\"off\">At the end of the hero detail template, add a save button with a <code>click</code> event\nbinding that invokes a new component method named <code>save()</code>.</p>\n<p translation-result=\"\">我们先来确保对英雄名字的编辑不会丢失。先在英雄详情模板的底部添加一个保存按钮，它绑定了一个<code>click</code>事件，事件绑定会调用组件中一个名叫<code>save()</code>的新方法：</p>\n<code-example path=\"toh-pt6/src/app/hero-detail.component.html\" region=\"save\" title=\"src/app/hero-detail.component.html (save)\">\n&#x3C;button (click)=\"save()\">Save&#x3C;/button>\n\n</code-example>\n<p translation-origin=\"off\">Add the following <code>save()</code> method, which persists hero name changes using the hero service\n<code>update()</code> method and then navigates back to the previous view.</p>\n<p translation-result=\"\"><code>save()</code>方法使用 hero 服务的<code>update()</code>方法来持久化对英雄名字的修改，然后导航回前一个视图：</p>\n<code-example path=\"toh-pt6/src/app/hero-detail.component.ts\" region=\"save\" title=\"src/app/hero-detail.component.ts (save)\">\nsave(): void {\n  this.heroService.update(this.hero)\n    .then(() => this.goBack());\n}\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"add-a-hero-service-update-method\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-a-hero-service-update-method\"><i class=\"material-icons\">link</i></a>Add a hero service <em>update()</em> method</h3>\n<h3 translation-result=\"\" id=\"hero-服务的update方法\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#hero-服务的update方法\"><i class=\"material-icons\">link</i></a>hero 服务的<code>update</code>方法</h3>\n<p translation-origin=\"off\">The overall structure of the <code>update()</code> method is similar to that of\n<code>getHeroes()</code>, but it uses an HTTP <code>put()</code> to persist server-side changes.</p>\n<p translation-result=\"\"><code>update()</code>方法的大致结构与<code>getHeroes()</code>类似，不过我们使用 HTTP 的 <code>put()</code> 方法来把修改持久化到服务端：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"update\" title=\"src/app/hero.service.ts (update)\">\nprivate headers = new <a href=\"api/http/Headers\" class=\"code-anchor\">Headers</a>({'Content-<a href=\"api/core/Type\" class=\"code-anchor\">Type</a>': 'application/<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>'});\n\nupdate(hero: Hero): Promise&#x3C;Hero> {\n  const url = `${this.heroesUrl}/${hero.id}`;\n  return this.http\n    .put(url, JSON.stringify(hero), {headers: this.headers})\n    .toPromise()\n    .then(() => hero)\n    .catch(this.handleError);\n}\n\n</code-example>\n<p translation-origin=\"off\">To identify which hero the server should update, the hero <code>id</code> is encoded in\nthe URL. The <code>put()</code> body is the JSON string encoding of the hero, obtained by\ncalling <code>JSON.stringify</code>. The body content type\n(<code>application/<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>) is identified in the request header.</p>\n<p translation-result=\"\">我们通过一个编码在 URL 中的英雄 <code>id</code> 来告诉服务器应该更新哪个英雄。<code>put</code> 的 body 是该英雄的 JSON 字符串，它是通过调用<code>JSON.stringify</code>得到的。\n并且在请求头中标记出的 body 的内容类型（<code>application/<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>）。</p>\n<p translation-origin=\"off\">Refresh the browser, change a hero name, save your change,\nand click the browser Back button. Changes should now persist.</p>\n<p translation-result=\"\">刷新浏览器试一下，对英雄名字的修改确实已经被持久化了。</p>\n<h2 translation-origin=\"off\" id=\"add-the-ability-to-add-heroes\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-the-ability-to-add-heroes\"><i class=\"material-icons\">link</i></a>Add the ability to add heroes</h2>\n<h2 translation-result=\"\" id=\"添加英雄\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#添加英雄\"><i class=\"material-icons\">link</i></a>添加英雄</h2>\n<p translation-origin=\"off\">To add a hero, the app needs the hero's name. You can use an <code>input</code>\nelement paired with an add button.</p>\n<p translation-result=\"\">要添加一个新的英雄，我们得先知道英雄的名字。我们使用一个 <code>input</code> 元素和一个添加按钮来实现。</p>\n<p translation-origin=\"off\">Insert the following into the heroes component HTML, just after\nthe heading:</p>\n<p translation-result=\"\">把下列代码插入 heroes 组件的 HTML 中，放在标题的下面：</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.html\" region=\"add\" title=\"src/app/heroes.component.html (add)\">\n&#x3C;div>\n  &#x3C;label>Hero name:&#x3C;/label> &#x3C;input #heroName />\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    Add\n  &#x3C;/button>\n&#x3C;/div>\n\n</code-example>\n<p translation-origin=\"off\">In response to a click event, call the component's click handler and then\nclear the input field so that it's ready for another name.</p>\n<p translation-result=\"\">当点击事件触发时，我们调用组件的点击处理器，然后清空这个输入框，以便用来输入另一个名字。</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.ts\" region=\"add\" title=\"src/app/heroes.component.ts (add)\">\nadd(name: string): void {\n  name = name.trim();\n  if (!name) { return; }\n  this.heroService.create(name)\n    .then(hero => {\n      this.heroes.push(hero);\n      this.selectedHero = null;\n    });\n}\n\n</code-example>\n<p translation-origin=\"off\">When the given name is non-blank, the handler delegates creation of the\nnamed hero to the hero service, and then adds the new hero to the array.</p>\n<p translation-result=\"\">当指定的名字不为空的时候，点击处理器就会委托 hero 服务来创建一个具有此名字的英雄，\n并把这个新的英雄添加到我们的数组中。</p>\n<p translation-origin=\"off\">Implement the <code>create()</code> method in the <code>HeroService</code> class.</p>\n<p translation-result=\"\">然后，我们在<code>HeroService</code>类中实现这个<code>create()</code>方法。</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"create\" title=\"src/app/hero.service.ts (create)\">\ncreate(name: string): Promise&#x3C;Hero> {\n  return this.http\n    .post(this.heroesUrl, JSON.stringify({name: name}), {headers: this.headers})\n    .toPromise()\n    .then(res => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero)\n    .catch(this.handleError);\n}\n\n</code-example>\n<p translation-origin=\"off\">Refresh the browser and create some heroes.</p>\n<p translation-result=\"\">刷新浏览器，并创建一些新的英雄！</p>\n<h2 translation-origin=\"off\" id=\"add-the-ability-to-delete-a-hero\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-the-ability-to-delete-a-hero\"><i class=\"material-icons\">link</i></a>Add the ability to delete a hero</h2>\n<h2 translation-result=\"\" id=\"删除英雄\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#删除英雄\"><i class=\"material-icons\">link</i></a>删除英雄</h2>\n<p translation-origin=\"off\">Each hero in the heroes view should have a delete button.</p>\n<p translation-result=\"\">在英雄列表视图中的每个英雄都应该有一个删除按钮。</p>\n<p translation-origin=\"off\">Add the following button element to the heroes component HTML, after the hero\nname in the repeated <code>&#x3C;li></code> element.</p>\n<p translation-result=\"\">把这个按钮元素添加到英雄列表组件的 HTML 中，把它放在<code>&#x3C;li></code>标签中的英雄名的后面：</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.html\" region=\"delete\">\n&#x3C;button class=\"delete\"\n  (click)=\"delete(hero); $event.stopPropagation()\">x&#x3C;/button>\n\n</code-example>\n<p translation-origin=\"off\">The <code>&#x3C;li></code> element should now look like this:</p>\n<p translation-result=\"\"><code>&#x3C;li></code>元素应该变成了这样：</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.html\" region=\"li-element\" title=\"src/app/heroes.component.html (li-element)\">\n&#x3C;li *ngFor=\"let hero of heroes\" (click)=\"onSelect(hero)\"\n    [class.selected]=\"hero === selectedHero\">\n  &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span>\n  &#x3C;span>{{hero.name}}&#x3C;/span>\n  &#x3C;button class=\"delete\"\n    (click)=\"delete(hero); $event.stopPropagation()\">x&#x3C;/button>\n&#x3C;/li>\n\n</code-example>\n<p translation-origin=\"off\">In addition to calling the component's <code>delete()</code> method, the delete button's\nclick handler code stops the propagation of the click event—you\ndon't want the <code>&#x3C;li></code> click handler to be triggered because doing so would\nselect the hero that the user will delete.</p>\n<p translation-result=\"\">除了调用组件的<code>delete()</code>方法之外，这个删除按钮的点击处理器还应该阻止点击事件向上冒泡 —\n我们并不希望触发<code>&#x3C;li></code>的事件处理器，否则它会选中我们要删除的这位英雄。</p>\n<p translation-origin=\"off\">The logic of the <code>delete()</code> handler is a bit trickier:</p>\n<p translation-result=\"\"><code>delete()</code>处理器的逻辑略复杂：</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.ts\" region=\"delete\" title=\"src/app/heroes.component.ts (delete)\">\ndelete(hero: Hero): void {\n  this.heroService\n      .delete(hero.id)\n      .then(() => {\n        this.heroes = this.heroes.filter(h => h !== hero);\n        if (this.selectedHero === hero) { this.selectedHero = null; }\n      });\n}\n\n</code-example>\n<p translation-origin=\"off\">Of course you delegate hero deletion to the hero service, but the component\nis still responsible for updating the display: it removes the deleted hero\nfrom the array and resets the selected hero, if necessary.</p>\n<p translation-result=\"\">当然，我们仍然把删除英雄的操作委托给了 hero 服务，\n不过该组件仍然负责更新显示：它从数组中移除了被删除的英雄，如果删除的是正选中的英雄，还会清空选择。</p>\n<p translation-origin=\"off\">To place the delete button at the far right of the hero entry,\nadd this CSS:</p>\n<p translation-result=\"\">我们希望删除按钮被放在英雄条目的最右边。\n于是 CSS 变成了这样：</p>\n<code-example path=\"toh-pt6/src/app/heroes.component.css\" region=\"additions\" title=\"src/app/heroes.component.css (additions)\">\nbutton.delete {\n  float:right;\n  margin-top: 2px;\n  margin-right: .8em;\n  background-color: gray !important;\n  color:white;\n}\n\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"hero-service-delete-method\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#hero-service-delete-method\"><i class=\"material-icons\">link</i></a>Hero service <em>delete()</em> method</h3>\n<h3 translation-result=\"\" id=\"hero-服务的delete方法\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#hero-服务的delete方法\"><i class=\"material-icons\">link</i></a>hero 服务的<code>delete()</code>方法</h3>\n<p translation-origin=\"off\">Add the hero service's <code>delete()</code> method, which uses the <code>delete()</code> HTTP method to remove the hero from the server:</p>\n<p translation-result=\"\">hero 服务的<code>delete()</code>方法使用 HTTP 的 <code>delete()</code> 方法来从服务器上移除该英雄：</p>\n<code-example path=\"toh-pt6/src/app/hero.service.ts\" region=\"delete\" title=\"src/app/hero.service.ts (delete)\">\ndelete(id: number): Promise&#x3C;void> {\n  const url = `${this.heroesUrl}/${id}`;\n  return this.http.delete(url, {headers: this.headers})\n    .toPromise()\n    .then(() => null)\n    .catch(this.handleError);\n}\n\n</code-example>\n<p translation-origin=\"off\">Refresh the browser and try the new delete functionality.</p>\n<p translation-result=\"\">刷新浏览器，并试一下这个新的删除功能。</p>\n<h2 translation-origin=\"off\" id=\"observables\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#observables\"><i class=\"material-icons\">link</i></a>Observables</h2>\n<h2 translation-result=\"\" id=\"可观察对象-observable\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#可观察对象-observable\"><i class=\"material-icons\">link</i></a>可观察对象 (Observable)</h2>\n<p translation-origin=\"off\">Each <code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code> service method  returns an <code>Observable</code> of HTTP <code><a href=\"api/http/Response\" class=\"code-anchor\">Response</a></code> objects.</p>\n<p translation-result=\"\"><code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code>服务中的每个方法都返回一个 HTTP <code><a href=\"api/http/Response\" class=\"code-anchor\">Response</a></code>对象的<code>Observable</code>实例。</p>\n<p translation-origin=\"off\">The <code>HeroService</code> converts that <code>Observable</code> into a <code>Promise</code> and returns the promise to the caller.\nThis section shows you how, when, and why to return the <code>Observable</code> directly.</p>\n<p translation-result=\"\">我们的<code>HeroService</code>中把那个<code>Observable</code>对象转换成了<code>Promise</code>（承诺），并把这个承诺返回给了调用者。\n这一节，我们将学会直接返回<code>Observable</code>，并且讨论何时以及为何那样做会更好。</p>\n<h3 translation-origin=\"off\" id=\"background\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#background\"><i class=\"material-icons\">link</i></a>Background</h3>\n<h3 translation-result=\"\" id=\"背景\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#背景\"><i class=\"material-icons\">link</i></a>背景</h3>\n<p translation-origin=\"off\">An <em>Observable</em> is a stream of events that you can process with array-like operators.</p>\n<p translation-result=\"\">一个<em>可观察对象</em>是一个事件流，我们可以用数组型操作符来处理它。</p>\n<p translation-origin=\"off\">Angular core has basic support for observables.\nDevelopers augment that support with operators and extensions from the\n<a href=\"http://reactivex.io/rxjs\" target=\"_blank\" title=\"RxJS\">RxJS library</a>.\nYou'll see how shortly.</p>\n<p translation-result=\"\">Angular 内核中提供了对可观察对象的基本支持。而我们这些开发人员可以自己从 <a href=\"http://reactivex.io/rxjs\" target=\"_blank\" title=\"RxJS\">RxJS</a> 库中引入操作符和扩展。\n我们会简短的讲解下如何做。</p>\n<p translation-origin=\"off\">Recall that the <code>HeroService</code>  chained the <code>toPromise</code> operator to the <code>Observable</code> result of <code>http.get()</code>.\nThat operator converted the <code>Observable</code> into a <code>Promise</code> and you passed that promise back to the caller.</p>\n<p translation-result=\"\">快速回忆一下<code>HeroService</code>，它在<code>http.get()</code>返回的<code>Observable</code>后面串联了一个<code>toPromise</code>操作符。\n该操作符把<code>Observable</code>转换成了<code>Promise</code>，并且我们把那个承诺返回给了调用者。</p>\n<p translation-origin=\"off\">Converting to a Promise is often a good choice. You typically ask <code>http.get()</code> to fetch a single chunk of data.\nWhen you receive the data, you're done.\nThe calling component can easily consume a single result in the form of a Promise.</p>\n<p translation-result=\"\">转换成承诺通常是更好地选择，我们通常会要求<code>http.get()</code>获取单块数据。只要接收到数据，就算完成。\n使用承诺这种形式的结果是让调用方更容易写，并且承诺已经在 JavaScript 程序员中被广泛接受了。</p>\n<p translation-origin=\"off\">But requests aren't always done only once.\nYou may start one request,\ncancel it, and make a different request before the server has responded to the first request.</p>\n<p translation-result=\"\">但是请求并非总是“一次性”的。我们可以开始一个请求，\n并且取消它，在服务器对第一个请求作出回应之前，再开始另一个不同的请求 。\n像这样一个<em>请求-取消-新请求</em>的序列用<em>承诺</em>是很难实现的，但接下来我们会看到，它对于<em>可观察对象</em>却很简单。</p>\n<p translation-origin=\"off\">A <em>request-cancel-new-request</em> sequence is difficult to implement with <code>Promise</code>s, but\neasy with <code>Observable</code>s.</p>\n<p translation-result=\"\"><em>请求-取消-新请求</em>的序列对于<code>Promise</code>来说是很难实现的，但是对<code>Observable</code>来说则很容易。</p>\n<h3 translation-origin=\"off\" id=\"add-the-ability-to-search-by-name\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-the-ability-to-search-by-name\"><i class=\"material-icons\">link</i></a>Add the ability to search by name</h3>\n<h3 translation-result=\"\" id=\"支持按名搜索\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#支持按名搜索\"><i class=\"material-icons\">link</i></a>支持按名搜索</h3>\n<p translation-origin=\"off\">You're going to add a <em>hero search</em> feature to the Tour of Heroes.\nAs the user types a name into a search box, you'll make repeated HTTP requests for heroes filtered by that name.</p>\n<p translation-result=\"\">我们要为《英雄指南》添加一个<em>英雄搜索</em>特性。\n当用户在搜索框中输入一个名字时，我们将不断发起 HTTP 请求，以获得按名字过滤的英雄。</p>\n<p translation-origin=\"off\">Start by creating <code>HeroSearchService</code> that sends search queries to the server's web API.</p>\n<p translation-result=\"\">我们先创建<code>HeroSearchService</code>服务，它会把搜索请求发送到我们服务器上的 Web API。</p>\n<code-example path=\"toh-pt6/src/app/hero-search.service.ts\" title=\"src/app/hero-search.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> }       from '@angular/http';\n\nimport { Observable }     from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Hero }           from './hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroSearchService {\n\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) {}\n\n  search(term: string): Observable&#x3C;Hero[]> {\n    return this.http\n               .get(`api/heroes/?name=${term}`)\n               .map(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero[]);\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">The <code>http.get()</code> call in <code>HeroSearchService</code> is similar to the one\nin the <code>HeroService</code>, although the URL now has a query string.</p>\n<p translation-result=\"\"><code>HeroSearchService</code>中的<code>http.get()</code>调用和<code>HeroService</code>中的很相似，只是这次带了查询字符串。</p>\n<p translation-origin=\"off\">More importantly, you no longer call <code>toPromise()</code>.\nInstead you return the <em>Observable</em> from the the <code>http.get()</code>,\nafter chaining it to another RxJS operator, <code>map()</code>,\nto extract heroes from the response data.</p>\n<p translation-result=\"\">更重要的是：我们不再调用<code>toPromise</code>方法，而是从<code>http.get</code>\n方法中返回一个<em>Observable</em>对象，之后调用RxJS的<code>map</code>操作符\n来从返回数据中提取英雄。  </p>\n<p translation-origin=\"off\">RxJS operator chaining makes response processing easy and readable.\nSee the <a href=\"tutorial/toh-pt6#rxjs-imports\">discussion below about operators</a>.</p>\n<p translation-result=\"\">链式RxJS操作可以让我们简单、易读的处理响应数据。详见<a href=\"tutorial/toh-pt6#rxjs-imports\">下面关于操作符的讨论</a></p>\n<h3 translation-origin=\"off\" id=\"herosearchcomponent\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent\"><i class=\"material-icons\">link</i></a>HeroSearchComponent</h3>\n<h3 translation-result=\"\" id=\"herosearchcomponent-组件\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#herosearchcomponent-组件\"><i class=\"material-icons\">link</i></a>HeroSearchComponent 组件</h3>\n<p translation-origin=\"off\">Let's create a new <code>HeroSearchComponent</code> that calls this new <code>HeroSearchService</code>.</p>\n<p translation-result=\"\">我们再创建一个新的<code>HeroSearchComponent</code>来调用这个新的<code>HeroSearchService</code>。</p>\n<p translation-origin=\"off\">The component template is simple—just a text box and a list of matching search results.</p>\n<p translation-result=\"\">组件模板很简单，就是一个输入框和一个显示匹配的搜索结果的列表。</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.html\" title=\"src/app/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>Hero Search&#x3C;/h4>\n  &#x3C;input #searchBox id=\"search-box\" (keyup)=\"search(searchBox.value)\" />\n  &#x3C;div>\n    &#x3C;div *ngFor=\"let hero of heroes | async\"\n         (click)=\"gotoDetail(hero)\" class=\"search-result\" >\n      {{hero.name}}\n    &#x3C;/div>\n  &#x3C;/div>\n&#x3C;/div>\n\n\n</code-example>\n<p translation-origin=\"off\">Also, add styles for the new component.</p>\n<p translation-result=\"\">我们还要往这个新组件中添加样式。</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.css\" title=\"src/app/hero-search.component.css\">\n.search-result{\n  border-bottom: 1px solid gray;\n  border-left: 1px solid gray;\n  border-right: 1px solid gray;\n  width:195px;\n  height: 16px;\n  padding: 5px;\n  background-color: white;\n  cursor: pointer;\n}\n\n.search-result:hover {\n  color: #eee;\n  background-color: #607D8B;\n}\n\n#search-box{\n  width: 200px;\n  height: 20px;\n}\n\n\n</code-example>\n<p translation-origin=\"off\">As the user types in the search box, a <em>keyup</em> event binding calls the component's <code>search()</code>\nmethod with the new search box value.</p>\n<p translation-result=\"\">当用户在搜索框中输入时，一个 <em>keyup</em> 事件绑定会调用该组件的<code>search()</code>方法，并传入新的搜索框的值。</p>\n<p translation-origin=\"off\">As expected, the <code>*ngFor</code> repeats hero objects from the component's <code>heroes</code> property.</p>\n<p translation-result=\"\">不出所料，<code>*ngFor</code>从该组件的<code>heroes</code>属性重复获取 <em>hero</em> 对象。这也没啥特别的。</p>\n<p translation-origin=\"off\">But as you'll soon see, the <code>heroes</code> property is now an <em>Observable</em> of hero arrays, rather than just a hero array.\nThe <code>*ngFor</code> can't do anything with an <code>Observable</code> until you route it through the <code>async</code> pipe (<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>).\nThe <code>async</code> pipe subscribes to the <code>Observable</code> and produces the array of heroes to <code>*ngFor</code>.</p>\n<p translation-result=\"\">但是，接下来我们看到<code>heroes</code>属性现在是英雄列表的<code>Observable</code>对象，而不再只是英雄数组。\n<code>*ngFor</code>不能用可观察对象做任何事，除非我们在它后面跟一个<code>async</code> pipe (<code><a href=\"api/common/AsyncPipe\" class=\"code-anchor\">AsyncPipe</a></code>)。\n这个<code>async</code>管道会订阅到这个可观察对象，并且为<code>*ngFor</code>生成一个英雄数组。</p>\n<p translation-origin=\"off\">Create the <code>HeroSearchComponent</code> class and metadata.</p>\n<p translation-result=\"\">该创建<code>HeroSearchComponent</code>类及其元数据了。</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.ts\" title=\"src/app/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> }            from '@angular/router';\n\nimport { Observable }        from 'rxjs/Observable';\nimport { Subject }           from 'rxjs/Subject';\n\n// Observable class extensions\nimport 'rxjs/add/observable/of';\n\n// Observable operators\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/distinctUntilChanged';\n\nimport { HeroSearchService } from './hero-search.service';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-search',\n  templateUrl: './hero-search.component.html',\n  styleUrls: [ './hero-search.component.css' ],\n  providers: [HeroSearchService]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(\n    private heroSearchService: HeroSearchService,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  // Push a search term into the observable stream.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes = this.searchTerms\n      .debounceTime(300)        // wait 300ms after each keystroke before considering the term\n      .distinctUntilChanged()   // ignore if next search term is same as previous\n      .switchMap(term => term   // switch to new observable each time the term changes\n        // return the http search observable\n        ? this.heroSearchService.search(term)\n        // or the observable of empty heroes if there was no search term\n        : Observable.of&#x3C;Hero[]>([]))\n      .catch(error => {\n        // TODO: add real error handling\n        console.log(error);\n        return Observable.of&#x3C;Hero[]>([]);\n      });\n  }\n\n  gotoDetail(hero: Hero): void {\n    let link = ['/detail', hero.id];\n    this.router.navigate(link);\n  }\n}\n\n\n</code-example>\n<h4 translation-origin=\"off\" id=\"search-terms\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#search-terms\"><i class=\"material-icons\">link</i></a>Search terms</h4>\n<h4 translation-result=\"\" id=\"搜索词\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#搜索词\"><i class=\"material-icons\">link</i></a>搜索词</h4>\n<p translation-origin=\"off\">Focus on the <code>searchTerms</code>:</p>\n<p translation-result=\"\">仔细看下这个<code>searchTerms</code>：</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.ts\" region=\"searchTerms\">\nprivate searchTerms = new Subject&#x3C;string>();\n\n// Push a search term into the observable stream.\nsearch(term: string): void {\n  this.searchTerms.next(term);\n}\n\n</code-example>\n<p translation-origin=\"off\">A <code>Subject</code> is a producer of an <em>observable</em> event stream;\n<code>searchTerms</code> produces an <code>Observable</code> of strings, the filter criteria for the name search.</p>\n<p translation-result=\"\">  <code>Subject</code>（主题）是一个<em>可观察的</em>事件流中的生产者。\n<code>searchTerms</code>生成一个产生字符串的<code>Observable</code>，用作按名称搜索时的过滤条件。Each call to <code>search()</code> puts a new string into this subject's <em>observable</em> stream by calling <code>next()</code>.</p>\n<p translation-result=\"\">  每当调用<code>search()</code>时都会调用<code>next()</code>来把新的字符串放进该主题的<em>可观察</em>流中。</p>\n<a id=\"ngoninit\"></a>\n<h4 translation-origin=\"off\" id=\"initialize-the-heroes-property-ngoninit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#initialize-the-heroes-property-ngoninit\"><i class=\"material-icons\">link</i></a>Initialize the <em>heroes</em> property (<em>ngOnInit</em>)</h4>\n<h4 translation-result=\"\" id=\"初始化-heroes-属性ngoninit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#初始化-heroes-属性ngoninit\"><i class=\"material-icons\">link</i></a>初始化 <em>heroes</em> 属性(<em>ngOnInit</em>)</h4>\n<p translation-origin=\"off\">A <code>Subject</code> is also an <code>Observable</code>.\nYou can turn the stream\nof search terms into a stream of <code>Hero</code> arrays and assign the result to the <code>heroes</code> property.</p>\n<p translation-result=\"\"><code>Subject</code>也是一个<code>Observable</code>对象。\n我们要把搜索词的流转换成<code>Hero</code>数组的流，并把结果赋值给<code>heroes</code>属性。</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.ts\" region=\"search\">\nheroes: Observable&#x3C;Hero[]>;\n\nngOnInit(): void {\n  this.heroes = this.searchTerms\n    .debounceTime(300)        // wait 300ms after each keystroke before considering the term\n    .distinctUntilChanged()   // ignore if next search term is same as previous\n    .switchMap(term => term   // switch to new observable each time the term changes\n      // return the http search observable\n      ? this.heroSearchService.search(term)\n      // or the observable of empty heroes if there was no search term\n      : Observable.of&#x3C;Hero[]>([]))\n    .catch(error => {\n      // TODO: add real error handling\n      console.log(error);\n      return Observable.of&#x3C;Hero[]>([]);\n    });\n}\n\n</code-example>\n<p translation-origin=\"off\">Passing every user keystroke directly to the <code>HeroSearchService</code> would create an excessive amount of HTTP requests,\ntaxing server resources and burning through the cellular network data plan.</p>\n<p translation-result=\"\">如果我们直接把每一次用户按键都直接传给<code>HeroSearchService</code>，就会发起一场 HTTP 请求风暴。\n这可不好玩。我们不希望占用服务器资源，也不想耗光蜂窝移动网络的流量。</p>\n<p translation-origin=\"off\">Instead, you can chain <code>Observable</code> operators that reduce the request flow to the string <code>Observable</code>.\nYou'll make fewer calls to the <code>HeroSearchService</code> and still get timely results. Here's how:</p>\n<p translation-result=\"\">不过，我们可以在字符串的<code>Observable</code>后面串联一些<code>Observable</code>操作符，来归并这些请求。\n我们将对<code>HeroSearchService</code>发起更少的调用，并且仍然获得足够及时的响应。做法如下：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>debounceTime(300)</code> waits until the flow of new string events pauses for 300 milliseconds\nbefore passing along the latest string. You'll never make requests more frequently than 300ms.</p>\n<p translation-result=\"\">  在传出最终字符串之前，<code>debounceTime(300)</code>将会等待，直到新增字符串的事件暂停了 300 毫秒。\n我们实际发起请求的间隔永远不会小于 300ms。\n</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>distinctUntilChanged</code> ensures that a request is sent only if the filter text changed.</p>\n<p translation-result=\"\"><code>distinctUntilChanged</code>确保只在过滤条件变化时才发送请求，\n这样就不会重复请求同一个搜索词了。\n</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>switchMap()</code> calls the search service for each search term that makes it through <code>debounce</code> and <code>distinctUntilChanged</code>.\nIt cancels and discards previous search observables, returning only the latest search service observable.</p>\n<p translation-result=\"\">  <code>switchMap()</code>会为每个从<code>debounce</code>和<code>distinctUntilChanged</code>中通过的搜索词调用搜索服务。\n它会取消并丢弃以前的搜索可观察对象，只保留最近的。</p>\n</li>\n</ul>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">  With the <a href=\"http://www.learnrxjs.io/operators/transformation/switchmap.html\">switchMap operator</a>\n(formerly known as <code>flatMapLatest</code>),\nevery qualifying key event can trigger an <code>http()</code> method call.\nEven with a 300ms pause between requests, you could have multiple HTTP requests in flight\nand they may not return in the order sent.</p>\n<p translation-result=\"\">借助<a href=\"http://www.learnrxjs.io/operators/transformation/switchmap.html\">switchMap操作符</a>\n(正式名称是<code>flatMapLatest</code>)\n每次符合条件的按键事件都会触发一次对<code>http()</code>方法的调用。即使在发送每个请求前都有 300 毫秒的延迟，\n我们仍然可能同时拥有多个在途的 HTTP 请求，并且它们返回的顺序未必就是发送时的顺序。<code>switchMap()</code> preserves the original request order while returning\nonly the observable from the most recent <code>http</code> method call.\nResults from prior calls are canceled and discarded.</p>\n<p translation-result=\"\"><code>switchMap()</code>保留了原始的请求顺序，并且只返回最近一次 <code>http</code> 调用返回的可观察对象。\n这是因为以前的调用都被取消或丢弃了。If the search text is empty, the <code>http()</code> method call is also short circuited\nand an observable containing an empty array is returned.</p>\n<p translation-result=\"\">如果搜索框为空，我们还可以短路掉这次<code>http()</code>方法调用，并且直接返回一个包含空数组的可观察对象。Note that until the service supports that feature, <em>canceling</em> the <code>HeroSearchService</code> Observable\ndoesn't actually abort a pending HTTP request.\nFor now, unwanted results are discarded.</p>\n<p translation-result=\"\">注意，<em>取消</em><code>HeroSearchService</code>的可观察对象并不会实际中止 (abort) 一个未完成的 HTTP 请求，\n除非服务支持这个特性，这个问题我们以后再讨论。\n目前我们的做法只是丢弃不希望的结果。</p>\n</div>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>catch</code> intercepts a failed observable.\nThe simple example prints the error to the console; a real life app would do better.\nThen to clear the search result, you return an observable containing an empty array .</p>\n<p translation-result=\"\">  <code>catch</code>拦截失败的可观察对象。这个简单的例子中只是把错误信息打印到控制台（但实际的应用需要做更多事），然后返回一个包含空数组的可观察对象，以清空搜索结果。</p>\n</li>\n</ul>\n<a id=\"rxjs-imports\"></a>\n<h3 translation-origin=\"off\" id=\"import-rxjs-operators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#import-rxjs-operators\"><i class=\"material-icons\">link</i></a>Import RxJS operators</h3>\n<h3 translation-result=\"\" id=\"导入-rxjs-操作符\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#导入-rxjs-操作符\"><i class=\"material-icons\">link</i></a>导入 RxJS 操作符</h3>\n<p translation-origin=\"off\">Most RxJS operators are not included in Angular's base <code>Observable</code> implementation.\nThe base implementation includes only what Angular itself requires.</p>\n<p translation-result=\"\">大部分RxJS操作符都不包括在Angular的<code>Observable</code>基本实现中，基本实现只包括Angular本身所需的功能。</p>\n<p translation-origin=\"off\">When you need more RxJS features, extend  <code>Observable</code> by <em>importing</em> the libraries in which they are defined.\nHere are all the RxJS imports that <em>this</em> component needs:</p>\n<p translation-result=\"\">如果想要更多的RxJS功能，我们必须<em>导入</em>其所定义的库来扩展<code>Observable</code>对象，\n以下是<em>这个</em>模块所需导入的所有RxJS操作符：</p>\n<code-example path=\"toh-pt6/src/app/hero-search.component.ts\" region=\"rxjs-imports\" title=\"src/app/hero-search.component.ts (rxjs imports)\" linenums=\"false\">\nimport { Observable }        from 'rxjs/Observable';\nimport { Subject }           from 'rxjs/Subject';\n\n// Observable class extensions\nimport 'rxjs/add/observable/of';\n\n// Observable operators\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/distinctUntilChanged';\n\n</code-example>\n<p translation-origin=\"off\">The <code>import 'rxjs/add/...'</code> syntax may be unfamiliar.\nIt's missing the usual list of symbols between the braces: <code>{...}</code>.</p>\n<p translation-result=\"\">你可能并不熟悉这种<code>import 'rxjs/add/...'</code>语法，它缺少了花括号中的导入列表：<code>{...}</code>。</p>\n<p translation-origin=\"off\">You don't need the operator symbols themselves.\nIn each case, the mere act of importing the library\nloads and executes the library's script file which, in turn, adds the operator to the <code>Observable</code> class.</p>\n<p translation-result=\"\">这是因为我们并不需要操作符本身，这种情况下，我们所做的其实是导入这个库，加载并运行其中的脚本，\n它会把操作符添加到<code>Observable</code>类中。</p>\n<h3 translation-origin=\"off\" id=\"add-the-search-component-to-the-dashboard\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#add-the-search-component-to-the-dashboard\"><i class=\"material-icons\">link</i></a>Add the search component to the dashboard</h3>\n<h3 translation-result=\"\" id=\"为仪表盘添加搜索组件\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#为仪表盘添加搜索组件\"><i class=\"material-icons\">link</i></a>为仪表盘添加搜索组件</h3>\n<p translation-origin=\"off\">Add the hero search HTML element to the bottom of the <code>DashboardComponent</code> template.</p>\n<p translation-result=\"\">将表示“英雄搜索”组件的 HTML 元素添加到<code>DashboardComponent</code>模版的最后面。</p>\n<code-example path=\"toh-pt6/src/app/dashboard.component.html\" title=\"src/app/dashboard.component.html\" linenums=\"false\">\n&#x3C;h3>Top Heroes&#x3C;/h3>\n&#x3C;div class=\"grid grid-pad\">\n  &#x3C;a *ngFor=\"let hero of heroes\"  [routerLink]=\"['/detail', hero.id]\"  class=\"col-1-4\">\n    &#x3C;div class=\"module hero\">\n      &#x3C;h4>{{hero.name}}&#x3C;/h4>\n    &#x3C;/div>\n  &#x3C;/a>\n&#x3C;/div>\n&#x3C;hero-search>&#x3C;/hero-search>\n\n\n</code-example>\n<p translation-origin=\"off\">Finally, import <code>HeroSearchComponent</code> from\n<code>hero-search.component.ts</code>\nand add it to the <code>declarations</code> array.</p>\n<p translation-result=\"\">最后，从<span ngio-ex=\"\">hero-search.component.ts</span>中导入<code>HeroSearchComponent</code>并将其添加到<code>declarations</code>数组中。</p>\n<code-example path=\"toh-pt6/src/app/app.module.ts\" region=\"search\" title=\"src/app/app.module.ts (search)\">\ndeclarations: [\n  AppComponent,\n  DashboardComponent,\n  HeroDetailComponent,\n  HeroesComponent,\n  HeroSearchComponent\n],\n\n</code-example>\n<p translation-origin=\"off\">Run the app again. In the Dashboard, enter some text in the search box.\nIf you enter characters that match any existing hero names, you'll see something like this.</p>\n<p translation-result=\"\">再次运行该应用，跳转到<em>仪表盘</em>，并在英雄下方的搜索框里输入一些文本。\n运行效果如下：</p>\n<figure>\n  <img src=\"generated/images/guide/toh/toh-hero-search.png\" alt=\"Hero Search Component\" width=\"240\" height=\"224\">\n</figure>\n<h2 translation-origin=\"off\" id=\"app-structure-and-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#app-structure-and-code\"><i class=\"material-icons\">link</i></a>App structure and code</h2>\n<h2 translation-result=\"\" id=\"应用的结构与代码\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#应用的结构与代码\"><i class=\"material-icons\">link</i></a>应用的结构与代码</h2>\n<p translation-origin=\"off\">Review the sample source code in the <live-example></live-example> for this page.\nVerify that you have the following structure:</p>\n<p translation-result=\"\">回顾一下本章<live-example></live-example>中的范例代码。\n验证我们是否得到了如下结构：</p>\n<div class=\"filetree\">\n  <div class=\"file\">angular-tour-of-heroes</div>\n  <div class=\"children\">\n    <div class=\"file\">src</div>\n    <div class=\"children\">\n      <div class=\"file\">app</div>\n      <div class=\"children\">\n        <div class=\"file\">app.component.ts</div>\n        <div class=\"file\">app.component.css</div>\n        <div class=\"file\">app.module.ts</div>\n        <div class=\"file\">app-routing.module.ts</div>\n        <div class=\"file\">dashboard.component.css</div>\n        <div class=\"file\">dashboard.component.html</div>\n        <div class=\"file\">dashboard.component.ts</div>\n        <div class=\"file\">hero.ts</div>\n        <div class=\"file\">hero-detail.component.css</div>\n        <div class=\"file\">hero-detail.component.html</div>\n        <div class=\"file\">hero-detail.component.ts</div>\n        <div class=\"file\">hero-search.component.html (new)</div>\n        <div class=\"file\">hero-search.component.css (new)</div>\n        <div class=\"file\">hero-search.component.ts (new)</div>\n        <div class=\"file\">hero-search.service.ts (new)</div>\n        <div class=\"file\">hero.service.ts</div>\n        <div class=\"file\">heroes.component.css</div>\n        <div class=\"file\">heroes.component.html</div>\n        <div class=\"file\">heroes.component.ts</div>\n        <div class=\"file\">in-memory-data.service.ts (new)</div>\n      </div>\n      <div class=\"file\">main.ts</div>\n      <div class=\"file\">index.html</div>\n      <div class=\"file\">styles.css</div>\n      <div class=\"file\">systemjs.config.js</div>\n      <div class=\"file\">tsconfig.json</div>\n    </div>\n    <div class=\"file\">node_modules ...</div>\n    <div class=\"file\">package.json</div>\n  </div>\n</div>\n<h2 translation-origin=\"off\" id=\"summary\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#summary\"><i class=\"material-icons\">link</i></a>Summary</h2>\n<h2 translation-result=\"\" id=\"最后冲刺\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#最后冲刺\"><i class=\"material-icons\">link</i></a>最后冲刺</h2>\n<p translation-origin=\"off\">You're at the end of your journey, and you've accomplished a lot.</p>\n<p translation-result=\"\">旅程即将结束，不过我们已经收获颇丰。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">You added the necessary dependencies to use HTTP in the app.</p>\n<p translation-result=\"\">我们添加了在应用程序中使用 HTTP 的必备依赖。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You refactored <code>HeroService</code> to load heroes from a web API.</p>\n<p translation-result=\"\">我们重构了<code>HeroService</code>，以通过 web API 来加载英雄数据。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You extended <code>HeroService</code> to support <code>post()</code>, <code>put()</code>, and <code>delete()</code> methods.</p>\n<p translation-result=\"\">我们扩展了<code>HeroService</code>来支持 <code>post()</code>、<code>put()</code> 和 <code>delete()</code> 方法。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You updated the components to allow adding, editing, and deleting of heroes.</p>\n<p translation-result=\"\">我们更新了组件，以允许用户添加、编辑和删除英雄。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You configured an in-memory web API.</p>\n<p translation-result=\"\">我们配置了一个内存 Web API。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You learned how to use Observables.</p>\n<p translation-result=\"\">我们学会了如何使用“可观察对象”。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Here are the files you added or changed in this page.</p>\n<p translation-result=\"\">下面是我们<strong>添加或修改</strong>之后的文件汇总。</p>\n<code-tabs>\n  <code-pane title=\"app.comp...ts\" path=\"toh-pt6/src/app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }          from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-app',\n  template: `\n    &#x3C;h1>{{title}}&#x3C;/h1>\n    &#x3C;nav>\n      &#x3C;a routerLink=\"/dashboard\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Dashboard&#x3C;/a>\n      &#x3C;a routerLink=\"/heroes\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n    &#x3C;/nav>\n    &#x3C;router-outlet>&#x3C;/router-outlet>\n  `,\n  styleUrls: ['./app.component.css']\n})\nexport class AppComponent {\n  title = 'Tour of Heroes';\n}\n\n\n</code-pane>\n  <code-pane title=\"app.mod...ts\" path=\"toh-pt6/src/app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }      from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }   from '@angular/forms';\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> }    from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\n\n// Imports for loading &#x26; configuring the in-memory web api\nimport { InMemoryWebApiModule } from 'angular-in-memory-web-api';\nimport { InMemoryDataService }  from './in-memory-data.service';\n\nimport { AppComponent }         from './app.component';\nimport { DashboardComponent }   from './dashboard.component';\nimport { HeroesComponent }      from './heroes.component';\nimport { HeroDetailComponent }  from './hero-detail.component';\nimport { HeroService }          from './hero.service';\nimport { HeroSearchComponent }  from './hero-search.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    InMemoryWebApiModule.forRoot(InMemoryDataService),\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    DashboardComponent,\n    HeroDetailComponent,\n    HeroesComponent,\n    HeroSearchComponent\n  ],\n  providers: [ HeroService ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n  <code-pane title=\"heroes.comp...ts\" path=\"toh-pt6/src/app/heroes.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> }            from '@angular/router';\n\nimport { Hero }                from './hero';\nimport { HeroService }         from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-heroes',\n  templateUrl: './heroes.component.html',\n  styleUrls: [ './heroes.component.css' ]\n})\nexport class HeroesComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes: Hero[];\n  selectedHero: Hero;\n\n  constructor(\n    private heroService: HeroService,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) { }\n\n  getHeroes(): void {\n    this.heroService\n        .getHeroes()\n        .then(heroes => this.heroes = heroes);\n  }\n\n  add(name: string): void {\n    name = name.trim();\n    if (!name) { return; }\n    this.heroService.create(name)\n      .then(hero => {\n        this.heroes.push(hero);\n        this.selectedHero = null;\n      });\n  }\n\n  delete(hero: Hero): void {\n    this.heroService\n        .delete(hero.id)\n        .then(() => {\n          this.heroes = this.heroes.filter(h => h !== hero);\n          if (this.selectedHero === hero) { this.selectedHero = null; }\n        });\n  }\n\n  ngOnInit(): void {\n    this.getHeroes();\n  }\n\n  onSelect(hero: Hero): void {\n    this.selectedHero = hero;\n  }\n\n  gotoDetail(): void {\n    this.router.navigate(['/detail', this.selectedHero.id]);\n  }\n}\n\n\n</code-pane>\n  <code-pane title=\"heroes.comp...html\" path=\"toh-pt6/src/app/heroes.component.html\">\n&#x3C;h2>My Heroes&#x3C;/h2>\n&#x3C;div>\n  &#x3C;label>Hero name:&#x3C;/label> &#x3C;input #heroName />\n  &#x3C;button (click)=\"add(heroName.value); heroName.value=''\">\n    Add\n  &#x3C;/button>\n&#x3C;/div>\n&#x3C;ul class=\"heroes\">\n  &#x3C;li *ngFor=\"let hero of heroes\" (click)=\"onSelect(hero)\"\n      [class.selected]=\"hero === selectedHero\">\n    &#x3C;span class=\"badge\">{{hero.id}}&#x3C;/span>\n    &#x3C;span>{{hero.name}}&#x3C;/span>\n    &#x3C;button class=\"delete\"\n      (click)=\"delete(hero); $event.stopPropagation()\">x&#x3C;/button>\n  &#x3C;/li>\n&#x3C;/ul>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"selectedHero\">\n  &#x3C;h2>\n    {{selectedHero.name | <a href=\"api/common/UpperCasePipe\" class=\"code-anchor\">uppercase</a>}} is my hero\n  &#x3C;/h2>\n  &#x3C;button (click)=\"gotoDetail()\">View Details&#x3C;/button>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane title=\"heroes.comp...css\" path=\"toh-pt6/src/app/heroes.component.css\">\n.selected {\n  background-color: #CFD8DC !important;\n  color: white;\n}\n.heroes {\n  margin: 0 0 2em 0;\n  list-style-type: none;\n  padding: 0;\n  width: 15em;\n}\n.heroes li {\n  cursor: pointer;\n  position: relative;\n  left: 0;\n  background-color: #EEE;\n  margin: .5em;\n  padding: .3em 0;\n  height: 1.6em;\n  border-radius: 4px;\n}\n.heroes li:hover {\n  color: #607D8B;\n  background-color: #DDD;\n  left: .1em;\n}\n.heroes li.selected:hover {\n  background-color: #BBD8DC !important;\n  color: white;\n}\n.heroes .text {\n  position: relative;\n  top: -3px;\n}\n.heroes .badge {\n  display: inline-block;\n  font-size: small;\n  color: white;\n  padding: 0.8em 0.7em 0 0.7em;\n  background-color: #607D8B;\n  line-height: 1em;\n  position: relative;\n  left: -1px;\n  top: -4px;\n  height: 1.8em;\n  margin-right: .8em;\n  border-radius: 4px 0 0 4px;\n}\nbutton {\n  font-family: Arial;\n  background-color: #eee;\n  border: none;\n  padding: 5px 10px;\n  border-radius: 4px;\n  cursor: pointer;\n  cursor: hand;\n}\nbutton:hover {\n  background-color: #cfd8dc;\n}\nbutton.delete {\n  float:right;\n  margin-top: 2px;\n  margin-right: .8em;\n  background-color: gray !important;\n  color:white;\n}\n\n\n</code-pane>\n  <code-pane title=\"hero-detail.comp...ts\" path=\"toh-pt6/src/app/hero-detail.component.ts\">\nimport 'rxjs/add/operator/switchMap';\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> }        from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a> } from '@angular/router';\nimport { <a href=\"api/common/Location\" class=\"code-anchor\">Location</a> }                 from '@angular/common';\n\nimport { Hero }        from './hero';\nimport { HeroService } from './hero.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  templateUrl: './hero-detail.component.html',\n  styleUrls: [ './hero-detail.component.css' ]\n})\nexport class HeroDetailComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  hero: Hero;\n\n  constructor(\n    private heroService: HeroService,\n    private route: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>,\n    private location: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>\n  ) {}\n\n  ngOnInit(): void {\n    this.route.paramMap\n      .switchMap((params: <a href=\"api/router/ParamMap\" class=\"code-anchor\">ParamMap</a>) => this.heroService.getHero(+params.get('id')))\n      .subscribe(hero => this.hero = hero);\n  }\n\n  save(): void {\n    this.heroService.update(this.hero)\n      .then(() => this.goBack());\n  }\n\n  goBack(): void {\n    this.location.back();\n  }\n}\n\n\n</code-pane>\n  <code-pane title=\"hero-detail.comp...html\" path=\"toh-pt6/src/app/hero-detail.component.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"hero\">\n  &#x3C;h2>{{hero.name}} details!&#x3C;/h2>\n  &#x3C;div>\n    &#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n  &#x3C;div>\n    &#x3C;label>name: &#x3C;/label>\n    &#x3C;input [(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]=\"hero.name\" placeholder=\"name\" />\n   &#x3C;/div>\n  &#x3C;button (click)=\"goBack()\">Back&#x3C;/button>\n  &#x3C;button (click)=\"save()\">Save&#x3C;/button>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane title=\"hero.service.ts\" path=\"toh-pt6/src/app/hero.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> }    from '@angular/core';\nimport { <a href=\"api/http/Headers\" class=\"code-anchor\">Headers</a>, <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> } from '@angular/http';\n\nimport 'rxjs/add/operator/toPromise';\n\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroService {\n\n  private headers = new <a href=\"api/http/Headers\" class=\"code-anchor\">Headers</a>({'Content-<a href=\"api/core/Type\" class=\"code-anchor\">Type</a>': 'application/<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>'});\n  private heroesUrl = 'api/heroes';  // URL to web api\n\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) { }\n\n  getHeroes(): Promise&#x3C;Hero[]> {\n    return this.http.get(this.heroesUrl)\n               .toPromise()\n               .then(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero[])\n               .catch(this.handleError);\n  }\n\n\n  getHero(id: number): Promise&#x3C;Hero> {\n    const url = `${this.heroesUrl}/${id}`;\n    return this.http.get(url)\n      .toPromise()\n      .then(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero)\n      .catch(this.handleError);\n  }\n\n  delete(id: number): Promise&#x3C;void> {\n    const url = `${this.heroesUrl}/${id}`;\n    return this.http.delete(url, {headers: this.headers})\n      .toPromise()\n      .then(() => null)\n      .catch(this.handleError);\n  }\n\n  create(name: string): Promise&#x3C;Hero> {\n    return this.http\n      .post(this.heroesUrl, JSON.stringify({name: name}), {headers: this.headers})\n      .toPromise()\n      .then(res => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero)\n      .catch(this.handleError);\n  }\n\n  update(hero: Hero): Promise&#x3C;Hero> {\n    const url = `${this.heroesUrl}/${hero.id}`;\n    return this.http\n      .put(url, JSON.stringify(hero), {headers: this.headers})\n      .toPromise()\n      .then(() => hero)\n      .catch(this.handleError);\n  }\n\n  private handleError(error: any): Promise&#x3C;any> {\n    console.error('An error occurred', error); // for demo purposes only\n    return Promise.reject(error.message || error);\n  }\n}\n\n\n\n</code-pane>\n  <code-pane title=\"in-memory-data.service.ts\" path=\"toh-pt6/src/app/in-memory-data.service.ts\">\nimport { InMemoryDbService } from 'angular-in-memory-web-api';\nexport class InMemoryDataService implements InMemoryDbService {\n  createDb() {\n    const heroes = [\n      { id: 0,  name: 'Zero' },\n      { id: 11, name: 'Mr. Nice' },\n      { id: 12, name: 'Narco' },\n      { id: 13, name: 'Bombasto' },\n      { id: 14, name: 'Celeritas' },\n      { id: 15, name: 'Magneta' },\n      { id: 16, name: 'RubberMan' },\n      { id: 17, name: 'Dynama' },\n      { id: 18, name: 'Dr IQ' },\n      { id: 19, name: 'Magma' },\n      { id: 20, name: 'Tornado' }\n    ];\n    return {heroes};\n  }\n}\n\n\n</code-pane>\n</code-tabs>\n<code-tabs>\n  <code-pane title=\"hero-search.service.ts\" path=\"toh-pt6/src/app/hero-search.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/http/Http\" class=\"code-anchor\">Http</a> }       from '@angular/http';\n\nimport { Observable }     from 'rxjs/Observable';\nimport 'rxjs/add/operator/map';\n\nimport { Hero }           from './hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class HeroSearchService {\n\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) {}\n\n  search(term: string): Observable&#x3C;Hero[]> {\n    return this.http\n               .get(`api/heroes/?name=${term}`)\n               .map(response => response.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>().data as Hero[]);\n  }\n}\n\n\n</code-pane>\n  <code-pane title=\"hero-search.component.ts\" path=\"toh-pt6/src/app/hero-search.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> } from '@angular/core';\nimport { <a href=\"api/router/Router\" class=\"code-anchor\">Router</a> }            from '@angular/router';\n\nimport { Observable }        from 'rxjs/Observable';\nimport { Subject }           from 'rxjs/Subject';\n\n// Observable class extensions\nimport 'rxjs/add/observable/of';\n\n// Observable operators\nimport 'rxjs/add/operator/catch';\nimport 'rxjs/add/operator/debounceTime';\nimport 'rxjs/add/operator/distinctUntilChanged';\n\nimport { HeroSearchService } from './hero-search.service';\nimport { Hero } from './hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-search',\n  templateUrl: './hero-search.component.html',\n  styleUrls: [ './hero-search.component.css' ],\n  providers: [HeroSearchService]\n})\nexport class HeroSearchComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  heroes: Observable&#x3C;Hero[]>;\n  private searchTerms = new Subject&#x3C;string>();\n\n  constructor(\n    private heroSearchService: HeroSearchService,\n    private router: <a href=\"api/router/Router\" class=\"code-anchor\">Router</a>) {}\n\n  // Push a search term into the observable stream.\n  search(term: string): void {\n    this.searchTerms.next(term);\n  }\n\n  ngOnInit(): void {\n    this.heroes = this.searchTerms\n      .debounceTime(300)        // wait 300ms after each keystroke before considering the term\n      .distinctUntilChanged()   // ignore if next search term is same as previous\n      .switchMap(term => term   // switch to new observable each time the term changes\n        // return the http search observable\n        ? this.heroSearchService.search(term)\n        // or the observable of empty heroes if there was no search term\n        : Observable.of&#x3C;Hero[]>([]))\n      .catch(error => {\n        // TODO: add real error handling\n        console.log(error);\n        return Observable.of&#x3C;Hero[]>([]);\n      });\n  }\n\n  gotoDetail(hero: Hero): void {\n    let link = ['/detail', hero.id];\n    this.router.navigate(link);\n  }\n}\n\n\n</code-pane>\n  <code-pane title=\"hero-search.component.html\" path=\"toh-pt6/src/app/hero-search.component.html\">\n&#x3C;div id=\"search-component\">\n  &#x3C;h4>Hero Search&#x3C;/h4>\n  &#x3C;input #searchBox id=\"search-box\" (keyup)=\"search(searchBox.value)\" />\n  &#x3C;div>\n    &#x3C;div *ngFor=\"let hero of heroes | async\"\n         (click)=\"gotoDetail(hero)\" class=\"search-result\" >\n      {{hero.name}}\n    &#x3C;/div>\n  &#x3C;/div>\n&#x3C;/div>\n\n\n</code-pane>\n  <code-pane title=\"hero-search.component.css\" path=\"toh-pt6/src/app/hero-search.component.css\">\n.search-result{\n  border-bottom: 1px solid gray;\n  border-left: 1px solid gray;\n  border-right: 1px solid gray;\n  width:195px;\n  height: 16px;\n  padding: 5px;\n  background-color: white;\n  cursor: pointer;\n}\n\n.search-result:hover {\n  color: #eee;\n  background-color: #607D8B;\n}\n\n#search-box{\n  width: 200px;\n  height: 20px;\n}\n\n\n</code-pane>\n</code-tabs>\n<h2 translation-origin=\"off\" id=\"next-step\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#next-step\"><i class=\"material-icons\">link</i></a>Next step</h2>\n<h2 translation-result=\"\" id=\"下一步\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"tutorial/toh-pt6#下一步\"><i class=\"material-icons\">link</i></a>下一步</h2>\n<p translation-origin=\"off\">That concludes the \"Tour of Heroes\" tutorial.\nYou're ready to learn more about Angular development in the fundamentals section,\nstarting with the <a href=\"guide/architecture\" title=\"Architecture\">Architecture</a> guide.</p>\n<p translation-result=\"\">这就是《英雄指南》教程的全部内容。\n现在可以深入学习 Angular 的开发原理了，你可以从<a href=\"guide/architecture\" title=\"Architecture\">架构</a>开始学。</p>\n\n</div>"
}