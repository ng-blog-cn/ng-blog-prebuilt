{
  "id": "guide/ngmodule",
  "title": "Angular模块 (NgModule)",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"ngmodules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#ngmodules\"><i class=\"material-icons\">link</i></a>NgModules</h1>\n<h1 translation-result=\"\" id=\"angular模块-ngmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular模块-ngmodule\"><i class=\"material-icons\">link</i></a>Angular模块 (NgModule)</h1>\n<p translation-origin=\"off\"><strong>NgModules</strong> help organize an application into cohesive blocks of functionality.</p>\n<!-- CF: \"app\" and \"application\" are used interchangeably throughout this page.\nI'm not sure what's appropriate, so I left them as is for now.  -->\n<p translation-result=\"\"><strong>Angular 模块</strong>能帮你把应用组织成多个内聚的功能块。</p>\n<p translation-origin=\"off\">An NgModule is a class adorned with the <em>@NgModule</em> decorator function.\n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> takes a metadata object that tells Angular how to compile and run module code.\nIt identifies the module's own components, directives, and pipes,\nmaking some of them public so external components can use them.\n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> may add service providers to the application dependency injectors.\nAnd there are many more options covered here.</p>\n<p translation-result=\"\">Angular 模块是带有 <strong>@NgModule</strong> 装饰器函数的<em>类</em>。\n<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>接收一个元数据对象，该对象告诉 Angular 如何编译和运行模块代码。\n它标记出该模块<em>拥有</em>的组件、指令和管道，\n并把它们的一部分公开出去，以便外部组件使用它们。\n它可以向应用的依赖注入器中添加服务提供商。\n本章还会涉及到更多选项。</p>\n<p translation-origin=\"off\">Before reading this page, read the\n<a href=\"guide/bootstrapping\">The Root Module</a> page, which introduces NgModules and the essentials\nof creating and maintaining a single root <code>AppModule</code> for the entire application.</p>\n<p translation-result=\"\">请先阅读<a href=\"guide/bootstrapping\">根模块</a>一章，那里介绍过 Angular 模块，以及如何为整个应用创建和维护单一的<em>根</em><code>AppModule</code>类。</p>\n<p translation-origin=\"off\">This page covers NgModules in greater depth.</p>\n<p translation-result=\"\">本章的解释更加详尽，正如下面的目录所示。</p>\n<!-- CF: See my comment in the \"Resolve directive conflicts\" section below proposing renaming or reorganizing that section.\n\n* [Angular modularity](guide/ngmodule#angular-modularity \"Add structure to the app with NgModule\")\n\n  [Angular 模块化](guide/ngmodule#angular-modularity \"用 NgModule 把结构添加到应用中\")\n\n* [The application root module](guide/ngmodule#root-module \"The startup module that every app requires\")\n\n  [应用的根模块](guide/ngmodule#root-module \"任何应用都需要的启动模块\")\n\n* [Bootstrap the root module](guide/ngmodule#bootstrap \"Launch the app in a browser with the root module as the entry point\")\n\n  [引导根模块](guide/ngmodule#bootstrap \"在浏览器中把根模块作为入口点来启动应用\")\n\n* [Declarations](guide/ngmodule#declarations \"Declare the components, directives, and pipes that belong to a module\")\n\n  [声明](guide/ngmodule#declarations \"声明从属于模块的组件、指令和管道\")\n\n* [Providers](guide/ngmodule#providers \"Extend the app with additional services\")\n\n  [提供商](guide/ngmodule#providers \"使用更多服务来扩展该应用\")\n\n* [Imports](guide/ngmodule#imports \"Import components, directives, and pipes for use in component templates\")\n\n  [导入](guide/ngmodule#imports \"为组件模板导入组件、指令和管道\")\n  \n* [Resolve conflicts](guide/ngmodule#resolve-conflicts \"When two directives have the same selector\")\n\n  [解决冲突](guide/ngmodule#resolve-conflicts \"当两指令具有相同的选择器时……\")\n  \n* [Feature modules](guide/ngmodule#feature-modules \"Partition the app into feature modules\")\n\n  [特性模块](guide/ngmodule#feature-modules \"把应用分割成一些特性模块\")\n  \n* [Lazy loaded modules with the router](guide/ngmodule#lazy-load \"Load modules asynchronously\")\n\n  [用路由器惰性加载模块](guide/ngmodule#lazy-load \"惰性加载模块\")\n  \n* [Shared modules](guide/ngmodule#shared-module \"Create modules for commonly used components, directives, and pipes\")\n\n  [共享模块](guide/ngmodule#shared-module \"为公用的组件、指令和管道创建模块\")\n\n* [The Core module](guide/ngmodule#core-module \"Create a core module with app-wide singleton services and single-use components\")\n\n  [核心模块](guide/ngmodule#core-module \"用应用级单例服务和一次性组件创建核心模块\")\n\n* [Configure core services with _forRoot_](guide/ngmodule#core-for-root \"Configure providers during module import\")\n\n  [用 _forRoot_ 配置核心服务](guide/ngmodule#core-for-root \"在导入模块时配置提供商\")\n\n* [Prevent reimport of the _CoreModule_](guide/ngmodule#prevent-reimport \"because bad things happen if a lazy loaded module imports Core\")\n\n  [禁止重复导入 _CoreModule_](guide/ngmodule#prevent-reimport \"如果惰性加载模块导入了核心模块，就会出问题\")\n\n<!--\n* [NgModule metadata properties](guide/ngmodule#ngmodule-properties \"A technical summary of the @NgModule metadata properties\")\n CF: This link goes to the top of this page. I would expect it to go to an \"NgModule metadata properties\"\n section at the end of this page, but that section doesn't exist. -->\n<!--\n  [NgModule 元数据的属性](guide/ngmodule#ngmodule-properties \"对@NgModule元数据属性的技术性总结\")\n-->\n<h4 translation-origin=\"off\" id=\"live-examples\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#live-examples\"><i class=\"material-icons\">link</i></a>Live examples</h4>\n<h4 translation-result=\"\" id=\"在线例子\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#在线例子\"><i class=\"material-icons\">link</i></a>在线例子</h4>\n<p translation-origin=\"off\">This page explains NgModules through a progression of improvements to a sample with a \"Tour of Heroes\" theme. Here's an index to live examples at key moments in the evolution of the sample:</p>\n<p translation-result=\"\">本章通过一个基于《英雄指南》的渐进式例子解释了 Angular 的模块。这里是例子演化过程中一些关键节点的在线例子。</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><live-example plnkr=\"minimal.0\">A minimal NgModule app</live-example></p>\n<p translation-result=\"\"><live-example plnkr=\"minimal.0\">最小的 NgModule 应用</live-example></p>\n</li>\n<li>\n<p translation-origin=\"off\"><live-example plnkr=\"contact.1b\">The first contact module</live-example></p>\n<p translation-result=\"\"><live-example plnkr=\"contact.1b\">第一个联系人模块</live-example></p>\n</li>\n<li>\n<p translation-origin=\"off\"><live-example plnkr=\"contact.2\">The revised contact module</live-example></p>\n<p translation-result=\"\"><live-example plnkr=\"contact.2\">修改过的联系人模块</live-example></p>\n</li>\n<li>\n<p translation-origin=\"off\"><live-example plnkr=\"pre-shared.3\">Just before adding SharedModule</live-example></p>\n<p translation-result=\"\"><live-example plnkr=\"pre-shared.3\">添加 <em>SharedModule</em> 之前</live-example></p>\n</li>\n<li>\n<p translation-origin=\"off\"><live-example>The final version</live-example></p>\n<p translation-result=\"\"><live-example>最终版</live-example></p>\n</li>\n</ul>\n<h4 translation-origin=\"off\" id=\"frequently-asked-questions-faqs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#frequently-asked-questions-faqs\"><i class=\"material-icons\">link</i></a>Frequently asked questions (FAQs)</h4>\n<h3 translation-result=\"\" id=\"常见问题\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#常见问题\"><i class=\"material-icons\">link</i></a>常见问题</h3>\n<p translation-origin=\"off\">This page covers NgModule concepts in a tutorial fashion.</p>\n<p translation-result=\"\">本章涵盖了英雄指南下的 Angular 模块概念。</p>\n<p translation-origin=\"off\">The companion <a href=\"guide/ngmodule-faq\" title=\"NgModule FAQs\">NgModule FAQs</a> guide\noffers answers to specific design and implementation questions.\nRead this page before reading those FAQs.</p>\n<p translation-result=\"\">烹饪宝典中的 <a href=\"guide/ngmodule-faq\" title=\"Angular 模块常见问题\">Angular 模块常见问题</a>为一些与设计和实现有关的问题提供了答案。\n不过在阅读常见问题之前，要先阅读本章。</p>\n<hr>\n<a id=\"angular-modularity\"></a>\n<h2 translation-origin=\"off\" id=\"angular-modularity\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-modularity\"><i class=\"material-icons\">link</i></a>Angular modularity</h2>\n<h2 translation-result=\"\" id=\"angular-模块化\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-模块化\"><i class=\"material-icons\">link</i></a>Angular 模块化</h2>\n<p translation-origin=\"off\">Modules are a great way to organize an application and extend it with capabilities from external libraries.</p>\n<p translation-result=\"\">模块是组织应用和使用外部库扩展应用的最佳途径。</p>\n<p translation-origin=\"off\">Many Angular libraries are modules (such as <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>, <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>, and <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>).\nMany third-party libraries are available as NgModules (such as\n<a href=\"https://material.angular.io/\">Material Design</a>,\n<a href=\"http://ionicframework.com/\">Ionic</a>,\n<a href=\"https://github.com/angular/angularfire2\">AngularFire2</a>).</p>\n<p translation-result=\"\">很多 Angular 库都是模块，例如：<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>、<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>、<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>。\n很多第三方库也封装成了 Angular 模块，例如：<a href=\"https://material.angular.io/\" target=\"_blank\">Material Design</a>、\n<a href=\"http://ionicframework.com/\" target=\"_blank\">Ionic</a>、\n<a href=\"https://github.com/angular/angularfire2\" target=\"_blank\">AngularFire2</a>。</p>\n<p translation-origin=\"off\">NgModules consolidate components, directives, and pipes into\ncohesive blocks of functionality, each focused on a\nfeature area, application business domain, workflow, or common collection of utilities.</p>\n<p translation-result=\"\">Angular 模块把组件、指令和管道打包成内聚的功能块，每个模块聚焦于一个特性区域、业务领域、工作流或通用工具。</p>\n<p translation-origin=\"off\">Modules can also add services to the application.\nSuch services might be internally developed, such as the application logger.\nServices can come from outside sources, such as the Angular router and Http client.</p>\n<p translation-result=\"\">模块还能用来把服务加到应用程序中。这些服务可能是内部研发的，例如应用日志服务；\n也可能是外部资源，例如 Angular 路由和 Http 客户端。</p>\n<p translation-origin=\"off\">Modules can be loaded eagerly when the application starts.\nThey can also be <em>lazy loaded</em> asynchronously by the router.</p>\n<p translation-result=\"\">模块可能在应用启动时主动加载，也可能由路由器进行异步<em>惰性加载</em>。</p>\n<p translation-origin=\"off\">An NgModule is a class decorated with <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata. The metadata do the following:</p>\n<p translation-result=\"\">Angular 模块是一个由<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>装饰器提供元数据的类，元数据包括：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Declare which components, directives, and pipes belong to the module.</p>\n<p translation-result=\"\">声明哪些组件、指令、管道<em>属于</em>该模块。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Make some of those classes public so that other component templates can use them.</p>\n<p translation-result=\"\">公开某些类，以便其它的组件模板可以使用它们。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Import other modules with the components, directives, and pipes needed by the components in <em>this</em> module.</p>\n<p translation-result=\"\">导入其它模块，从其它模块中获得<em>本</em>模块所需的组件、指令和管道。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Provide services at the application level that any application component can use.</p>\n<p translation-result=\"\">在应用程序级提供服务，以便应用中的任何组件都能使用它。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Every Angular app has at least one module class, the <em>root module</em>.\nYou bootstrap that module to launch the application.</p>\n<p translation-result=\"\">每个 Angular 应用至少有一个模块类 —— <em>根模块</em>，我们将通过引导根模块来启动应用。</p>\n<p translation-origin=\"off\">The root module is all you need in a simple application with a few components.\nAs the app grows, you refactor the root module into <em>feature modules</em>\nthat represent collections of related functionality.\nYou then import these modules into the root module.</p>\n<p translation-result=\"\">对于组件很少的简单应用来说，只用一个<em>根模块</em>就足够了。\n随着应用规模的增长，我们逐步从<em>根模块</em>中重构出一些<strong>特性模块</strong>，来代表一组相关功能的集合。\n然后，我们在<em>根模块</em>中导入它们。</p>\n<p translation-origin=\"off\">Later in this page, you'll read about this process. For now, you'll start with the root module.</p>\n<p translation-result=\"\">稍后我们就会看到怎么做。不过还是先从<em>根模块</em>开始吧！</p>\n<a id=\"root-module\"></a>\n<h2 translation-origin=\"off\" id=\"the-root-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#the-root-appmodule\"><i class=\"material-icons\">link</i></a>The root <em>AppModule</em></h2>\n<h2 translation-result=\"\" id=\"appmodule---应用的根模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#appmodule---应用的根模块\"><i class=\"material-icons\">link</i></a><em>AppModule</em> - 应用的根模块</h2>\n<p translation-origin=\"off\">Every Angular app has a <em>root module</em> class.\nBy convention, the <em>root module</em> class is called <code>AppModule</code> and it exists in a file named <code>app.module.ts</code>.</p>\n<p translation-result=\"\">每个 Angular 应用都有一个<strong>根模块</strong>类。\n按照约定，它的类名叫做<code>AppModule</code>，被放在<code>app.module.ts</code>文件中。</p>\n<p translation-origin=\"off\">The <code>AppModule</code> from the QuickStart seed on the <a href=\"guide/setup\">Setup</a> page is as minimal as possible:</p>\n<p translation-result=\"\"><a href=\"guide/setup\">快速起步种子库</a>中的<code>AppModule</code>是能找到的最小版本：</p>\n<code-example path=\"setup/src/app/app.module.ts\" title=\"src/app/app.module.ts (minimal)\" linenums=\"false\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }      from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { AppComponent }  from './app.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<p translation-origin=\"off\">The <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator defines the metadata for the module.\nThis page takes an intuitive approach to understanding the metadata and fills in details as it progresses.</p>\n<p translation-result=\"\"><code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>装饰器用来为模块定义元数据。\n我们先凭直觉来理解一下元数据，接下来再逐步深入细节。</p>\n<p translation-origin=\"off\">The metadata imports a single helper module, <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, which every browser app must import.</p>\n<p translation-result=\"\">这个元数据只导入了一个辅助模块，<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，每个运行在浏览器中的应用都必须导入它。</p>\n<p translation-origin=\"off\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> registers critical application service providers.\nIt also includes common directives like <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code>NgFor</code>, which become immediately visible and usable\nin any of this module's component templates.</p>\n<p translation-result=\"\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>注册了一些关键的应用服务提供商。\n它还包括了一些通用的指令，例如<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>和<code>NgFor</code>，所以这些指令在该模块的任何组件模板中都是可用的。</p>\n<p translation-origin=\"off\">The <code>declarations</code> list identifies the application's only component,\nthe <em>root component</em>, the top of the app's rather bare component tree.</p>\n<p translation-result=\"\"><code>declarations</code>列出了该应用程序中唯一的组件（<em>根组件</em>），它是应用的光秃秃的组件树的根。</p>\n<p translation-origin=\"off\">The example <code>AppComponent</code> simply displays a data-bound title:</p>\n<p translation-result=\"\">下面范例<code>AppComponent</code>显示被绑定的标题：</p>\n<code-example path=\"ngmodule/src/app/app.component.0.ts\" title=\"src/app/app.component.ts (minimal)\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>',\n})\nexport class AppComponent {\n  title = 'Minimal <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>';\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Lastly, the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.bootstrap</code> property identifies this <code>AppComponent</code> as the <em>bootstrap component</em>.\nWhen Angular launches the app, it places the HTML rendering of <code>AppComponent</code> in the DOM,\ninside the <code>&#x3C;my-app></code> element tags of the <code>index.html</code>.</p>\n<p translation-result=\"\">最后，<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.bootstrap</code>属性把这个<code>AppComponent</code>标记为<em>引导 (bootstrap) 组件</em>。\n当 Angular 引导应用时，它会在 DOM 中渲染<code>AppComponent</code>，并把结果放进<code>index.html</code>的<code>&#x3C;my-app></code>元素标记内部。</p>\n<a id=\"bootstrap\"></a>\n<h2 translation-origin=\"off\" id=\"bootstrapping-in-maints\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#bootstrapping-in-maints\"><i class=\"material-icons\">link</i></a>Bootstrapping in <em>main.ts</em></h2>\n<h2 translation-result=\"\" id=\"在-maints-中引导\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#在-maints-中引导\"><i class=\"material-icons\">link</i></a>在 <em>main.ts</em> 中引导</h2>\n<p translation-origin=\"off\">You launch the application by bootstrapping the <code>AppModule</code> in the <code>main.ts</code> file.</p>\n<p translation-result=\"\">在<code>main.ts</code>文件中，我们通过引导<code>AppModule</code>来启动应用。</p>\n<p translation-origin=\"off\">Angular offers a variety of bootstrapping options targeting multiple platforms.\nThis page describes two options, both targeting the browser.</p>\n<p translation-result=\"\">针对不同的平台，Angular 提供了很多引导选项。\n本章我们只讲两个选项，都是针对浏览器平台的。</p>\n<h3 translation-origin=\"off\" id=\"compile-just-in-time-jit\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#compile-just-in-time-jit\"><i class=\"material-icons\">link</i></a>Compile just-in-time (JIT)</h3>\n<h3 translation-result=\"\" id=\"即时-jit-编译\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#即时-jit-编译\"><i class=\"material-icons\">link</i></a>即时 (JiT) 编译</h3>\n<p translation-origin=\"off\">In the first, <em>dynamic</em> option, the <a href=\"guide/ngmodule-faq#q-angular-compiler\" title=\"About the Angular Compiler\">Angular compiler</a>\ncompiles the application in the browser and then launches the app.</p>\n<p translation-result=\"\">先看看<em>动态</em>选项，<a href=\"guide/ngmodule-faq#q-angular-compiler\" title=\"关于 Angular 编译器\">Angular 编译器</a>在浏览器中编译并引导该应用。</p>\n<code-example path=\"ngmodule/src/main.ts\" title=\"src/main.ts (dynamic)\" linenums=\"false\">\nimport { <a href=\"api/core/enableProdMode\" class=\"code-anchor\">enableProdMode</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic';\n\nimport { AppModule } from './app/app.module';\nimport { environment } from './environments/environment';\n\nif (environment.production) {\n  <a href=\"api/core/enableProdMode\" class=\"code-anchor\">enableProdMode</a>();\n}\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p translation-origin=\"off\">The samples in this page demonstrate the dynamic bootstrapping approach.</p>\n<p translation-result=\"\">这里的例子演示进行动态引导的方法。</p>\n<p translation-origin=\"off\"><live-example embedded=\"\" plnkr=\"minimal.0\" img=\"guide/ngmodule/minimal-plunker.png\">Try the live example.</live-example></p>\n<p translation-result=\"\"><live-example embedded=\"\" plnkr=\"minimal.0\" img=\"devguide/ngmodule/minimal-plunker.png\">试试在线例子。</live-example></p>\n<h3 translation-origin=\"off\" id=\"compile-ahead-of-time-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#compile-ahead-of-time-aot\"><i class=\"material-icons\">link</i></a>Compile ahead-of-time (AOT)</h3>\n<h3 translation-result=\"\" id=\"使用预编译器-aot---ahead-of-time-进行静态引导\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#使用预编译器-aot---ahead-of-time-进行静态引导\"><i class=\"material-icons\">link</i></a>使用预编译器 (AoT - Ahead-Of-Time) 进行静态引导</h3>\n<p translation-origin=\"off\">Consider the static alternative which can produce a much smaller application that\nlaunches faster, especially on mobile devices and high latency networks.</p>\n<p translation-result=\"\">静态方案可以生成更小、启动更快的应用，建议优先使用它，特别是在移动设备或高延迟网络下。</p>\n<p translation-origin=\"off\">In the <em>static</em> option, the Angular compiler runs ahead of time as part of the build process,\nproducing a collection of class factories in their own files.\nAmong them is the <code>AppModuleNgFactory</code>.</p>\n<p translation-result=\"\">使用<em>静态</em>选项，Angular 编译器作为构建流程的一部分提前运行，生成一组类工厂。它们的核心就是<code>AppModuleNgFactory</code>。</p>\n<p translation-origin=\"off\">The syntax for bootstrapping the pre-compiled <code>AppModuleNgFactory</code> is similar to\nthe dynamic version that bootstraps the <code>AppModule</code> class.</p>\n<p translation-result=\"\">引导预编译的<code>AppModuleNgFactory</code>的语法和动态引导<code>AppModule</code>类的方式很相似。</p>\n<code-example path=\"ngmodule/src/main-static.ts\" title=\"src/main.ts (static)\" linenums=\"false\">\n// The <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a> platform without a compiler\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n// The app module factory produced by the <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> offline compiler\nimport { AppModuleNgFactory } from './app/app.module.ngfactory';\n\n// Launch with the app module factory.\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModuleFactory(AppModuleNgFactory);\n\n</code-example>\n<p translation-origin=\"off\">Because the entire application was pre-compiled,\nAngular doesn't ship the Angular compiler to the browser and doesn't compile in the browser.</p>\n<p translation-result=\"\">由于整个应用都是预编译的，所以我们不用把 <em>Angular 编译器</em>一起发到浏览器中，也不用在浏览器中进行编译。</p>\n<p translation-origin=\"off\">The application code downloaded to the browser is much smaller than the dynamic equivalent\nand it's ready to execute immediately. The performance boost can be significant.</p>\n<p translation-result=\"\">下载到浏览器中的应用代码比动态版本要小得多，并且能立即执行。引导的性能可以得到显著提升。</p>\n<p translation-origin=\"off\">Both the JIT and AOT compilers generate an <code>AppModuleNgFactory</code> class from the same <code>AppModule</code>\nsource code.\nThe JIT compiler creates that factory class on the fly, in memory, in the browser.\nThe AOT compiler outputs the factory to a physical file\nthat is imported here in the static version of <code>main.ts</code>.</p>\n<p translation-result=\"\">无论是 JiT 还是 AoT 编译器都会从同一份<code>AppModule</code>源码中生成一个<code>AppModuleNgFactory</code>类。\nJiT 编译器动态地在浏览器的内存中创建这个工厂类。\nAoT 编译器把工厂输出成一个物理文件，也就是我们在静态版本<code>main.ts</code>中导入的那个。</p>\n<p translation-origin=\"off\">In general, the <code>AppModule</code> should neither know nor care how it is bootstrapped.</p>\n<p translation-result=\"\">通常，<code>AppModule</code>不必关心它是如何被引导的。</p>\n<p translation-origin=\"off\">Although the <code>AppModule</code> evolves as the app grows, the bootstrap code in <code>main.ts</code> doesn't change.\nThis is the last time you'll look at <code>main.ts</code>.</p>\n<p translation-result=\"\">虽然<code>AppModule</code>会随着应用而演化，但是<code>main.ts</code>中的引导代码不会变。\n这将是我们最后一次关注<code>main.ts</code>了。</p>\n<hr>\n<a id=\"declarations\"></a>\n<h2 translation-origin=\"off\" id=\"declare-directives-and-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#declare-directives-and-components\"><i class=\"material-icons\">link</i></a>Declare directives and components</h2>\n<h2 translation-result=\"\" id=\"声明指令和组件\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#声明指令和组件\"><i class=\"material-icons\">link</i></a>声明指令和组件</h2>\n<p translation-origin=\"off\">As the app evolves,\nthe first addition is a <code>HighlightDirective</code>, an <a href=\"guide/attribute-directives\">attribute directive</a>\nthat sets the background color of the attached element.</p>\n<p translation-result=\"\">应用继续演进。\n首先加入的是<code>HighlightDirective</code>，一个<a href=\"guide/attribute-directives\">属性型指令</a>，它会设置所在元素的背景色。</p>\n<code-example path=\"ngmodule/src/app/highlight.directive.ts\" title=\"src/app/highlight.directive.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight]' })\n/** Highlight the attached element in gold */\nexport class HighlightDirective {\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.backgroundColor = 'gold';\n    console.log(\n      `* AppRoot highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Update the <code>AppComponent</code> template to attach the directive to the title:</p>\n<p translation-result=\"\">我们更新<code>AppComponent</code>的模板，来把该指令附加到标题上：</p>\n<code-example path=\"ngmodule/src/app/app.component.1.ts\" region=\"template\" title=\"src/app/app.component.ts\" linenums=\"false\">\ntemplate: '&#x3C;h1 highlight>{{title}}&#x3C;/h1>'\n\n</code-example>\n<p translation-origin=\"off\">If you ran the app now, Angular wouldn't recognize the <code>highlight</code> attribute and would ignore it.\nYou must declare the directive in <code>AppModule</code>.</p>\n<p translation-result=\"\">如果我们现在就运行该应用，Angular 将无法识别<code>highlight</code>属性，并且忽略它。\n我们必须在<code>AppModule</code>中声明该指令。</p>\n<p translation-origin=\"off\">Import the <code>HighlightDirective</code> class and add it to the module's <code>declarations</code> like this:</p>\n<p translation-result=\"\">导入<code>HighlightDirective</code>类，并把它加入该模块的<code>declarations</code>数组中，就像这样：</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"directive\" title=\"src/app/app.module.ts\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n],\n\n</code-example>\n<p translation-origin=\"off\">Refactor the title into its own <code>TitleComponent</code>.\nThe component's template binds to the component's <code>title</code> and <code>subtitle</code> properties like this:</p>\n<p translation-result=\"\">接着把标题重构到独立的<code>TitleComponent</code>中。\n该组件的模板绑定到了组件的<code>title</code>和<code>subtitle</code>属性中，就像这样：</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" region=\"v1\" title=\"src/app/title.component.html\" linenums=\"false\">\n&#x3C;h1 highlight>{{title}} {{subtitle}}&#x3C;/h1>\n\n</code-example>\n<code-example path=\"ngmodule/src/app/title.component.ts\" region=\"v1\" title=\"src/app/title.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-title',\n  templateUrl: './title.component.html',\n})\nexport class TitleComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() subtitle = '';\n  title = 'NgModules';\n}\n\n</code-example>\n<p translation-origin=\"off\">Rewrite the <code>AppComponent</code> to display the new <code>TitleComponent</code> in the <code>&#x3C;app-title></code> element,\nusing an input binding to set the <code>subtitle</code>.</p>\n<p translation-result=\"\">我们重写了<code>AppComponent</code>来把这个新的<code>TitleComponent</code>显示到<code>&#x3C;app-title></code>元素中，并使用一个输入型绑定来设置<code>subtitle</code>。</p>\n<code-example path=\"ngmodule/src/app/app.component.1.ts\" title=\"src/app/app.component.ts (v1)\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>'\n})\nexport class AppComponent {\n  subtitle = '(v1)';\n}\n\n</code-example>\n<p translation-origin=\"off\">Angular won't recognize the <code>&#x3C;app-title></code> tag until you declare it in <code>AppModule</code>.\nImport the <code>TitleComponent</code> class and add it to the module's <code>declarations</code>:</p>\n<p translation-result=\"\">除非我们在<code>AppModule</code>中声明过，否则 Angular 无法识别<code>&#x3C;app-title></code>标签。\n导入<code>TitleComponent</code>类，并把它加到模块的<code>declarations</code>中：</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"component\" title=\"src/app/app.module.ts\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n  TitleComponent,\n],\n\n</code-example>\n<a id=\"providers\"></a>\n<h2 translation-origin=\"off\" id=\"service-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#service-providers\"><i class=\"material-icons\">link</i></a>Service providers</h2>\n<h2 translation-result=\"\" id=\"服务提供商\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#服务提供商\"><i class=\"material-icons\">link</i></a>服务提供商</h2>\n<p translation-origin=\"off\">Modules are a great way to provide services for all of the module's components.</p>\n<p translation-result=\"\">模块是为模块中的所有组件提供服务的最佳途径。</p>\n<p translation-origin=\"off\">The <a href=\"guide/dependency-injection\">Dependency Injection</a> page describes\nthe Angular hierarchical dependency-injection system and how to configure that system\nwith <a href=\"guide/dependency-injection#providers\">providers</a> at different levels of the\napplication's component tree.</p>\n<p translation-result=\"\"><a href=\"guide/dependency-injection\">依赖注入</a>一章中讲过 Angular 的层次化依赖注入系统，\n以及如何在组件树的不同层次上通过<a href=\"guide/dependency-injection#providers\">提供商</a>配置该系统。</p>\n<p translation-origin=\"off\">A module can add providers to the application's root dependency injector, making those services\navailable everywhere in the application.</p>\n<p translation-result=\"\">模块可以往应用的“根依赖注入器”中添加提供商，让那些服务在应用中到处可用。</p>\n<p translation-origin=\"off\">Many applications capture information about the currently logged-in user and make that information\naccessible through a user service.\nThis sample application has a dummy implementation of such a <code>UserService</code>.</p>\n<p translation-result=\"\">很多应用都需要获取当前登录的用户的信息，并且通过一个用户服务来访问它们。\n该范例中有一个<code>UserService</code>的伪实现。</p>\n<code-example path=\"ngmodule/src/app/user.service.ts\" title=\"src/app/user.service.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\n/** Dummy version of an authenticated user service */\nexport class UserService {\n  userName = 'Sherlock Holmes';\n}\n\n\n</code-example>\n<p translation-origin=\"off\">The sample application should display a welcome message to the logged-in user just below the application title.\nUpdate the <code>TitleComponent</code> template to show the welcome message below the application title.</p>\n<p translation-result=\"\">该范例应用会在标题下方为已登录用户显示一条欢迎信息。\n更新<code>TitleComponent</code>的模板来显示它。</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" title=\"src/app/title.component.html\" linenums=\"false\">\n&#x3C;h1 highlight>{{title}} {{subtitle}}&#x3C;/h1>\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"user\">\n  &#x3C;i>Welcome, {{user}}&#x3C;/i>\n&#x3C;p>\n\n\n\n</code-example>\n<p translation-origin=\"off\">Update the <code>TitleComponent</code> class with a constructor that injects the <code>UserService</code>\nand sets the component's <code>user</code> property from the service.</p>\n<p translation-result=\"\">更新<code>TitleComponent</code>，为它加入一个构造函数，注入<code>UserService</code>类，并把组件的<code>user</code>属性设置为它的实例。</p>\n<code-example path=\"ngmodule/src/app/title.component.ts\" title=\"src/app/title.component.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { UserService } from './user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-title',\n  templateUrl: './title.component.html',\n})\nexport class TitleComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() subtitle = '';\n  title = 'NgModules';\n  user = '';\n\n  constructor(userService: UserService) {\n    this.user = userService.userName;\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">You've defined and used the service. Now to <em>provide</em> it for all components to use,\nadd it to a <code>providers</code> property in the <code>AppModule</code> metadata:</p>\n<p translation-result=\"\">我们已经<em>定义</em>并<em>使用了</em>该服务。现在，我们通过把它加入<code>AppModule</code>元数据的<code>providers</code>属性中，来把它<em>提供</em>给所有组件使用。</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [ UserService ],\n\n</code-example>\n<a id=\"imports\"></a>\n<h2 translation-origin=\"off\" id=\"import-supporting-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#import-supporting-modules\"><i class=\"material-icons\">link</i></a>Import supporting modules</h2>\n<h2 translation-result=\"\" id=\"导入支持性模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#导入支持性模块\"><i class=\"material-icons\">link</i></a>导入支持性模块</h2>\n<p translation-origin=\"off\">In the revised <code>TitleComponent</code>, an <code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> directive guards the message.\nThere is no message if there is no user.</p>\n<p translation-result=\"\">注意，在修改过的<code>TitleComponent</code>中，有一个<code>*<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>指令在“守卫着”该消息。如果没有当前用户，就没有任何消息。</p>\n<code-example path=\"ngmodule/src/app/title.component.html\" region=\"ngIf\" title=\"src/app/title.component.html (ngIf)\" linenums=\"false\">\n&#x3C;p *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"user\">\n  &#x3C;i>Welcome, {{user}}&#x3C;/i>\n&#x3C;p>\n\n</code-example>\n<p translation-origin=\"off\">Although <code>AppModule</code> doesn't declare <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>, the application still compiles and runs.\nHow can that be? The Angular compiler should either ignore or complain about unrecognized HTML.</p>\n<p translation-result=\"\">虽然<code>AppModule</code>没有声明过<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>指令，但该应用仍然能正常编译和运行。为什么这样没问题呢？Angular 的编译器遇到不认识的 HTML 时应该不是忽略就是报错才对。</p>\n<p translation-origin=\"off\">Angular does recognize <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> because you imported it earlier.\nThe initial version of <code>AppModule</code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>.</p>\n<p translation-result=\"\">Angular 能识别<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>指令，是因为我们以前导入过它。最初版本的<code>AppModule</code>就导入了<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>。</p>\n<code-example path=\"ngmodule/src/app/app.module.0.ts\" region=\"imports\" title=\"src/app/app.module.ts (imports)\" linenums=\"false\">\nimports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> ],\n\n</code-example>\n<p translation-origin=\"off\">Importing <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> made all of its public components, directives, and pipes visible\nto the component templates in <code>AppModule</code>.</p>\n<p translation-result=\"\">导入<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>会让该模块公开的所有组件、指令和管道在<code>AppModule</code>下的任何组件模板中可用。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">More accurately, <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> is declared in <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> from <code>@angular/common</code>.</p>\n<p translation-result=\"\">更准确的说，<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>是在来自<code>@angular/common</code>的<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>中声明的。</p>\n<p translation-origin=\"off\"><code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> contributes many of the common directives that applications need, including <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> and <code>ngFor</code>.</p>\n<p translation-result=\"\"><code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>提供了很多应用程序中常用的指令，包括<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>和<code>NgFor</code>等。</p>\n<p translation-origin=\"off\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> imports <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> and <a href=\"guide/ngmodule-faq#q-re-export\">re-exports</a> it.\nThe net effect is that an importer of <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> gets <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> directives automatically.</p>\n<p translation-result=\"\"><code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>导入了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>并且<a href=\"guide/ngmodule-faq#q-re-export\"><em>重新导出</em></a>了它。\n最终的效果是：只要导入<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>就自动获得了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>中的指令。</p>\n</div>\n<p translation-origin=\"off\">Many familiar Angular directives don't belong to <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>.\nFor example,  <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> and <code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code> belong to Angular's <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> and <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> respectively.\nYou must import those modules before you can use their directives.</p>\n<p translation-result=\"\">很多熟悉的 Angular 指令并不属于<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。\n例如，<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>和<code><a href=\"api/router/RouterLink\" class=\"code-anchor\">RouterLink</a></code>分别属于 Angular 的<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>模块和<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>模块。\n在使用那些指令之前，我们也必须<em>导入</em>那些模块。</p>\n<p translation-origin=\"off\">To illustrate this point, you'll extend the sample app with <code>ContactComponent</code>,\na form component that imports form support from the Angular <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.</p>\n<p translation-result=\"\">要解释这一点，我们可以再加入<code>ContactComponent</code>组件，它是一个表单组件，从 Angular 的<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>中导入了表单支持。</p>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"add-the-_contactcomponent_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#add-the-_contactcomponent_\"><i class=\"material-icons\">link</i></a>Add the _ContactComponent_</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"添加-_contactcomponent_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#添加-_contactcomponent_\"><i class=\"material-icons\">link</i></a>添加 _ContactComponent_</h3>\n<p translation-origin=\"off\"><a href=\"guide/forms\">Angular forms</a> are a great way to manage user data entry.</p>\n<p translation-result=\"\"><a href=\"guide/forms\">Angular 表单</a>是用来管理用户数据输入的最佳方式之一。</p>\n<p translation-origin=\"off\">The <code>ContactComponent</code> presents a \"contact editor,\"\nimplemented with Angular forms in the <a href=\"guide/forms#template-driven\">template-driven form</a> style.</p>\n<p translation-result=\"\"><code>ContactComponnet</code>组件展现“联系人编辑器”，它是用<a href=\"guide/forms\"><em>模板驱动式表单</em></a>实现的。</p>\n<div class=\"l-sub-section\">\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"angular-form-styles\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-form-styles\"><i class=\"material-icons\">link</i></a>Angular form styles</h3>\n<h3 translation-result=\"\" id=\"angular-表单的风格\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#angular-表单的风格\"><i class=\"material-icons\">link</i></a>Angular 表单的风格</h3>\n<p translation-origin=\"off\">You can write Angular form components in\ntemplate-driven or\n<a href=\"guide/dynamic-form\">reactive</a> style.</p>\n<!-- CF: this link goes to a page titled \"Dynamic Forms\". Should the link text be \"dynamic\" instead of \"reactive\"? -->\n<p translation-result=\"\">我们写 Angular 表单组件时，可以使用<a href=\"guide/forms\"><em>模板驱动式表单</em></a>，\n也可以使用<a href=\"guide/dynamic-form\"><em>响应式表单</em></a>。</p>\n<p translation-origin=\"off\">The following sample imports the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> from <code>@angular/forms</code> because\nthe <code>ContactComponent</code> is written in <em>template-driven</em> style.\nModules with components written in the <em>reactive</em> style\nimport the <code><a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a></code>.</p>\n<p translation-result=\"\">该例子中从<code>@angular/forms</code>中导入了<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，这是因为<code>ContactComponent</code>组件用的是<em>模板驱动式表单</em>。\n那些带有<em>响应式表单</em>组件的模块，应该转而导入<code><a href=\"api/forms/ReactiveFormsModule\" class=\"code-anchor\">ReactiveFormsModule</a></code>。</p>\n</div>\n<p translation-origin=\"off\">The <code>ContactComponent</code> selector matches an element named <code>&#x3C;app-contact></code>.\nAdd an element with that name to the <code>AppComponent</code> template, just below the <code>&#x3C;app-title></code>:</p>\n<p translation-result=\"\"><code>ContactComponent</code>的选择器会去匹配名叫<code>&#x3C;app-contact></code>的元素。\n在<code>AppComponent</code>模板中<code>&#x3C;app-title></code>的下方添加一个具有此名字的元素：</p>\n<code-example path=\"ngmodule/src/app/app.component.1b.ts\" region=\"template\" title=\"src/app/app.component.ts (template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>\n  &#x3C;app-contact>&#x3C;/app-contact>\n`\n\n</code-example>\n<p translation-origin=\"off\">Form components are often complex. The <code>ContactComponent</code> has its own <code>ContactService</code>\nand <a href=\"guide/pipes#custom-pipes\">custom pipe</a> (called <code>Awesome</code>),\nand an alternative version of the <code>HighlightDirective</code>.</p>\n<p translation-result=\"\"><code>ContactComponent</code>还有很多事要做。\n表单组件通常都是很复杂的。本组件具有它自己的<code>ContactService</code>和<a href=\"guide/pipes#custom-pipes\">自定义管道</a> <code>Awesome</code>，\n以及<code>HighlightDirective</code>的另一个版本。</p>\n<p translation-origin=\"off\">To make it manageable, place all contact-related material in an <code>src/app/contact</code> folder\nand break the component into three constituent HTML, TypeScript, and css files:</p>\n<p translation-result=\"\">为了方便管理，我们把所有与联系人相关的编程元素都放进<code>src/app/contact</code>目录，\n并把该组件分解成三个基本成分：HTML、TypeScript 和 CSS 文件：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.component.html\" path=\"ngmodule/src/app/contact/contact.component.html\">\n&#x3C;h2>Contact of {{userName}}&#x3C;/h2>\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"msg\" class=\"msg\">{{msg}}&#x3C;/div>\n\n&#x3C;form *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"contacts\" (ngSubmit)=\"onSubmit()\" #contactForm=\"ngForm\">\n  &#x3C;h3 highlight>{{ contact.name | awesome }}&#x3C;/h3>\n  &#x3C;div class=\"form-group\">\n    &#x3C;label for=\"name\">Name&#x3C;/label>\n    &#x3C;input type=\"text\" class=\"form-control\" required\n      [(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]=\"contact.name\"\n        name=\"name\"  #name=\"<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>\" >\n    &#x3C;div [hidden]=\"name.valid\" class=\"alert alert-danger\">\n      Name is required\n    &#x3C;/div>\n  &#x3C;/div>\n  &#x3C;br>\n  &#x3C;button type=\"submit\" class=\"btn btn-default\" [disabled]=\"!contactForm.form.valid\">Save&#x3C;/button>\n  &#x3C;button type=\"button\" class=\"btn\" (click)=\"next()\" [disabled]=\"!contactForm.form.valid\">Next Contact&#x3C;/button>\n  &#x3C;button type=\"button\" class=\"btn\" (click)=\"newContact()\">New Contact&#x3C;/button>\n&#x3C;/form>\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.component.ts\" path=\"ngmodule/src/app/contact/contact.component.3.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> }      from '@angular/core';\n\nimport { Contact, ContactService } from './contact.service';\nimport { UserService }    from '../user.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-contact',\n  templateUrl: './contact.component.html',\n  styleUrls: [ './contact.component.css' ]\n})\nexport class ContactComponent implements <a href=\"api/core/OnInit\" class=\"code-anchor\">OnInit</a> {\n  contact:  Contact;\n  contacts: Contact[];\n\n  msg = 'Loading contacts ...';\n  userName = '';\n\n  constructor(private contactService: ContactService, userService: UserService) {\n    this.userName = userService.userName;\n  }\n\n  ngOnInit() {\n    this.contactService.getContacts().then(contacts => {\n      this.msg = '';\n      this.contacts = contacts;\n      this.contact = contacts[0];\n    });\n  }\n\n  next() {\n    let ix = 1 + this.contacts.indexOf(this.contact);\n    if (ix >= this.contacts.length) { ix = 0; }\n    this.contact = this.contacts[ix];\n  }\n\n  onSubmit() {\n    // POST-DEMO TODO: do something like save it\n    this.displayMessage('Saved ' + this.contact.name);\n  }\n\n  newContact() {\n    this.displayMessage('New contact');\n    this.contact = {id: 42, name: ''};\n    this.contacts.push(this.contact);\n  }\n\n  /** Display a message briefly, then remove it. */\n  displayMessage(msg: string) {\n    this.msg = msg;\n    setTimeout(() => this.msg = '', 1500);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.component.css\" path=\"ngmodule/src/app/contact/contact.component.css\">\n.ng-valid[required] {\n  border-left: 5px solid #42A948; /* green */\n}\n\n.ng-invalid {\n  border-left: 5px solid #a94442; /* red */\n}\n\n.alert {\n  padding: 15px;\n  margin: 8px 0;\n  border: 1px solid transparent;\n  border-radius: 4px;\n}\n.alert-danger {\n  color: #a94442;\n  background-color: #f2dede;\n  border-color: #ebccd1;\n}\n\n.msg {\n  color: blue;\n  background-color: whitesmoke;\n  border: 1px solid transparent;\n  border-radius: 4px;\n  margin-bottom: 20px;\n}\n\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.service.ts\" path=\"ngmodule/src/app/contact/contact.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\n\nexport class Contact {\n  constructor(public id: number, public name: string) { }\n}\n\nconst CONTACTS: Contact[] = [\n  new Contact(21, 'Sam Spade'),\n  new Contact(22, 'Nick Danger'),\n  new Contact(23, 'Nancy Drew')\n];\n\nconst FETCH_LATENCY = 500;\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class ContactService {\n\n  getContacts() {\n    return new Promise&#x3C;Contact[]>(resolve => {\n      setTimeout(() => { resolve(CONTACTS); }, FETCH_LATENCY);\n    });\n  }\n\n  getContact(id: number | string) {\n    return this.getContacts()\n      .then(heroes => heroes.find(hero => hero.id === +id));\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/awesome.pipe.ts\" path=\"ngmodule/src/app/contact/awesome.pipe.ts\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({ name: 'awesome' })\n/** Precede the input string with the word \"Awesome \" */\nexport class AwesomePipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(phrase: string) {\n    return phrase ? 'Awesome ' + phrase : '';\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/highlight.directive.ts\" path=\"ngmodule/src/app/contact/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight], input' })\n/** Highlight the attached element or an InputElement in blue */\nexport class HighlightDirective {\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.backgroundColor = 'powderblue';\n    console.log(\n      `* Contact highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">In the middle of the component template,\nnotice the two-way data binding <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>.\n<code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code> is the selector for the <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> directive.</p>\n<p translation-result=\"\">先来看组件模板。\n注意模板中部的双向数据绑定<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>。\n<code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code>是<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>指令的选择器。</p>\n<p translation-origin=\"off\">Although <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> is an Angular directive, the <em>Angular compiler</em> won't recognize it for the following reasons:</p>\n<p translation-result=\"\">虽然<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>是 Angular 指令，但 <em>Angular 编译器</em>并不会识别它，因为：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>AppModule</code> doesn't declare <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>.</p>\n<p translation-result=\"\"><code>AppModule</code>没有声明过这个<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code> wasn't imported via <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>.</p>\n<p translation-result=\"\"><code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>也没有通过<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>被导入过。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Even if Angular somehow recognized <code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code>,\n<code>ContactComponent</code> wouldn't behave like an Angular form because\nform features such as validation aren't yet available.</p>\n<p translation-result=\"\">退一步说，即使 Angular 有办法识别<code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code>，<code>ContactComponent</code>也不会表现的像 Angular 表单，\n因为本组件表单的表单相关的特性（例如有效性验证）还不可用。</p>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"import-the-formsmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#import-the-formsmodule\"><i class=\"material-icons\">link</i></a>Import the FormsModule</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"导入-formsmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#导入-formsmodule\"><i class=\"material-icons\">link</i></a>导入 FormsModule</h3>\n<h3 translation-result=\"\" id=\"导入formsmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#导入formsmodule\"><i class=\"material-icons\">link</i></a>导入<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code></h3>\n<p translation-origin=\"off\">Add the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to the <code>AppModule</code> metadata's <code>imports</code> list.</p>\n<p translation-result=\"\">把<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>加到<code>AppModule</code>元数据中的<code>imports</code>列表中：</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"imports\" title=\"src/app/app.module.ts\" linenums=\"false\">\nimports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n\n</code-example>\n<p translation-origin=\"off\">Now <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code> binding will work and the user input will be validated by Angular forms,\nonce you declare the new component, pipe, and directive.</p>\n<p translation-result=\"\">一旦我们声明了这些新组件、管道和指令，<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>绑定就会正常工作，用户的输入也能被 Angular 表单验证了。</p>\n<div class=\"alert is-critical\">\n<p translation-origin=\"off\"><em>Do not</em> add <code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>—or the <code>FORMS_DIRECTIVES</code>—to\nthe <code>AppModule</code> metadata's declarations.\nThese directives belong to the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.</p>\n<p translation-result=\"\"><strong>不要</strong>把<code><a href=\"api/forms/NgModel\" class=\"code-anchor\">NgModel</a></code>（或<code>FORMS_DIRECTIVES）加到</code>AppModule<code>元数据的</code>declarations<code>数据中！这些指令属于</code>FormsModule`。</p>\n<p translation-origin=\"off\">Components, directives, and pipes belong to <em>one module only</em>.</p>\n<p translation-result=\"\">组件、指令和管道<em>只能</em>属于一个模块。</p>\n<p translation-origin=\"off\"><em>Never re-declare classes that belong to another module.</em></p>\n<p translation-result=\"\"><strong>永远不要再次声明属于其它模块的类。</strong></p>\n</div>\n<a id=\"declare-pipe\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"declare-the-contact-component-directive-and-pipe\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#declare-the-contact-component-directive-and-pipe\"><i class=\"material-icons\">link</i></a>Declare the contact component, directive, and pipe</h3>\n<h3 translation-result=\"\" id=\"声明联系人的组件、指令和管道\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#声明联系人的组件、指令和管道\"><i class=\"material-icons\">link</i></a>声明联系人的组件、指令和管道</h3>\n<p translation-origin=\"off\">The application won't compile until you declare the contact component, directive, and pipe.\nUpdate the <code>declarations</code> in the  <code>AppModule</code> accordingly:</p>\n<p translation-result=\"\">如果我们没有声明该联系人模块的组件、指令和管道，该应用就会失败。\n更新<code>AppModule</code>中的<code>declarations</code>元数据，就像这样：</p>\n<code-example path=\"ngmodule/src/app/app.module.1.ts\" region=\"declarations\" title=\"src/app/app.module.ts (declarations)\" linenums=\"false\">\ndeclarations: [\n  AppComponent,\n  HighlightDirective,\n  TitleComponent,\n\n  AwesomePipe,\n  ContactComponent,\n  ContactHighlightDirective\n],\n\n</code-example>\n<a id=\"import-name-conflict\"></a>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">There are two directives with the same name, both called <code>HighlightDirective</code>.</p>\n<p translation-result=\"\">如果有两个同名指令，都叫做<code>HighlightDirective</code>，该怎么办呢？</p>\n<p translation-origin=\"off\">To work around this, create an alias for the contact version using the <code>as</code> JavaScript import keyword.</p>\n<p translation-result=\"\">我们只要在 import 时使用<code>as</code>关键字来为第二个指令创建个别名就可以了。</p>\n<code-example path=\"ngmodule/src/app/app.module.1b.ts\" region=\"import-alias\" title=\"src/app/app.module.1b.ts\" linenums=\"false\">\nimport {\n  HighlightDirective as ContactHighlightDirective\n} from './contact/highlight.directive';\n\n</code-example>\n<p translation-origin=\"off\">This solves the immediate issue of referencing both directive <em>types</em> in the same file but\nleaves another issue unresolved.\nYou'll learn more about that issue later in this page, in <a href=\"guide/ngmodule#resolve-conflicts\">Resolve directive conflicts</a>.</p>\n<p translation-result=\"\">这解决了在文件中使用指令<em>类型</em>时的冲突问题，但是还有另一个问题没有解决，我们将在<a href=\"guide/ngmodule#resolve-conflicts\">后面</a>讨论它。</p>\n</div>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"provide-the-_contactservice_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#provide-the-_contactservice_\"><i class=\"material-icons\">link</i></a>Provide the _ContactService_</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"提供-_contactservice_\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#提供-_contactservice_\"><i class=\"material-icons\">link</i></a>提供 _ContactService_</h3>\n<p translation-origin=\"off\">The <code>ContactComponent</code> displays contacts retrieved by the <code>ContactService</code>,\nwhich Angular injects into its constructor.</p>\n<p translation-result=\"\"><code>ContactComponent</code>显示从<code>ContactService</code>服务中获取的联系人信息，该服务是被 Angular 注入到组件的构造函数中的。</p>\n<p translation-origin=\"off\">You have to provide that service somewhere.\nThe <code>ContactComponent</code> could provide it,\nbut then the service would be scoped to this component only.\nYou want to share this service with other contact-related components that you'll surely add later.</p>\n<p translation-result=\"\">我们必须在某个地方提供该服务。\n在<code>ContactComponent</code>中<em>可以</em>提供它。\n但是那样一来，它的作用范围就会<em>仅</em>局限于该组件及其子组件。\n而我们希望让该服务与其它和联系人有关的组件中共享，稍后我们就会添加那些组件。</p>\n<p translation-origin=\"off\">In this app, add <code>ContactService</code> to the <code>AppModule</code> metadata's <code>providers</code> list:</p>\n<p translation-result=\"\">在此应用中，我们选择把<code>ContactSerivce</code>添加到<code>AppModule</code>元数据的<code>providers</code>列表中：</p>\n<code-example path=\"ngmodule/src/app/app.module.1b.ts\" region=\"providers\" title=\"src/app/app.module.ts (providers)\" linenums=\"false\">\nproviders: [ ContactService, UserService ],\n\n</code-example>\n<p translation-origin=\"off\">Now you can inject <code>ContactService</code> (like <code>UserService</code>) into any component in the application.</p>\n<p translation-result=\"\">现在，<code>ContactService</code>服务就能被注入进该应用中的任何组件了，就像<code>UserService</code>一样。</p>\n<a id=\"application-scoped-providers\"></a>\n<div class=\"l-sub-section\">\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"application-scoped-providers\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#application-scoped-providers\"><i class=\"material-icons\">link</i></a>Application-scoped providers</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"全应用范围的提供商\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#全应用范围的提供商\"><i class=\"material-icons\">link</i></a>全应用范围的提供商</h3>\n<p translation-origin=\"off\">  The <code>ContactService</code> provider is <em>application</em>-scoped because Angular\nregisters a module's <code>providers</code> with the application's <em>root injector</em>.</p>\n<p translation-result=\"\"><code>ContactService</code>的提供商是<em>全应用</em>范围的，这是因为 Angular 使用该应用的<strong>根注入器</strong>注册模块的<code>providers</code>。</p>\n<p translation-origin=\"off\">Architecturally, the <code>ContactService</code> belongs to the Contact business domain.\nClasses in other domains don't need the <code>ContactService</code> and shouldn't inject it.</p>\n<p translation-result=\"\">从架构上看，<code>ContactService</code>属于“联系人”这个业务领域。\n<em>其它</em>领域中的类并不需要知道<code>ContactService</code>，也不会要求注入它。</p>\n<p translation-origin=\"off\">You might expect Angular to offer a <em>module</em>-scoping mechanism to enforce this design.\nIt doesn't. NgModule instances, unlike components, don't have their own injectors\nso they can't have their own provider scopes.</p>\n<p translation-result=\"\">我们可能会期待 Angular 提供一种<em>模块</em>范围内的机制来保障此设计。\n但它没有。与组件不同，Angular的 模块实例并没有它们自己的注入器，所以它们也没有自己的供应商范围。  </p>\n<p translation-origin=\"off\">This omission is intentional.\nNgModules are designed primarily to extend an application,\nto enrich the entire app with the module's capabilities.</p>\n<p translation-result=\"\">Angular是故意这么设计的。\nAngular的模块设计，主要目的是扩展应用程序，丰富其模块化能力。</p>\n<p translation-origin=\"off\">In practice, service scoping is rarely an issue.\nNon-contact components can't accidentally inject the <code>ContactService</code>.\nTo inject <code>ContactService</code>, you must first import its <em>type</em>.\nOnly Contact components should import the <code>ContactService</code> type.</p>\n<p translation-result=\"\">在实践中，服务的范围很少会成为问题。\n联系人之外的组件不会意外注入<code>ContactService</code>服务。\n要想注入<code>ContactService</code>，你得先导入它的<em>类型</em>。\n而只有联系人组件才会导入<code>ContactService</code><em>类型</em>。</p>\n<p translation-origin=\"off\">Read more in the <a href=\"guide/ngmodule-faq#q-component-scoped-providers\">How do I restrict service scope to a module?</a> section\nof the <a href=\"guide/ngmodule-faq\">NgModule FAQs</a> page.</p>\n<p translation-result=\"\">在<a href=\"guide/ngmodule-faq\">NgModule常见问题</a>页的<a href=\"guide/ngmodule-faq#q-component-scoped-providers\">如何把服务的范围限制在一个模块中</a>一节中可以了解更多。</p>\n</div>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"run-the-app\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#run-the-app\"><i class=\"material-icons\">link</i></a>Run the app</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"运行该应用\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#运行该应用\"><i class=\"material-icons\">link</i></a>运行该应用</h3>\n<p translation-origin=\"off\">Everything is in place to run the application with its contact editor.</p>\n<p translation-result=\"\">一切就绪，可以运行该应用及其联系人编辑器了。</p>\n<p translation-origin=\"off\">The app file structure looks like this:</p>\n<p translation-result=\"\">应用的文件结构是这样的：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    app\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      app.component.ts\n    </div>\n    <div class=\"file\">\n      app.module.ts\n    </div>\n    <div class=\"file\">\n      highlight.directive.ts\n    </div>\n    <div class=\"file\">\n      title.component.(html|ts)\n    </div>\n    <div class=\"file\">\n      user.service.ts\n    </div>\n    <div class=\"file\">\n      contact\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        awesome.pipe.ts\n      </div>\n      <div class=\"file\">\n        contact.component.(css|html|ts)\n      </div>\n      <div class=\"file\">\n        contact.service.ts\n      </div>\n      <div class=\"file\">\n        highlight.directive.ts\n      </div>\n    </div>\n  </div>\n</div>\n<p translation-result=\"\">Try the example:\n试试这个例子：<live-example embedded=\"\" plnkr=\"contact.1b\" img=\"guide/ngmodule/contact-1b-plunker.png\"></live-example></p>\n<a id=\"resolve-conflicts\"></a>\n<h2 translation-origin=\"off\" id=\"resolve-directive-conflicts\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#resolve-directive-conflicts\"><i class=\"material-icons\">link</i></a>Resolve directive conflicts</h2>\n<h2 translation-result=\"\" id=\"解决指令冲突\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#解决指令冲突\"><i class=\"material-icons\">link</i></a>解决指令冲突</h2>\n<!-- CF: This section describes directive conflicts in detail, but doesn't describe how to resolve them.\n This section seems like more of an introduction to the next section, \"Feature modules\".\n Consider moving this section to be a child section of \"Feature modules\", or striking \"Resolve\" from this title. -->\n<p translation-origin=\"off\">An issue arose <a href=\"guide/ngmodule#import-name-conflict\">earlier</a> when you declared the contact's <code>HighlightDirective</code> because\nyou already had a <code>HighlightDirective</code> class at the application level.</p>\n<p translation-result=\"\"><a href=\"guide/ngmodule#import-name-conflict\">以前</a>我们在声明联系人的<code>HighlightDirective</code>指令时遇到了问题，因为在应用程序一级已经有了一个<code>HighlightDirective</code>类。</p>\n<p translation-origin=\"off\">The selectors of the two directives both highlight the attached element with a different color.</p>\n<p translation-result=\"\">在查找它们的选择器时，它们都试图用不同的颜色来高亮所依附的元素。</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/highlight.directive.ts\" path=\"ngmodule/src/app/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight]' })\n/** Highlight the attached element in gold */\nexport class HighlightDirective {\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.backgroundColor = 'gold';\n    console.log(\n      `* AppRoot highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/highlight.directive.ts\" path=\"ngmodule/src/app/contact/highlight.directive.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a> } from '@angular/core';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({ selector: '[highlight], input' })\n/** Highlight the attached element or an InputElement in blue */\nexport class HighlightDirective {\n  constructor(el: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>) {\n    el.nativeElement.style.backgroundColor = 'powderblue';\n    console.log(\n      `* Contact highlight called for ${el.nativeElement.tagName}`);\n  }\n}\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">Both directives are declared in this module so both directives are active.</p>\n<p translation-result=\"\">Angular 会只用它们中的一个吗？不会。\n所有指令都声明在该模块中，所以<em>这两个指令都会被激活</em>。</p>\n<p translation-origin=\"off\">When the two directives compete to color the same element,\nthe directive that's declared later wins because its DOM changes overwrite the first.\nIn this case, the contact's <code>HighlightDirective</code> makes the application title text blue\nwhen it should stay gold.</p>\n<p translation-result=\"\">当两个指令在同一个元素上争相设置颜色时，后声明的那个会胜出，因为它对 DOM 的修改覆盖了前一个。\n在该例子中，联系人的<code>HighlightDirective</code>把应用标题的文本染成了蓝色，而我们原本期望它保持金色。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The issue is that two different classes are trying to do the same thing.</p>\n<p translation-result=\"\">真正的问题在于，有<em>两个不同的类</em>试图做同一件事。</p>\n<p translation-origin=\"off\">It's OK to import the same directive class multiple times.\nAngular removes duplicate classes and only registers one of them.</p>\n<p translation-result=\"\">多次导入<em>同一个</em>指令是没问题的，Angular 会移除重复的类，而只注册一次。</p>\n<p translation-origin=\"off\">But from Angular's perspective, two different classes, defined in different files, that have the same name\nare not duplicates. Angular keeps both directives and\nthey take turns modifying the same HTML element.</p>\n<p translation-result=\"\">从 Angular 的角度看，两个类并没有重复。Angular 会同时保留这两个指令，并让它们依次修改同一个 HTML 元素。</p>\n</div>\n<p translation-origin=\"off\">At least the app still compiles.\nIf you define two different component classes with the same selector specifying the same element tag,\nthe compiler reports an error. It can't insert two components in the same DOM location.</p>\n<p translation-result=\"\">至少，应用仍然编译通过了。\n如果我们使用相同的选择器定义了两个不同的组件类，并指定了同一个元素标记，编译器就会报错说它无法在同一个 DOM 位置插入两个不同的组件。</p>\n<p translation-origin=\"off\">To eliminate component and directive conflicts, create feature modules\nthat insulate the declarations in one module from the declarations in another.</p>\n<p translation-result=\"\">我们可以通过创建特性模块来消除组件与指令的冲突。\n特性模块可以把来自一个模块中的声明和来自另一个的区隔开。</p>\n<a id=\"feature-modules\"></a>\n<h2 translation-origin=\"off\" id=\"feature-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#feature-modules\"><i class=\"material-icons\">link</i></a>Feature modules</h2>\n<h2 translation-result=\"\" id=\"特性模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#特性模块\"><i class=\"material-icons\">link</i></a>特性模块</h2>\n<p translation-origin=\"off\">This application isn't big yet, but it's already experiencing structural issues.</p>\n<p translation-result=\"\">该应用还不大，但是已经在受结构方面的问题困扰了。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">The root <code>AppModule</code> grows larger with each new application class.</p>\n<p translation-result=\"\">随着一个个类被加入应用中，根模块<code>AppModule</code>变大了。</p>\n</li>\n<li>\n<p translation-origin=\"off\">There are conflicting directives.\nThe <code>HighlightDirective</code> in the contact re-colors the work done by the <code>HighlightDirective</code> declared in <code>AppModule</code>.\nAlso, it colors the application title text when it should color only the <code>ContactComponent</code>.</p>\n<p translation-result=\"\">  我们遇到了指令冲突。\n联系人模块的<code>HighlightDirective</code>在<code>AppModule</code>中声明的<code>HighlightDirective</code>的基础上进行了二次上色。\n并且，它染了应用标题文字的颜色，而不仅仅是<code>ContactComponent</code>中的。\n</p>\n</li>\n<li>\n<p translation-origin=\"off\">The app lacks clear boundaries between contact functionality and other application features.\nThat lack of clarity makes it harder to assign development responsibilities to different teams.</p>\n<p translation-result=\"\">  该应用在联系人和其它特性区之间缺乏清晰的边界。\n这种缺失，导致难以在不同的开发组之间分配职责。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">You can resolve these issues with <em>feature modules</em>.</p>\n<p translation-result=\"\">我们用<em>特性模块</em>技术来缓解此问题。</p>\n<p translation-origin=\"off\">A feature module is a class adorned by the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator and its metadata,\njust like a root module.\nFeature module metadata have the same properties as the metadata for a root module.</p>\n<p translation-result=\"\"><em>特性模块</em>是带有<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>装饰器及其元数据的类，就像根模块一样。\n特性模块的元数据和根模块的元数据的属性是一样的。</p>\n<p translation-origin=\"off\">The root module and the feature module share the same execution context.\nThey share the same dependency injector, which means the services in one module\nare available to all.</p>\n<p translation-result=\"\">根模块和特性模块还共享着相同的执行环境。\n它们共享着同一个依赖注入器，这意味着某个模块中定义的服务在所有模块中也都能用。</p>\n<p translation-origin=\"off\">The modules have the following significant technical differences:</p>\n<p translation-result=\"\">它们在技术上有两个显著的不同点：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">You <em>boot</em> the root module to <em>launch</em> the app;\nyou <em>import</em> a feature module to <em>extend</em> the app.</p>\n<p translation-result=\"\">  我们<em>引导</em>根模块来<em>启动</em>应用，但<em>导入</em>特性模块来<em>扩展</em>应用。\n</p>\n</li>\n<li>\n<p translation-origin=\"off\">A feature module can expose or hide its implementation from other modules.</p>\n<p translation-result=\"\">特性模块可以对其它模块暴露或隐藏自己的实现。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Otherwise, a feature module is distinguished primarily by its intent.</p>\n<p translation-result=\"\">此外，特性模块主要还是从它的设计意图上来区分。</p>\n<p translation-origin=\"off\">A feature module delivers a cohesive set of functionality\nfocused on an application business domain, user workflow, facility (forms, http, routing),\nor collection of related utilities.</p>\n<p translation-result=\"\">特性模块用来提供了内聚的功能集合。\n聚焦于应用的某个业务领域、用户工作流、某个基础设施（表单、HTTP、路由），或一组相关的工具集合。</p>\n<p translation-origin=\"off\">While you can do everything within the root module,\nfeature modules help you partition the app into areas of specific interest and purpose.</p>\n<!-- CF: Is this paragraph just restating the previous paragraph?\nIf so, I recommend removing it or merging the two -->\n<p translation-result=\"\">虽然这些都能在根模块中做，但特性模块可以帮助我们把应用切分成具有特定关注点和目标的不同区域。</p>\n<p translation-origin=\"off\">A feature module collaborates with the root module and with other modules\nthrough the services it provides and\nthe components, directives, and pipes that it shares.</p>\n<p translation-result=\"\">特性模块通过自己提供的服务和它决定对外共享的那些组件、指令、管道来与根模块等其它模块协同工作。</p>\n<p translation-origin=\"off\">In the next section, you'll carve the contact functionality out of the root module\nand into a dedicated feature module.</p>\n<p translation-result=\"\">下一节，我们从根模块中把与联系人有关的功能切分到专门的特性模块中。</p>\n<a id=\"contact-module-v1\"></a>\n<h3 translation-origin=\"off\" id=\"make-contact-a-feature-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#make-contact-a-feature-module\"><i class=\"material-icons\">link</i></a>Make <em>Contact</em> a feature module</h3>\n<!-- CF: Is \"Contact\" a proper noun in this context? -->\n<h3 translation-result=\"\" id=\"把联系人做成特性模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#把联系人做成特性模块\"><i class=\"material-icons\">link</i></a>把<em>联系人</em>做成特性模块</h3>\n<p translation-origin=\"off\">It's easy to refactor the contact material into a contact feature module.</p>\n<p translation-result=\"\">把与联系人有关的这些元素重构到“联系人”特性模块中很简单。</p>\n<ol>\n<li>\n<p translation-origin=\"off\">Create the <code>ContactModule</code> in the <code>src/app/contact</code> folder.</p>\n<p translation-result=\"\">在<code>src/app/contact</code>目录下创建<code>ContactModule</code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Move the contact material from <code>AppModule</code> to <code>ContactModule</code>.</p>\n<p translation-result=\"\">把联系人相关的元素从<code>AppModule</code>移到<code>ContactModule</code>中。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Replace the imported  <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> with <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>.</p>\n<p translation-result=\"\">把导入<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>改为导入<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Import the <code>ContactModule</code> into the <code>AppModule</code>.</p>\n<p translation-result=\"\">在<code>AppModule</code>中导入<code>ContactModule</code>。</p>\n</li>\n</ol>\n<p translation-origin=\"off\"><code>AppModule</code> is the only existing class that changes. But you do add one new file.</p>\n<p translation-result=\"\"><code>AppModule</code>是唯一有改变的<em>已经存在</em>的类，不过我们还会添加一个新文件。</p>\n<h3 translation-origin=\"off\" id=\"add-the-contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#add-the-contactmodule\"><i class=\"material-icons\">link</i></a>Add the <em>ContactModule</em></h3>\n<h3 translation-result=\"\" id=\"添加-contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#添加-contactmodule\"><i class=\"material-icons\">link</i></a>添加 <em>ContactModule</em></h3>\n<p translation-origin=\"off\">Here's the new <code>ContactModule</code>:</p>\n<p translation-result=\"\">下面是新的<code>ContactModule</code>：</p>\n<code-example path=\"ngmodule/src/app/contact/contact.module.2.ts\" title=\"src/app/contact/contact.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }       from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }        from '@angular/forms';\n\nimport { AwesomePipe }        from './awesome.pipe';\n\nimport\n       { ContactComponent }   from './contact.component';\nimport { ContactService }     from './contact.service';\nimport { HighlightDirective } from './highlight.directive';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-example>\n<p translation-origin=\"off\">You copy from <code>AppModule</code> the contact-related import statements and <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> properties\nthat concern the contact, and paste them into <code>ContactModule</code>.</p>\n<p translation-result=\"\">把<code>AppModule</code>中的相关联系人的 import 语句和<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的相关属性复制到<code>ContactModule</code>。</p>\n<p translation-origin=\"off\">You <em>import</em> the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> because the contact component needs it.</p>\n<p translation-result=\"\"><em>导入</em><code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，因为联系人组件需要它。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">Modules don't inherit access to the components, directives, or pipes that are declared in other modules.\nWhat <code>AppModule</code> imports is irrelevant to <code>ContactModule</code> and vice versa.\nBefore <code>ContactComponent</code> can bind with <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>, its <code>ContactModule</code> must import <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.</p>\n<p translation-result=\"\">当前模块不会继承其它模块中对组件、指令或管道的访问权。\n<code>AppModule</code>中的 imports 与<code>ContatModule</code>的 imports 互不相干。\n如果<code>ContactComponent</code>要绑定到<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>，它所在的<code>ContactModule</code>必需导入<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n</div>\n<p translation-origin=\"off\">You also replaced <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code> by <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>, for reasons explained in the\n<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">Should I import BrowserModule or CommonModule?</a>\nsection of the <a href=\"guide/ngmodule-faq\">NgModule FAQs</a> page.</p>\n<p translation-result=\"\">我们还用<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>替换了<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，其中缘由参见<a href=\"guide/ngmodule-faq#q-browser-vs-common-module\">这条常见问题</a>。</p>\n<p translation-origin=\"off\">You <em>declare</em> the contact component, directive, and pipe in the module <code>declarations</code>.</p>\n<p translation-result=\"\">我们在该模块的<code>declarations</code>中<em>声明</em>了联系人组件、指令和管道。</p>\n<p translation-origin=\"off\">You <em>export</em> the <code>ContactComponent</code> so\nother modules that import the <code>ContactModule</code> can include it in their component templates.</p>\n<p translation-result=\"\">我们<em>导出</em>了<code>ContactComponent</code>，这样其它模块只要导入了<code>ContactModule</code>，就可以在它们的组件模板中使用<code>ContactComponent</code>了。</p>\n<p translation-origin=\"off\">All other declared contact classes are private by default.\nThe <code>AwesomePipe</code> and <code>HighlightDirective</code> are hidden from the rest of the application.\nThe <code>HighlightDirective</code> can no longer color the <code>AppComponent</code> title text.</p>\n<p translation-result=\"\">声明的所有其它联系人类默认都是私有的。\n<code>AwesomePipe</code>和<code>HighlightDirective</code>对应用的其它部分是不可见的。\n所以<code>HighlightDirective</code>不能把<code>AppComponent</code>的标题文字染色。</p>\n<h3 translation-origin=\"off\" id=\"refactor-the-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#refactor-the-appmodule\"><i class=\"material-icons\">link</i></a>Refactor the <em>AppModule</em></h3>\n<h3 translation-result=\"\" id=\"重构-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#重构-appmodule\"><i class=\"material-icons\">link</i></a>重构 <em>AppModule</em></h3>\n<p translation-origin=\"off\">Return to the <code>AppModule</code> and remove everything specific to the contact feature set.</p>\n<p translation-result=\"\">返回<code>AppModule</code>并移除专属于联系人特性下的任何东西。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Delete the contact import statements.</p>\n<p translation-result=\"\">删除属于联系人的<code>import</code>语句。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Delete the contact declarations and contact providers.</p>\n<p translation-result=\"\">删除联系人的<code>declarations</code>和<code>providers</code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Delete the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> from the <code>imports</code> list (<code>AppComponent</code> doesn't need it).</p>\n<p translation-result=\"\">从<code>imports</code>列表中移除<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>（<code>AppComponent</code>并不需要它）。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Leave only the classes required at the application root level.</p>\n<p translation-result=\"\">只保留本应用的根一级需要的那些类。</p>\n<p translation-origin=\"off\">Then import the <code>ContactModule</code> so the app can continue to display the exported <code>ContactComponent</code>.</p>\n<p translation-result=\"\">然后，导入<code>ContactModule</code>，以便应用能够继续显示导出的<code>ContactComponent</code>。</p>\n<p translation-origin=\"off\">Here's the refactored version of the <code>AppModule</code> along with the previous version.</p>\n<p translation-result=\"\">下面是<code>AppModule</code>重构完的版本与之前版本的对比。</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/app.module.ts (v2)\" path=\"ngmodule/src/app/app.module.2.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }      from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n/* App Root */\nimport\n       { AppComponent }       from './app.component';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Contact Imports */\nimport\n       { ContactModule }      from './contact/contact.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>, ContactModule ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  providers:    [ UserService ],\n  bootstrap:    [ AppComponent ],\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/app.module.ts (v1)\" path=\"ngmodule/src/app/app.module.1b.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }      from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n/* App Root */\nimport\n       { AppComponent }       from './app.component';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Contact Imports */\nimport\n       { ContactComponent }   from './contact/contact.component';\nimport { ContactService }     from './contact/contact.service';\nimport { AwesomePipe }        from './contact/awesome.pipe';\n\nimport {\n  HighlightDirective as ContactHighlightDirective\n} from './contact/highlight.directive';\n\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }        from '@angular/forms';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,  <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [\n    AppComponent, HighlightDirective, TitleComponent,\n    AwesomePipe, ContactComponent, ContactHighlightDirective\n  ],\n  providers: [ ContactService, UserService ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n</code-tabs>\n<h3 translation-origin=\"off\" id=\"improvements\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#improvements\"><i class=\"material-icons\">link</i></a>Improvements</h3>\n<h3 translation-result=\"\" id=\"改进之处\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#改进之处\"><i class=\"material-icons\">link</i></a>改进之处</h3>\n<p translation-origin=\"off\">There's a lot to like in the revised <code>AppModule</code>.</p>\n<p translation-result=\"\">修改后的<code>AppModule</code>有一些很棒的特性。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">It does not change as the <em>Contact</em> domain grows.</p>\n<p translation-result=\"\">它不会再随着<em>联系人</em>的领域扩张而修改。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It only changes when you add new modules.</p>\n<p translation-result=\"\">只有当添加新模块时才需要修改它。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It's simpler:</p>\n<p translation-result=\"\">它也变得简单了：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Fewer import statements.</p>\n<p translation-result=\"\">更少的<code>import</code>语句</p>\n</li>\n<li>\n<p translation-origin=\"off\">No <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> import.</p>\n<p translation-result=\"\">不再导入<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code></p>\n</li>\n<li>\n<p translation-origin=\"off\">No contact-specific declarations.</p>\n<p translation-result=\"\">没有与联系人有关的声明</p>\n</li>\n<li>\n<p translation-origin=\"off\">No <code>ContactService</code> provider.</p>\n<p translation-result=\"\">没有<code>ContactService</code>提供商</p>\n</li>\n<li>\n<p translation-origin=\"off\">No <code>HighlightDirective</code> conflict.</p>\n<p translation-result=\"\">没有<code>HighlightDirective</code>冲突</p>\n</li>\n</ul>\n</li>\n</ul>\n<p translation-origin=\"off\">Try this <code>ContactModule</code> version of the sample.</p>\n<p translation-result=\"\">试试范例的<code>ContactModule</code>版。</p>\n<p translation-origin=\"off\"><live-example embedded=\"\" plnkr=\"contact.2\" img=\"guide/ngmodule/contact-2-plunker.png\">Try the live example.</live-example></p>\n<p translation-result=\"\"><live-example embedded=\"\" plnkr=\"contact.2\" img=\"devguide/ngmodule/contact-2-plunker.png\">试试在线例子</live-example></p>\n<a id=\"lazy-load\"></a>\n<h2 translation-origin=\"off\" id=\"lazy-loading-modules-with-the-router\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#lazy-loading-modules-with-the-router\"><i class=\"material-icons\">link</i></a>Lazy-loading modules with the router</h2>\n<h2 translation-result=\"\" id=\"用路由器实现惰性-lazy-加载\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#用路由器实现惰性-lazy-加载\"><i class=\"material-icons\">link</i></a>用路由器实现惰性 (lazy) 加载</h2>\n<p translation-origin=\"off\">The Heroic Staffing Agency sample app has evolved.\nIt has two more modules, one for managing the heroes on staff and another for matching crises to the heroes.\nBoth modules are in the early stages of development.\nTheir specifics aren't important to the story and this page doesn't discuss every line of code.</p>\n<p translation-result=\"\">英雄职介所这个例子应用继续成长。\n它又增加了两个模块，一个用来管理雇佣的英雄，另一个用来匹配英雄与危机。\n这两个模块都还处于前期开发阶段。\n它们对于整个故事来说无关紧要，这里我们就不逐行讨论了。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Examine and download the complete source for this version from the\n<live-example plnkr=\"pre-shared.3\" img=\"guide/ngmodule/v3-plunker.png\">live example.</live-example></p>\n<p translation-result=\"\">到<live-example plnkr=\"pre-shared.3\" img=\"devguide/ngmodule/v3-plunker.png\">在线例子</live-example>\n试用并下载当前版本的完整代码。</p>\n</div>\n<p translation-origin=\"off\">Some facets of the current application merit discussion are as follows:</p>\n<p translation-result=\"\">当前应用中还有一些方面值得深入探讨。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">The app has three feature modules: Contact, Hero, and Crisis.</p>\n<p translation-result=\"\">该应用有三个特性模块：联系人 (Contact) 、英雄 (Hero) 和危机 (Crisis) 。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The Angular router helps users navigate among these modules.</p>\n<p translation-result=\"\">Angular 路由器帮助用户在这些模块之间导航。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <code>ContactComponent</code> is the default destination when the app starts.</p>\n<p translation-result=\"\"><code>ContactComponent</code>组件是应用启动时的默认页。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <code>ContactModule</code> continues to be \"eagerly\" loaded when the application starts.</p>\n<p translation-result=\"\"><code>ContactModule</code>仍然会在应用启动时被主动加载。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>HeroModule</code> and the <code>CrisisModule</code> are lazy loaded.</p>\n<p translation-result=\"\"><code>HeroModule</code>和<code>CrisisModule</code>会被惰性加载。</p>\n</li>\n</ul>\n<a id=\"app-component-template\"></a>\n<p translation-origin=\"off\">The new <code>AppComponent</code> templatehas\na title, three links, and a <code>&#x3C;router-outlet></code>.</p>\n<p translation-result=\"\">我们从这个<code>AppComponent</code>新模板的顶部看起：标题、三个链接和<code>&#x3C;router-outlet></code>。</p>\n<code-example path=\"ngmodule/src/app/app.component.3.ts\" region=\"template\" title=\"src/app/app.component.ts (v3 - Template)\" linenums=\"false\">\ntemplate: `\n  &#x3C;app-title [subtitle]=\"subtitle\">&#x3C;/app-title>\n  &#x3C;nav>\n    &#x3C;a routerLink=\"contact\" <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Contact&#x3C;/a>\n    &#x3C;a routerLink=\"crisis\"  <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Crisis Center&#x3C;/a>\n    &#x3C;a routerLink=\"heroes\"  <a href=\"api/router/RouterLinkActive\" class=\"code-anchor\">routerLinkActive</a>=\"active\">Heroes&#x3C;/a>\n  &#x3C;/nav>\n  &#x3C;router-outlet>&#x3C;/router-outlet>\n`\n\n</code-example>\n<p translation-origin=\"off\">The <code>&#x3C;app-contact></code> element is gone; you're routing to the <em>Contact</em> page now.</p>\n<p translation-result=\"\"><code>&#x3C;app-contact></code>元素不见了，改成了路由到<em>联系人</em>页。</p>\n<p translation-origin=\"off\">The <code>AppModule</code> has changed modestly:</p>\n<p translation-result=\"\">对<code>AppModule</code>进行适度的修改：</p>\n<code-example path=\"ngmodule/src/app/app.module.3.ts\" title=\"src/app/app.module.ts (v3)\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }      from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n/* App Root */\nimport { AppComponent }       from './app.component.3';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Feature Modules */\nimport { ContactModule }      from './contact/contact.module.3';\n\n/* Routing Module */\nimport { AppRoutingModule }   from './app-routing.module.3';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    AppRoutingModule\n  ],\n  providers:    [ UserService ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Some file names bear a <code>.3</code> extension that indicates\na difference with prior or future versions.\nThe significant differences will be explained in due course.</p>\n<!-- CF: Can you be more specific here? Are the differences explained later in this page or in another page? -->\n<p translation-result=\"\">有些文件名带有<code>.3</code>扩展名，用来和以前/以后的版本区分开。\n我们会在适当的时机解释它们的差异。</p>\n</div>\n<p translation-origin=\"off\">The module still imports <code>ContactModule</code> so that its routes and components are mounted when the app starts.</p>\n<p translation-result=\"\">该模块仍然要导入<code>ContactModule</code>模块，以便在应用启动时加载它的路由和组件。</p>\n<p translation-origin=\"off\">The module does <em>not</em> import <code>HeroModule</code> or <code>CrisisModule</code>.\nThey'll be fetched and mounted asynchronously when the user navigates to one of their routes.</p>\n<p translation-result=\"\">该模块<em>不</em>导入<code>HeroModule</code>或<code>CrisisModule</code>。\n它们将在用户导航到其中的某个路由时，被异步获取并加载。</p>\n<p translation-origin=\"off\">The significant change from version 2 is the addition of the <em>AppRoutingModule</em> to the module <code>imports</code>.\nThe <code>AppRoutingModule</code> is a <a href=\"guide/router#routing-module\">routing module</a>\nthat handles the app's routing concerns.</p>\n<p translation-result=\"\">与第二版相比，最值得注意的修改是<code>imports</code>中那个额外的<strong><em>AppRoutingModule</em></strong>模块。\n<code>AppRoutingModule</code>是一个<a href=\"guide/router#routing-module\"><strong>路由模块</strong></a>\n用来处理应用的路由。</p>\n<h3 translation-origin=\"off\" id=\"app-routing\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#app-routing\"><i class=\"material-icons\">link</i></a>App routing</h3>\n<h3 translation-result=\"\" id=\"应用路由\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#应用路由\"><i class=\"material-icons\">link</i></a>应用路由</h3>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }             from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\n\nexport const routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'contact', pathMatch: 'full'},\n  { path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },\n  { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule {}\n\n\n</code-example>\n<p translation-origin=\"off\">The router is the subject of the <a href=\"guide/router\">Routing &#x26; Navigation</a> page, so this section skips many of the details and\nconcentrates on the intersection of NgModules and routing.</p>\n<p translation-result=\"\">路由器有<a href=\"guide/router\">专门的章节</a>做深入讲解，所以这里我们跳过细节，而是专注于它和 Angular 模块的协作。</p>\n<p translation-origin=\"off\">The <code>app-routing.module.ts</code> file defines three routes.</p>\n<p translation-result=\"\"><code>app-routing.module.ts</code>文件定义了三个路由。</p>\n<p translation-origin=\"off\">The first route redirects the empty URL (such as <code>http://host.com/</code>)\nto another route whose path is <code>contact</code> (such as <code>http://host.com/contact</code>).</p>\n<p translation-result=\"\">第一个路由把空白 URL（例如<code>http://host.com/</code>）重定向到了另一个路径为<code>contact</code>的路由（例如<code>http://host.com/contact</code>）。</p>\n<p translation-origin=\"off\">The <code>contact</code> route isn't defined here.\nIt's defined in the <em>Contact</em> feature's <em>own</em> routing module, <code>contact-routing.module.ts</code>.\nIt's standard practice for feature modules with routing components to define their own routes.\nYou'll get to that file in a moment.</p>\n<p translation-result=\"\"><code>contact</code>路由并不是在这里定义的，而是定义在<em>联系人</em>特性区自己的路由文件<code>contact.routing.ts</code>中。\n对于带有路由组件的特性模块，其标准做法就是让它们定义自己的路由。\n稍后我们就会看到这些。</p>\n<p translation-origin=\"off\">The remaining two routes use lazy loading syntax to tell the router where to find the modules:</p>\n<p translation-result=\"\">另外两个路由使用惰性加载语法来告诉路由器要到哪里去找这些模块。</p>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" region=\"lazy-routes\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\n{ path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },\n{ path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">A lazy-loaded module location is a <em>string</em>, not a <em>type</em>.\nIn this app, the string identifies both the module <em>file</em> and the module <em>class</em>,\nthe latter separated from the former by a <code>#</code>.</p>\n<p translation-result=\"\">惰性加载模块的位置是<em>字符串</em>而不是<em>类型</em>。\n在本应用中，该字符串同时标记出了模块<em>文件</em>和模块<em>类</em>，两者用<code>#</code>分隔开。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"routermoduleforroot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#routermoduleforroot\"><i class=\"material-icons\">link</i></a>RouterModule.forRoot</h3>\n<h3 translation-result=\"\" id=\"routermoduleforroot-方法\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#routermoduleforroot-方法\"><i class=\"material-icons\">link</i></a>RouterModule.forRoot 方法</h3>\n<p translation-origin=\"off\">The <code>forRoot</code> static class method of the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> with the provided configuration and\nadded to the <code>imports</code> array provides the routing concerns for the module.</p>\n<p translation-result=\"\"><code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>类的<code>forRoot</code>静态方法和提供的配置，被添加到<code>imports</code>数组中，提供该模块的路由信息。</p>\n<code-example path=\"ngmodule/src/app/app-routing.module.ts\" region=\"forRoot\" title=\"src/app/app-routing.module.ts\" linenums=\"false\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot(routes)],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class AppRoutingModule {}\n\n</code-example>\n<p translation-origin=\"off\">The returned <code>AppRoutingModule</code> class is a <code>Routing Module</code> containing both the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code> directives\nand the dependency-injection providers that produce a configured <code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>.</p>\n<p translation-result=\"\">该方法返回的<code>AppRoutingModule</code>类是一个<code>路由模块</code>，它同时包含了<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>指令和用来生成配置好的<code><a href=\"api/router/Router\" class=\"code-anchor\">Router</a></code>的依赖注入提供商。</p>\n<p translation-origin=\"off\">This <code>AppRoutingModule</code> is intended for the app <em>root</em> module only.</p>\n<p translation-result=\"\">这个<code>AppRoutingModule</code><em>仅</em>用于应用的<em>根</em>模块。</p>\n<div class=\"alert is-critical\">\n<p translation-origin=\"off\">Never call <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot</code> in a feature-routing module.</p>\n<p translation-result=\"\">永远不要在特性路由模块中调用<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot</code>！</p>\n</div>\n<p translation-origin=\"off\">Back in the root <code>AppModule</code>, add the <code>AppRoutingModule</code> to its <code>imports</code> list,\nand the app is ready to navigate.</p>\n<p translation-result=\"\">回到根模块<code>AppModule</code>，把这个<code>AppRoutingModule</code>添加到根模块的<code>imports</code>列表中，该应用就可以正常导航了。</p>\n<code-example path=\"ngmodule/src/app/app.module.3.ts\" region=\"imports\" title=\"src/app/app.module.ts (imports)\" linenums=\"false\">\nimports:      [\n  <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ContactModule,\n  AppRoutingModule\n],\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"routing-to-a-feature-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#routing-to-a-feature-module\"><i class=\"material-icons\">link</i></a>Routing to a feature module</h3>\n<h3 translation-result=\"\" id=\"路由到特性模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#路由到特性模块\"><i class=\"material-icons\">link</i></a>路由到特性模块</h3>\n<p translation-origin=\"off\">The <code>src/app/contact</code> folder holds a new file, <code>contact-routing.module.ts</code>.\nIt defines the <code>contact</code> route mentioned earlier and provides a <code>ContactRoutingModule</code> as follows:</p>\n<p translation-result=\"\"><code>src/app/contact</code>目录中也有一个新文件<code>contact-routing.module.ts</code>。\n它定义了我们前面提到过的<code>联系人</code>路由，并提供了<code>ContactRoutingModule</code>，就像这样：</p>\n<code-example path=\"ngmodule/src/app/contact/contact-routing.module.ts\" region=\"routing\" title=\"src/app/contact/contact-routing.module.ts (routing)\" linenums=\"false\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forChild([\n    { path: 'contact', component: ContactComponent }\n  ])],\n  exports: [<a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>]\n})\nexport class ContactRoutingModule {}\n\n</code-example>\n<p translation-origin=\"off\">This time you pass the route list to the <code>forChild</code> method of the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>.\nThe route list is only responsible for providing additional routes and is intended for feature modules.</p>\n<p translation-result=\"\">这次我们要把路由列表传给<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a></code>的<code>forChild</code>方法。\n该方法会为特性模块生成另一种对象。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">Always call <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forChild</code> in a feature-routing module.</p>\n<p translation-result=\"\">总是在特性路由模块中调用<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forChild</code>。</p>\n</div>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>forRoot</em> and <em>forChild</em> are conventional names for methods that\ndeliver different <code>import</code> values to root and feature modules.\nAngular doesn't recognize them but Angular developers do.</p>\n<p translation-result=\"\">当需要为根模块和特性模块分别提供不同的<code>导入</code>值时，<strong><em>forRoot</em></strong>和<strong><em>forChild</em></strong>是约定俗成的方法名。\n虽然 Angular 无法识别它们，但是 Angular 开发人员可以。</p>\n<p translation-origin=\"off\"><a href=\"guide/ngmodule-faq#q-for-root\">Follow this convention</a> if you write a similar module\nthat has both shared <a href=\"guide/ngmodule-faq#q-declarable\">declarables</a> and services.</p>\n<p translation-result=\"\">当你要写类似的模块，来为根模块和特性模块分别导出一些<a href=\"guide/ngmodule-faq#q-declarable\"><em>声明</em></a>和服务时，请<a href=\"guide/ngmodule-faq#q-for-root\">遵循这个约定</a>。</p>\n</div>\n<p translation-origin=\"off\"><code>ContactModule</code> has changed in two small but important ways.</p>\n<p translation-result=\"\"><code>ContactModule</code>已经做了两个微小但重要的细节改动：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.module.3.ts\" path=\"ngmodule/src/app/contact/contact.module.3.ts\" region=\"class\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, ContactRoutingModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.module.2.ts\" path=\"ngmodule/src/app/contact/contact.module.2.ts\" region=\"class\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  exports:      [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n</code-tabs>\n<ul>\n<li>\n<p translation-origin=\"off\">It imports the <code>ContactRoutingModule</code> object from <code>contact-routing.module.ts</code>.</p>\n<p translation-result=\"\">它从<code>contact-routing.module.ts</code>中导入了<code>ContactRoutingModule</code>对象</p>\n</li>\n<li>\n<p translation-origin=\"off\">It no longer exports <code>ContactComponent</code>.</p>\n<p translation-result=\"\"> 它不再导出<code>ContactComponent</code></p>\n</li>\n</ul>\n<p translation-origin=\"off\">Now that you navigate to <code>ContactComponent</code> with the router, there's no reason to make it public.\nAlso, <code>ContactComponent</code> doesn't need a selector.\nNo template will ever again reference this <code>ContactComponent</code>.\nIt's gone from the <a href=\"guide/ngmodule#app-component-template\">AppComponent template</a>.</p>\n<p translation-result=\"\">现在我们通过路由器导航到<code>ContactComponent</code>，所以也就没有理由公开它了。它也不再需要选择器 (selector)。\n也没有模板会再引用<code>ContactComponent</code>。它从 <a href=\"guide/ngmodule#app-component-template\"><em>AppComponent</em> 模板</a>中彻底消失了。</p>\n<a id=\"hero-module\"></a>\n<h3 translation-origin=\"off\" id=\"lazy-loaded-routing-to-a-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#lazy-loaded-routing-to-a-module\"><i class=\"material-icons\">link</i></a>Lazy-loaded routing to a module</h3>\n<h3 translation-result=\"\" id=\"路由到惰性加载的模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#路由到惰性加载的模块\"><i class=\"material-icons\">link</i></a>路由到惰性加载的模块</h3>\n<p translation-origin=\"off\">The lazy-loaded <code>HeroModule</code> and <code>CrisisModule</code> follow the same principles as any feature module.\nThey don't look different from the eagerly loaded <code>ContactModule</code>.</p>\n<p translation-result=\"\">惰性加载的<code>HeroModule</code>和<code>CrisisModule</code>与其它特性模块遵循同样的规则。它们和主动加载的<code>ContactModule</code>看上去没有任何区别。</p>\n<p translation-origin=\"off\">The <code>HeroModule</code> is a bit more complex than the <code>CrisisModule</code>, which makes it\na more interesting and useful example. Its file structure is as follows:</p>\n<p translation-result=\"\"><code>HeroModule</code>比<code>CrisisModule</code>略复杂一些，因此更适合用作范例。它的文件结构如下：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    hero\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      hero-detail.component.ts\n    </div>\n    <div class=\"file\">\n      hero-list.component.ts\n    </div>\n    <div class=\"file\">\n      hero.component.ts\n    </div>\n    <div class=\"file\">\n      hero.module.ts\n    </div>\n    <div class=\"file\">\n      hero-routing.module.ts\n    </div>\n    <div class=\"file\">\n      hero.service.ts\n    </div>\n    <div class=\"file\">\n      highlight.directive.ts\n    </div>\n  </div>\n</div>\n<p translation-origin=\"off\">This is the child routing scenario familiar to readers of the\n<a href=\"guide/router#child-routing-component\">Child routing component</a> section of the\n<a href=\"guide/router#child-routing-component\">Routing &#x26; Navigation</a> page.\nThe <code>HeroComponent</code> is the feature's top component and routing host.\nIts template has a <code>&#x3C;router-outlet></code> that displays either a list of heroes (<code>HeroList</code>)\nor an editor of a selected hero (<code>HeroDetail</code>).\nBoth components delegate to the <code>HeroService</code> to fetch and save data.</p>\n<p translation-result=\"\">如果你读过<a href=\"guide/router#child-routing-component\">路由</a>那章，那么对这个子路由的场景应该觉得很熟悉。\n<code>HeroComponent</code>是本特性区的顶级组件和路由宿主。\n模板带有<code>&#x3C;router-outlet></code>指令，它或者显示英雄列表（<code>HeroList</code>）或者显示所选英雄的编辑器（<code>HeroDetail</code>）。\n这两个组件都把获取和保存数据的任务委托给<code>HeroService</code>执行。</p>\n<p translation-origin=\"off\">Yet another <code>HighlightDirective</code> colors elements in yet a different shade.\nIn the next section, <a href=\"guide/ngmodule#shared-module\" title=\"Shared modules\">Shared modules</a>, you'll resolve the repetition and inconsistencies.</p>\n<p translation-result=\"\">还有<em>另一个</em><code>HighlightDirective</code>指令，它用另一种方式为元素染色。\n在下一节的<a href=\"guide/ngmodule#shared-module\" title=\"共享模块\">共享模块</a>中，我们会解决这种不必要的重复和不一致性。</p>\n<p translation-origin=\"off\">The <code>HeroModule</code> is a feature module like any other.</p>\n<p translation-result=\"\"><code>HeroModule</code>是特性模块，与其它的没什么不同。</p>\n<code-example path=\"ngmodule/src/app/hero/hero.module.3.ts\" region=\"class\" title=\"src/app/hero/hero.module.ts (class)\" linenums=\"false\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, HeroRoutingModule ],\n  declarations: [\n    HeroComponent, HeroDetailComponent, HeroListComponent,\n    HighlightDirective\n  ]\n})\nexport class HeroModule { }\n\n</code-example>\n<p translation-origin=\"off\">It imports the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> because the <code>HeroDetailComponent</code> template binds with <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>.\nIt imports the <code>HeroRoutingModule</code> from <code>hero-routing.module.ts</code> just as <code>ContactModule</code> and <code>CrisisModule</code> do.</p>\n<p translation-result=\"\">它导入了<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，因为<code>HeroDetailComponent</code>的模板中绑定到了<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>。\n像<code>ContactModule</code>和<code>CrisisModule</code>中一样，它还从<code>hero-routing.module.ts</code>中导入了<code>HeroRoutingModule</code>。</p>\n<p translation-origin=\"off\">The <code>CrisisModule</code> is much the same.</p>\n<p translation-result=\"\"><code>CrisisModule</code>和本模块非常像，我们不再赘述。</p>\n<p translation-result=\"\"><live-example embedded=\"\" plnkr=\"pre-shared.3\" img=\"guide/ngmodule/v3-plunker.png\">试试在线例子。</live-example></p>\n<a id=\"shared-module\"></a>\n<h2 translation-origin=\"off\" id=\"shared-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#shared-modules\"><i class=\"material-icons\">link</i></a>Shared modules</h2>\n<h2 translation-result=\"\" id=\"共享模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#共享模块\"><i class=\"material-icons\">link</i></a>共享模块</h2>\n<p translation-origin=\"off\">The app is shaping up.\nBut it carries three different versions of the <code>HighlightDirective</code>.\nAnd the many files cluttering the app folder level could be better organized.</p>\n<p translation-result=\"\">本应用在继续演进中。\n让我们感到不爽的是：这里有<code>HighlightDirective</code>的三个不同版本。\n还有一大堆其它乱七八糟的东西堆在 app 目录这一级，我们得把它们清出去。</p>\n<p translation-origin=\"off\">Add a <code>SharedModule</code> to hold the common components, directives, and pipes\nand share them with the modules that need them.</p>\n<p translation-result=\"\">我们添加<code>SharedModule</code>来存放这些公共组件、指令和管道，并且共享给那些需要它们的模块。</p>\n<ol>\n<li>\n<p translation-origin=\"off\">Create an <code>src/app/shared</code> folder.</p>\n<p translation-result=\"\">创建<code>src/app/shared</code>目录</p>\n</li>\n<li>\n<p translation-origin=\"off\">Move the <code>AwesomePipe</code> and <code>HighlightDirective</code> from <code>src/app/contact</code> to <code>src/app/shared</code>.</p>\n<p translation-result=\"\">把<code>AwesomePipe</code>和<code>HighlightDirective</code>从<code>src/app/contact</code>移到<code>src/app/shared</code>中。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Delete the <code>HighlightDirective</code> classes from <code>src/app/</code> and <code>src/app/hero</code>.</p>\n<p translation-result=\"\">从<code>src/app/</code>和<code>src/app/hero</code>目录中删除<code>HighlightDirective</code>类</p>\n</li>\n<li>\n<p translation-origin=\"off\">Create a <code>SharedModule</code> class to own the shared material.</p>\n<p translation-result=\"\">创建<code>SharedModule</code>类来管理这些共享的素材</p>\n</li>\n<li>\n<p translation-origin=\"off\">Update other feature modules to import <code>SharedModule</code>.</p>\n<p translation-result=\"\">更新其它特性模块，导入<code>SharedModule</code></p>\n</li>\n</ol>\n<p translation-origin=\"off\">Here is the <code>SharedModule</code>:</p>\n<p translation-result=\"\">下面就是这个<code>SharedModule</code>：</p>\n<code-example path=\"ngmodule/src/app/shared/shared.module.ts\" title=\"src/app/src/app/shared/shared.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }            from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }        from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }         from '@angular/forms';\n\nimport { AwesomePipe }         from './awesome.pipe';\nimport { HighlightDirective }  from './highlight.directive';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  declarations: [ AwesomePipe, HighlightDirective ],\n  exports:      [ AwesomePipe, HighlightDirective,\n                  <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> ]\n})\nexport class SharedModule { }\n\n</code-example>\n<p translation-origin=\"off\">Note the following:</p>\n<p translation-result=\"\">值得注意的有：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">It imports the <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> because its component needs common directives.</p>\n<p translation-result=\"\">它导入了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>，这是因为它的组件需要这些公共指令。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It declares and exports the utility pipe, directive, and component classes as expected.</p>\n<p translation-result=\"\">正如我们所期待的，它声明并导出了工具性的管道、指令和组件类。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It re-exports the <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code></p>\n<p translation-result=\"\">它重新导出了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>和<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code></p>\n</li>\n</ul>\n<h3 translation-origin=\"off\" id=\"re-exporting-other-modules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#re-exporting-other-modules\"><i class=\"material-icons\">link</i></a>Re-exporting other modules</h3>\n<h3 translation-result=\"\" id=\"重新导出其它模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#重新导出其它模块\"><i class=\"material-icons\">link</i></a>重新导出其它模块</h3>\n<p translation-origin=\"off\">If you review the application, you may notice that many components requiring <code>SharedModule</code> directives\nalso use <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> and <code>NgFor</code> from <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>\nand bind to component properties with <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>, a directive in the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.\nModules that declare these components would have to import <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>, <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>, and <code>SharedModule</code>.</p>\n<p translation-result=\"\">当回顾应用程序时，我们注意到很多需要<code>SharedModule</code>的组件也同时用到了来自<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>的<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>和<code>NgFor</code>指令，\n并且还通过来自<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>的<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>指令绑定到了组件的属性。\n那些声明这些组件的模块将不得不同时导入<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>、<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>和<code>SharedModule</code>。</p>\n<p translation-origin=\"off\">You can reduce the repetition by having <code>SharedModule</code> re-export <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>\nso that importers of <code>SharedModule</code> get <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> for free.</p>\n<p translation-result=\"\">通过让<code>SharedModule</code>重新导出<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>和<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>模块，我们可以消除这种重复。\n于是导入<code>SharedModule</code>的模块也同时<em>免费</em>获得了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>和<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n<p translation-origin=\"off\">As it happens, the components declared by <code>SharedModule</code> itself don't bind with <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>.\nTechnically,  there is no need for <code>SharedModule</code> to import <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.</p>\n<p translation-result=\"\">实际上，<code>SharedModule</code>本身所声明的组件没绑定过<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>，那么，严格来说<code>SharedModule</code>并不需要导入<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n<p translation-origin=\"off\"><code>SharedModule</code> can still export <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> without listing it among its <code>imports</code>.</p>\n<p translation-result=\"\">这时<code>SharedModule</code>仍然可以导出<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>，而不需要先把它列在<code>imports</code>中。</p>\n<h3 translation-origin=\"off\" id=\"why-titlecomponent-isnt-shared\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-titlecomponent-isnt-shared\"><i class=\"material-icons\">link</i></a>Why <em>TitleComponent</em> isn't shared</h3>\n<h3 translation-result=\"\" id=\"为什么-titlecomponent-没有被共享\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#为什么-titlecomponent-没有被共享\"><i class=\"material-icons\">link</i></a>为什么 <em>TitleComponent</em> 没有被共享</h3>\n<p translation-origin=\"off\"><code>SharedModule</code> exists to make commonly used components, directives, and pipes available\nfor use in the templates of components in many other modules.</p>\n<p translation-result=\"\">设计<code>SharedModule</code>的目的在于让常用的组件、指令和管道可以被用在<em>很多</em>其它模块的组件模板中。</p>\n<p translation-origin=\"off\">The <code>TitleComponent</code> is used only once by the <code>AppComponent</code>.\nThere's no point in sharing it.</p>\n<p translation-result=\"\">而<code>TitleComponent</code><em>只被</em><code>AppComponent</code>用了一次，因此没必要共享它。</p>\n<a id=\"no-shared-module-providers\"></a>\n<h3 translation-origin=\"off\" id=\"why-userservice-isnt-shared\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-userservice-isnt-shared\"><i class=\"material-icons\">link</i></a>Why <em>UserService</em> isn't shared</h3>\n<h3 translation-result=\"\" id=\"为什么-userservice-没有被共享\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#为什么-userservice-没有被共享\"><i class=\"material-icons\">link</i></a>为什么 <em>UserService</em> 没有被共享</h3>\n<p translation-origin=\"off\">While many components share the same service instances,\nthey rely on Angular dependency injection to do this kind of sharing, not the module system.</p>\n<p translation-result=\"\">虽然很多组件都共享着同一个服务<em>实例</em>，但它们是靠 Angular 的依赖注入体系实现的，而不是模块体系。</p>\n<p translation-origin=\"off\">Several components of the sample inject the <code>UserService</code>.\nThere should be only one instance of the <code>UserService</code> in the entire application\nand only one provider of it.</p>\n<p translation-result=\"\">例子中的很多组件都注入了<code>UserService</code>。\n在整个应用程序中，<em>只应该有一个</em><code>UserService</code>的实例，并且它<em>只应该有一个</em>提供商。</p>\n<p translation-origin=\"off\"><code>UserService</code> is an application-wide singleton.\nYou don't want each module to have its own separate instance.\nYet there is <a href=\"guide/ngmodule-faq#q-why-bad\">a real danger</a> of that happening</p>\n<!-- CF: This link goes to the top of the NgModule FAQs page.\nIt looks like it is supposed to go to a specific question/section within the page. -->\n<p translation-origin=\"off\">if the <code>SharedModule</code> provides the <code>UserService</code>.</p>\n<p translation-result=\"\"><code>UserService</code>是全应用级单例。\n我们不希望每个模块都各自有它的实例。\n而如果由<code>SharedModule</code>提供<code>UserService</code>，就会导致<a href=\"guide/ngmodule-faq#q-why-bad\">铁板钉钉的危险</a>。</p>\n<div class=\"alert is-critical\">\n<p translation-origin=\"off\">Do <em>not</em> specify app-wide singleton <code>providers</code> in a shared module.\nA lazy-loaded module that imports that shared module makes its own copy of the service.</p>\n<p translation-result=\"\"><strong>不要</strong>在共享模块中把应用级单例添加到<code>providers</code>中。\n否则如果一个惰性加载模块导入了此共享模块，就会导致它自己也生成一份此服务的实例。</p>\n</div>\n<a id=\"core-module\"></a>\n<h2 translation-origin=\"off\" id=\"the-core-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#the-core-module\"><i class=\"material-icons\">link</i></a>The Core module</h2>\n<h2 translation-result=\"\" id=\"核心-core-模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#核心-core-模块\"><i class=\"material-icons\">link</i></a>核心 (Core) 模块</h2>\n<p translation-origin=\"off\">At the moment, the root folder is cluttered with the <code>UserService</code>\nand <code>TitleComponent</code> that only appear in the root <code>AppComponent</code>.\nYou didn't include them in the <code>SharedModule</code> for reasons just explained.</p>\n<p translation-result=\"\">现在，我们的根目录下只剩下<code>UserService</code>和<code>TitleComponent</code>这两个被根组件<code>AppComponent</code>用到的类没有清理了。\n但正如我们已经解释过的，它们无法被包含在<code>SharedModule</code>中。</p>\n<p translation-origin=\"off\">Instead, gather them in a single <code>CoreModule</code> that you import once when the app starts\nand never import anywhere else.</p>\n<p translation-result=\"\">不过，我们可以把它们收集到单独的<code>CoreModule</code>中，并且<strong>只在应用启动时导入它<em>一次</em></strong>，<strong>而不会在其它地方导入它</strong>。</p>\n<p translation-origin=\"off\">Perform the following steps:</p>\n<p translation-result=\"\">执行下列步骤：</p>\n<ol>\n<li>\n<p translation-origin=\"off\">Create an <code>src/app/core</code> folder.</p>\n<p translation-result=\"\">创建<code>src/app/core</code>文件夹</p>\n</li>\n<li>\n<p translation-origin=\"off\">Move the <code>UserService</code> and <code>TitleComponent</code> from <code>src/app/</code> to <code>src/app/core</code>.</p>\n<p translation-result=\"\">把<code>UserService</code>和<code>TitleComponent</code>从<code>src/app</code>移到<code>src/app/core</code>中</p>\n</li>\n<li>\n<p translation-origin=\"off\">Create a <code>CoreModule</code> class to own the core material.</p>\n<p translation-result=\"\">创建<code>CoreModule</code>类来管理这些核心素材</p>\n</li>\n<li>\n<p translation-origin=\"off\">Update the <code>AppRoot</code> module to  import <code>CoreModule</code>.</p>\n<p translation-result=\"\">修改<code>AppRoot</code>模块，使其导入<code>CoreModule</code>模块</p>\n</li>\n</ol>\n<p translation-origin=\"off\">Most of this work is familiar. The interesting part is the <code>CoreModule</code>.</p>\n<p translation-result=\"\">这些都是一些熟悉的普通任务。令人感兴趣的是<code>CoreModule</code>：</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"v4\" title=\"src/app/src/app/core/core.module.ts\">\nimport {\n  <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a>, <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>,\n  <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>, <a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a> }       from '@angular/core';\n\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }      from '@angular/common';\n\nimport { TitleComponent }    from './title.component';\nimport { UserService }       from './user.service';\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> ],\n  declarations: [ TitleComponent ],\n  exports:      [ TitleComponent ],\n  providers:    [ UserService ]\n})\nexport class CoreModule {\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">You're importing some extra symbols from the Angular core library that you're not using yet.\nThey'll become relevant later in this page.</p>\n<p translation-result=\"\">我们正在从 Angular 核心库中导入一些从未用到的符号，稍后我们会接触它们。</p>\n</div>\n<p translation-origin=\"off\">The <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> metadata should be familiar.\nYou declare the <code>TitleComponent</code>  because this module owns it and you export it\nbecause <code>AppComponent</code> (which is in <code>AppModule</code>) displays the title in its template.\n<code>TitleComponent</code> needs the Angular <code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code> directive that you import from <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>.</p>\n<p translation-result=\"\">我们对<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的元数据应该很熟悉。\n由于该模块<em>拥有</em><code>TitleComponent</code>，所以我们声明了它。由于<code>AppComponent</code>（位于<code>AppModule</code>模块）在模板中显示了这个标题，所以我们导出了它。\n由于<code>TitleComponent</code>需要用到 Angular 的<code><a href=\"api/common/NgIf\" class=\"code-anchor\">NgIf</a></code>指令，所以我们导入了<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>。</p>\n<p translation-origin=\"off\"><code>CoreModule</code> provides the <code>UserService</code>. Angular registers that provider with the app root injector,\nmaking a singleton instance of the <code>UserService</code> available to any component that needs it,\nwhether that component is eagerly or lazily loaded.</p>\n<p translation-result=\"\"><code>CoreModule</code><em>提供</em>了<code>UserService</code>。Angular 在该应用的根注入器中注册了它的提供商，\n导致这份<code>UserService</code>的实例在每个需要它的组件中都是可用的，无论那个组件时主动加载的还是惰性加载的。</p>\n<div class=\"l-sub-section\">\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"why-bother\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#why-bother\"><i class=\"material-icons\">link</i></a>Why bother?</h3>\n<h3 translation-result=\"\" class=\"no-toc\" id=\"没必要？\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#没必要？\"><i class=\"material-icons\">link</i></a>没必要？</h3>\n<p translation-origin=\"off\">This scenario is clearly contrived.\nThe app is too small to worry about a single service file and a tiny, one-time component.</p>\n<p translation-result=\"\">这个场景设计的是有点生硬。\n该应用太小了，所以其实并不需要拆分出单独的服务文件和小型的、一次性的组件。</p>\n<p translation-origin=\"off\">A <code>TitleComponent</code> sitting in the root folder isn't bothering anyone.\nThe root <code>AppModule</code> can register the <code>UserService</code> itself,\nas it does currently, even if you decide to relocate the <code>UserService</code> file to the <code>src/app/core</code> folder.</p>\n<p translation-result=\"\">把<code>TitleComponent</code>放在根目录中其实也无所谓。\n即使我们决定把<code>UserService</code>文件挪到<code>app/core</code>目录中，根<code>AppModule</code>也仍然可以自己注册<code>UserService</code>（就像现在这样）。</p>\n<p translation-origin=\"off\">Real-world apps have more to worry about.\nThey can have several single-use components (such as spinners, message toasts, and modal dialogs)\nthat appear only in the <code>AppComponent</code> template.\nYou don't import them elsewhere so they're not shared in that sense.\nYet they're too big and messy to leave loose in the root folder.</p>\n<p translation-result=\"\">但真实的应用要考虑很多。\n它们有一些只用于<code>AppComponent</code>的模板的一次性的组件（例如：加载动画、消息浮层和模态对话框等）。\n我们不用在其它地方导入它们，因此没必要<em>共享</em>它们。\n然而如果把它们留在根目录，还是显得太大、太乱了。</p>\n<p translation-origin=\"off\">Apps often have many singleton services like this sample's <code>UserService</code>.\nEach must be registered exactly once, in the app root injector, when the application starts.</p>\n<p translation-result=\"\">应用通常还有很多像这里的<code>UserService</code>这样的单例服务。\n当程序启动时，每个服务都只能在应用的“根注入器”中<em>注册一次</em>。</p>\n<p translation-origin=\"off\">While many components inject such services in their constructors—and\ntherefore require JavaScript <code>import</code> statements to import their symbols—no\nother component or module should define or re-create the services themselves.\nTheir <em>providers</em> aren't shared.</p>\n<p translation-result=\"\">当很多组件在它们的构造函数中注入这些服务时 —\n因此也需要用 JavaScript 的<code>import</code>语句来导入它们的符号 —\n任何组件或模块自身都不应该定义或重新创建这些服务。\n因为它们的<em>提供商</em>不是共享的。</p>\n<p translation-origin=\"off\">We recommend collecting such single-use classes and hiding their details inside a <code>CoreModule</code>.\nA simplified root <code>AppModule</code> imports <code>CoreModule</code> in its capacity as orchestrator of the application as a whole.</p>\n<p translation-result=\"\">因此我们建议把这些一次性的类收集到<code>CoreModule</code>中，并且隐藏它们的实现细节。\n简化之后的根模块<code>AppModule</code>导入<code>CoreModule</code>来获取其能力。记住，根模块是整个应用的总指挥，不应该插手过多细节。</p>\n</div>\n<h2 translation-origin=\"off\" id=\"cleanup\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#cleanup\"><i class=\"material-icons\">link</i></a>Cleanup</h2>\n<h2 translation-result=\"\" id=\"清理\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#清理\"><i class=\"material-icons\">link</i></a>清理</h2>\n<p translation-origin=\"off\">Having refactored to a <code>CoreModule</code> and a <code>SharedModule</code>, it's time to clean up the other modules.</p>\n<p translation-result=\"\">我们已经重构完<code>CoreModule</code>和<code>SharedModule</code>，现在开始清理其它模块。</p>\n<h3 translation-origin=\"off\" id=\"a-trimmer-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#a-trimmer-appmodule\"><i class=\"material-icons\">link</i></a>A trimmer <em>AppModule</em></h3>\n<h3 translation-result=\"\" id=\"清理-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#清理-appmodule\"><i class=\"material-icons\">link</i></a>清理 <em>AppModule</em></h3>\n<p translation-origin=\"off\">Here is the updated <code>AppModule</code> paired with version 3 for comparison:</p>\n<p translation-result=\"\">这里是更新后的<code>AppModule</code>与其第三版本的对比：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/app.module.ts (v4)\" path=\"ngmodule/src/app/app.module.ts\" region=\"v4\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }       from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }  from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n/* App Root */\nimport { AppComponent }   from './app.component';\n\n/* Feature Modules */\nimport { ContactModule }    from './contact/contact.module';\nimport { CoreModule }       from './core/core.module';\n\n/* Routing Module */\nimport { AppRoutingModule } from './app-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    CoreModule,\n    AppRoutingModule\n  ],\n  declarations: [ AppComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n</code-pane>\n\n  <code-pane title=\"src/app/app.module.ts (v3)\" path=\"ngmodule/src/app/app.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> }      from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n/* App Root */\nimport { AppComponent }       from './app.component.3';\nimport { HighlightDirective } from './highlight.directive';\nimport { TitleComponent }     from './title.component';\nimport { UserService }        from './user.service';\n\n/* Feature Modules */\nimport { ContactModule }      from './contact/contact.module.3';\n\n/* Routing Module */\nimport { AppRoutingModule }   from './app-routing.module.3';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    ContactModule,\n    AppRoutingModule\n  ],\n  providers:    [ UserService ],\n  declarations: [ AppComponent, HighlightDirective, TitleComponent ],\n  bootstrap:    [ AppComponent ]\n})\nexport class AppModule { }\n\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\"><code>AppModule</code> now has the following qualities:</p>\n<p translation-result=\"\"><code>AppModule</code>现在变得：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">A little smaller because many <code>src/app/root</code> classes have moved to other modules.</p>\n<p translation-result=\"\">更小了。因为很多<code>src/app/root</code>下的类被移到了其它模块。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Stable because you'll add future components and providers to other modules, not this one.</p>\n<p translation-result=\"\">更稳定了。因为我们以后会在其它模块中添加组件和服务提供商，而不是这里。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Delegated to imported modules rather than doing work.</p>\n<p translation-result=\"\">导入其它模块并把任务委托给它们，而不是亲力亲为。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Focused on its main task, orchestrating the app as a whole.</p>\n<p translation-result=\"\">聚焦于自己的主要任务：总指挥整个应用程序。</p>\n</li>\n</ul>\n<h3 translation-origin=\"off\" id=\"a-trimmer-contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#a-trimmer-contactmodule\"><i class=\"material-icons\">link</i></a>A trimmer <em>ContactModule</em></h3>\n<h3 translation-result=\"\" id=\"清理contactmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#清理contactmodule\"><i class=\"material-icons\">link</i></a>清理<em>ContactModule</em></h3>\n<p translation-origin=\"off\">Here is the new <code>ContactModule</code> paired with the prior version:</p>\n<p translation-result=\"\">这里是新的<code>ContactModule</code>与以前版本的对比：</p>\n<code-tabs>\n\n  <code-pane title=\"src/app/contact/contact.module.ts (v4)\" path=\"ngmodule/src/app/contact/contact.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { SharedModule }       from '../shared/shared.module';\n\nimport { ContactComponent }     from './contact.component';\nimport { ContactService }       from './contact.service';\nimport { ContactRoutingModule } from './contact-routing.module';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ SharedModule, ContactRoutingModule ],\n  declarations: [ ContactComponent ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n\n</code-pane>\n\n  <code-pane title=\"src/app/contact/contact.module.ts (v3)\" path=\"ngmodule/src/app/contact/contact.module.3.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> }           from '@angular/core';\nimport { <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a> }       from '@angular/common';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> }        from '@angular/forms';\n\nimport { AwesomePipe }        from './awesome.pipe';\n\nimport { ContactComponent }   from './contact.component.3';\nimport { ContactService }     from './contact.service';\nimport { HighlightDirective } from './highlight.directive';\n\nimport { ContactRoutingModule }   from './contact-routing.module.3';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports:      [ <a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a>, <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>, ContactRoutingModule ],\n  declarations: [ ContactComponent, HighlightDirective, AwesomePipe ],\n  providers:    [ ContactService ]\n})\nexport class ContactModule { }\n\n</code-pane>\n\n</code-tabs>\n<p translation-origin=\"off\">Notice the following:</p>\n<p translation-result=\"\">注意：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">The <code>AwesomePipe</code> and <code>HighlightDirective</code> are gone.</p>\n<p translation-result=\"\"><code>AwesomePipe</code>和<code>HighlightDirective</code>不见了。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The imports include <code>SharedModule</code> instead of <code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code> and <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.</p>\n<p translation-result=\"\">导入<code>SharedModule</code>，不再导入<code><a href=\"api/common/CommonModule\" class=\"code-anchor\">CommonModule</a></code>和<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The new version is leaner and cleaner.</p>\n<p translation-result=\"\">这个新版本更加精简和干净了。</p>\n</li>\n</ul>\n<hr>\n<a id=\"core-for-root\"></a>\n<h2 translation-origin=\"off\" id=\"configure-core-services-with-coremoduleforroot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#configure-core-services-with-coremoduleforroot\"><i class=\"material-icons\">link</i></a>Configure core services with <em>CoreModule.forRoot</em></h2>\n<h2 translation-result=\"\" id=\"用-coremoduleforroot-配置核心服务\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#用-coremoduleforroot-配置核心服务\"><i class=\"material-icons\">link</i></a>用 <em>CoreModule.forRoot</em> 配置核心服务</h2>\n<p translation-origin=\"off\">A module that adds providers to the application can offer a facility for configuring those providers as well.</p>\n<p translation-result=\"\">为应用添加服务提供商的模块也可以同时提供配置那些提供商的功能。</p>\n<p translation-origin=\"off\">By convention, the <code>forRoot</code> static method both provides and configures services at the same time.\nIt takes a service configuration object and returns a\n<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>, which is\na simple object with the following properties:</p>\n<p translation-result=\"\">按照约定，模块的静态方法<strong><em>forRoot</em></strong>可以同时提供并配置服务。\n它接收一个服务配置对象，并返回一个<a href=\"api/core/ModuleWithProviders\">ModuleWithProviders</a>。这个简单对象具有两个属性：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>ngModule</code>: the <code>CoreModule</code> class</p>\n<p translation-result=\"\"><code>ngModule</code> - <code>CoreModule</code>类</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>providers</code>: the configured providers</p>\n<p translation-result=\"\"><code>providers</code> - 配置好的服务提供商</p>\n</li>\n</ul>\n<p translation-origin=\"off\">The root <code>AppModule</code> imports the <code>CoreModule</code> and adds the <code>providers</code> to the <code>AppModule</code> providers.</p>\n<p translation-result=\"\">根模块<code>AppModule</code>会导入<code>CoreModule</code>类并把它的<code>providers</code>添加到<code>AppModule</code>的服务提供商中。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">More precisely, Angular accumulates all imported providers before appending the items listed in <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.providers</code>.\nThis sequence ensures that whatever you add explicitly to the <code>AppModule</code> providers takes precedence\nover the providers of imported modules.</p>\n<p translation-result=\"\">更精确的说法是，Angular 会先累加所有导入的提供商，<em>然后才</em>把它们追加到<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>.providers</code>中。\n这样可以确保我们显式添加到<code>AppModule</code>中的那些提供商总是优先于从其它模块中导入的提供商。</p>\n</div>\n<p translation-origin=\"off\">Add a <code>CoreModule.forRoot</code> method that configures the core <code>UserService</code>.</p>\n<p translation-result=\"\">现在添加<code>CoreModule.forRoot</code>方法，以便配置核心中的<code>UserService</code>。</p>\n<p translation-origin=\"off\">You've extended the core <code>UserService</code> with an optional, injected <code>UserServiceConfig</code>.\nIf a <code>UserServiceConfig</code> exists, the <code>UserService</code> sets the user name from that config.</p>\n<p translation-result=\"\">我们曾经用一个可选的、被注入的<code>UserServiceConfig</code>服务扩展过核心的<code>UserService</code>服务。\n如果有<code>UserServiceConfig</code>，<code>UserService</code>就会据此设置用户名。</p>\n<code-example path=\"ngmodule/src/app/core/user.service.ts\" region=\"ctor\" title=\"src/app/core/user.service.ts (constructor)\" linenums=\"false\">\nconstructor(@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() config: UserServiceConfig) {\n  if (config) { this._userName = config.userName; }\n}\n\n</code-example>\n<p translation-origin=\"off\">Here's <code>CoreModule.forRoot</code> that takes a <code>UserServiceConfig</code> object:</p>\n<p translation-result=\"\">这里的<code>CoreModule.forRoot</code>接收<code>UserServiceConfig</code>对象：</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"for-root\" title=\"src/app/core/core.module.ts (forRoot)\" linenums=\"false\">\n<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> forRoot(config: UserServiceConfig): <a href=\"api/core/ModuleWithProviders\" class=\"code-anchor\">ModuleWithProviders</a> {\n  return {\n    ngModule: CoreModule,\n    providers: [\n      {provide: UserServiceConfig, useValue: config }\n    ]\n  };\n}\n\n</code-example>\n<p translation-origin=\"off\">Lastly, call it within the <code>imports</code> list of the <code>AppModule</code>.</p>\n<p translation-result=\"\">最后，我们在<code>AppModule</code>的<code>imports</code><em>列表</em>中调用它。</p>\n<code-example path=\"ngmodule/src/app/app.module.ts\" region=\"import-for-root\" title=\"src/app//app.module.ts (imports)\" linenums=\"false\">\nimports: [\n  <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ContactModule,\n  CoreModule.forRoot({userName: 'Miss Marple'}),\n  AppRoutingModule\n],\n\n</code-example>\n<p translation-origin=\"off\">The app displays \"Miss Marple\" as the user instead of the default \"Sherlock Holmes\".</p>\n<p translation-result=\"\">该应用不再显示默认的 “Sherlock Holmes”，而是用 “Miss Marple” 作为用户名称。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">Call <code>forRoot</code> only in the root application module, <code>AppModule</code>.\nCalling it in any other module, particularly in a lazy-loaded module,\nis contrary to the intent and can produce a runtime error.</p>\n<p translation-result=\"\">只在应用的根模块<code>AppModule</code>中调用<code>forRoot</code>。\n如果在其它模块（特别是惰性加载模块）中调用它则违反了设计意图，并会导致运行时错误。</p>\n<p translation-origin=\"off\">Remember to <em>import</em> the result; don't add it to any other <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> list.</p>\n<p translation-result=\"\">别忘了<em>导入</em>其返回结果，而且不要把它添加到<code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的其它任何列表中。</p>\n</div>\n<hr>\n<a id=\"prevent-reimport\"></a>\n<h2 translation-origin=\"off\" id=\"prevent-reimport-of-the-coremodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#prevent-reimport-of-the-coremodule\"><i class=\"material-icons\">link</i></a>Prevent reimport of the <em>CoreModule</em></h2>\n<h2 translation-result=\"\" id=\"禁止多次导入coremodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#禁止多次导入coremodule\"><i class=\"material-icons\">link</i></a>禁止多次导入<em>CoreModule</em></h2>\n<p translation-origin=\"off\">Only the root <code>AppModule</code> should import the <code>CoreModule</code>.\n<a href=\"guide/ngmodule-faq#q-why-bad\">Bad things happen</a> if a lazy-loaded module imports it.</p>\n<!-- CF: Again, this link goes to the top of the NgModule FAQs page.\nIt looks like it is supposed to go to a specific question/section within the page. -->\n<p translation-result=\"\">只有根模块<code>AppModule</code>才能导入<code>CoreModule</code>。\n如果惰性加载模块导入了它，就会<a href=\"guide/ngmodule-faq#q-why-bad\">出问题</a>。</p>\n<p translation-origin=\"off\">You could hope that no developer makes that mistake.\nOr you can guard against it and fail fast by adding the following <code>CoreModule</code> constructor.</p>\n<p translation-result=\"\">我们可以<em>祈祷</em>任何开发人员都不会犯错。\n但是最好还是对它进行一些保护，以便让它“尽快出错”。只要把下列代码添加到<code>CoreModule</code>的构造函数中就可以了。</p>\n<code-example path=\"ngmodule/src/app/core/core.module.ts\" region=\"ctor\" title=\"src/app/core/core.module.ts\" linenums=\"false\">\nconstructor (@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a>() @<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a>() parentModule: CoreModule) {\n  if (parentModule) {\n    throw new Error(\n      'CoreModule is already loaded. Import it in the AppModule only');\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">The constructor tells Angular to inject the <code>CoreModule</code> into itself.\nThat seems dangerously circular.</p>\n<p translation-result=\"\">这个构造函数会要求 Angular 把<code>CoreModule</code>注入自身。这看起来像一个危险的循环注入。</p>\n<p translation-origin=\"off\">The injection would be circular if Angular looked for <code>CoreModule</code> in the <em>current</em> injector.\nThe <code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> decorator means \"look for <code>CoreModule</code> in an ancestor injector, above me in the injector hierarchy.\"</p>\n<p translation-result=\"\">确实，如果 Angular 在<em>当前</em>注入器中查阅<code>CoreModule</code>，这确实会是一个循环引用。\n不过，<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code>装饰器意味着“在当前注入器的所有祖先注入器中寻找<code>CoreModule</code>。”</p>\n<p translation-origin=\"off\">If the constructor executes as intended in the <code>AppModule</code>,\nthere is no ancestor injector that could provide an instance of <code>CoreModule</code>.\nThe injector should give up.</p>\n<p translation-result=\"\">如果该构造函数在我们所期望的<code>AppModule</code>中运行，就没有任何祖先注入器能够提供<code>CoreModule</code>的实例，于是注入器会放弃查找。</p>\n<p translation-origin=\"off\">By default, the injector throws an error when it can't find a requested provider.\nThe <code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code> decorator means not finding the service is OK.\nThe injector returns <code>null</code>, the <code>parentModule</code> parameter is null,\nand the constructor concludes uneventfully.</p>\n<p translation-result=\"\">默认情况下，当注入器找不到想找的提供商时，会抛出一个错误。\n但<code>@<a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code>装饰器表示找不到该服务也无所谓。\n于是注入器会返回<code>null</code>，<code>parentModule</code>参数也就被赋成了空值，而构造函数没有任何异常。</p>\n<p translation-origin=\"off\">It's a different story if you improperly import <code>CoreModule</code> into a lazy-loaded module such as <code>HeroModule</code> (try it).</p>\n<p translation-result=\"\">如果我们错误的把<code>CoreModule</code>导入了一个惰性加载模块（例如<code>HeroModule</code>）中，那就不一样了。</p>\n<p translation-origin=\"off\">Angular creates a lazy-loaded module with its own injector, a <em>child</em> of the root injector.\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code> causes Angular to look for a <code>CoreModule</code> in the parent injector, which this time is the root injector.\nOf course it finds the instance imported by the root <code>AppModule</code>.\nNow <code>parentModule</code> exists and the constructor throws the error.</p>\n<p translation-result=\"\">Angular 创建一个惰性加载模块，它具有自己的注入器，它是根注入器的<em>子注入器</em>。\n<code>@<a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code>让 Angular 在其父注入器中查找<code>CoreModule</code>，这次，它的父注入器却是根注入器了（而上次父注入器是空）。\n当然，这次它找到了由根模块<code>AppModule</code>导入的实例。\n该构造函数检测到存在<code>parentModule</code>，于是抛出一个错误。</p>\n<h2 translation-origin=\"off\" id=\"conclusion\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#conclusion\"><i class=\"material-icons\">link</i></a>Conclusion</h2>\n<h2 translation-result=\"\" id=\"总结\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#总结\"><i class=\"material-icons\">link</i></a>总结</h2>\n<p translation-origin=\"off\">You made it! You can examine and download the complete source for this final version from the live example.</p>\n<p translation-result=\"\">完工！你可以到下面的在线例子中试验它，并下载最终版本的全部源码。</p>\n<p translation-origin=\"off\"><live-example embedded=\"\" img=\"guide/ngmodule/final-plunker.png\"></live-example></p>\n<h2 translation-origin=\"off\" id=\"frequently-asked-questions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#frequently-asked-questions\"><i class=\"material-icons\">link</i></a>Frequently asked questions</h2>\n<h2 translation-result=\"\" id=\"常见问题-faq\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/ngmodule#常见问题-faq\"><i class=\"material-icons\">link</i></a>常见问题 (FAQ)</h2>\n<p translation-origin=\"off\">Now that you understand NgModules, you may be interested\nin the companion <a href=\"guide/ngmodule-faq\" title=\"NgModule FAQs\">NgModule FAQs</a> page\nwith its ready answers to specific design and implementation questions.</p>\n<p translation-result=\"\">现在，你已经理解了 Angular 的模块。可能你还会对烹饪宝典中的\n<a href=\"guide/ngmodule-faq\" title=\"Angular 模块常见问题\">Angular 模块常见问题</a>感兴趣，\n它解答了很多关于设计和实现方面的问题。</p>\n\n</div>"
}