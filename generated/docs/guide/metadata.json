{
  "id": "guide/metadata",
  "title": "Angular Metadata and AOT",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"angular-metadata-and-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#angular-metadata-and-aot\"><i class=\"material-icons\">link</i></a>Angular Metadata and AOT</h1>\n<p translation-origin=\"off\">The Angular <strong>AOT compiler</strong> turns your TypeScript source code into runnable JavaScript.\nAs part of that process, the compiler extracts and interprets <strong>metadata</strong> about the parts of the application that Angular is supposed to manage.</p>\n<p translation-origin=\"off\">You write metadata in a <em>subset</em> of TypeScript. This guide explains why a subset is necessary, describes the subset constraints, and what happens when you step outside of those constraints.</p>\n<h2 translation-origin=\"off\" id=\"angular-metadata\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#angular-metadata\"><i class=\"material-icons\">link</i></a>Angular metadata</h2>\n<p translation-origin=\"off\">Angular metadata tells Angular how to construct instances of your application classes and interact with them at runtime.</p>\n<p translation-origin=\"off\">You specify the metadata with <strong>decorators</strong> such as <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> and <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code>.\nYou also specify metadata implicitly in the constructor declarations of these decorated classes.</p>\n<p translation-origin=\"off\">In the following example, the <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>()</code> metadata object and the class constructor tell Angular how to create and display an instance of <code>TypicalComponent</code>.</p>\n<code-example language=\"typescript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-typical',\n  template: '&#x3C;div>A typical component for {{data.name}}&#x3C;/div>'\n)}\nexport class TypicalComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() data: TypicalData;\n  constructor(private someService: SomeService) { ... }\n}\n</code-example>\n<p translation-origin=\"off\">The Angular compiler extracts the metadata <em>once</em> and generates a <em>factory</em> for <code>TypicalComponent</code>.\nWhen it needs to create a <code>TypicalComponent</code> instance, Angular calls the factory, which produces a new visual element, bound to a new instance of the component class with its injected dependency.</p>\n<h2 translation-origin=\"off\" id=\"compile-ahead-of-time-aot\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#compile-ahead-of-time-aot\"><i class=\"material-icons\">link</i></a>Compile ahead-of-time (AOT)</h2>\n<p translation-origin=\"off\">You should use AOT to compile an application that must launch quickly.\nWith AOT, there is no runtime compile step.\nThe client doesn't need the compiler library at all and excluding it significantly reduces the total payload.\nThe browser downloads a smaller set of safely-compiled, application module(s) and libraries that it can parse quickly and run almost immediately.</p>\n<p translation-origin=\"off\">The AOT compiler produces a number of files, including the application JavaScript that ultimately runs in the browser. It then statically analyzes your source code and interprets the Angular metadata without actually running the application.</p>\n<p translation-origin=\"off\">To compile the app, run the <code>ngc</code> stand-alone tool as part of your build process.\nWhen using the CLI, run the <code>ng build</code> command.</p>\n<p translation-origin=\"off\">For more information on AOT, see <a href=\"guide/aot-compiler\">Ahead-of-Time Compilation</a>.</p>\n<h2 translation-origin=\"off\" id=\"metadata-restrictions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#metadata-restrictions\"><i class=\"material-icons\">link</i></a>Metadata restrictions</h2>\n<p translation-origin=\"off\">Angular metadata expressions must conform to the following general constraints:</p>\n<ol>\n<li>Limit <a translation-origin=\"off\" href=\"guide/metadata#expression-syntax\">expression syntax</a> to the supported subset of JavaScript.</li>\n<li>Only reference exported symbols after <a translation-origin=\"off\" href=\"guide/metadata#folding\">code folding</a>.</li>\n<li>Only call <a translation-origin=\"off\" href=\"guide/metadata#supported-functions\">functions supported</a> by the compiler.</li>\n<li>Decorated and data-bound class members must be public.</li>\n</ol>\n<p translation-origin=\"off\">The next sections elaborate on these points.</p>\n<h2 translation-origin=\"off\" id=\"how-aot-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#how-aot-works\"><i class=\"material-icons\">link</i></a>How AOT works</h2>\n<p translation-origin=\"off\">It helps to think of the AOT compiler as having two phases: a code analysis phase in which it simply records a representation of the source; and a code generation phase in which the compiler's <code>StaticReflector</code> handles the interpretation as well as places restrictions on what it interprets.</p>\n<h2 translation-origin=\"off\" id=\"phase-1-analysis\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#phase-1-analysis\"><i class=\"material-icons\">link</i></a>Phase 1: analysis</h2>\n<p translation-origin=\"off\">The TypeScript compiler does some of the analytic work of the first phase. It emits the <code>.d.ts</code> <em>type definition files</em> with type information that the AOT compiler needs to generate application code.</p>\n<p translation-origin=\"off\">At the same time, the AOT <strong><em>collector</em></strong> analyzes the metadata recorded in the Angular decorators and outputs metadata information in <strong><code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code></strong> files, one per <code>.d.ts</code> file.</p>\n<p translation-origin=\"off\">You can think of <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> as a diagram of the overall structure of a decorator's metadata, represented as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">abstract syntax tree (AST)</a>.</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Angular's <a href=\"https://github.com/angular/angular/blob/master/packages/tsc-wrapped/src/schema.ts\">schema.ts</a>\ndescribes the JSON format as a collection of TypeScript interfaces.</p>\n</div>\n<a id=\"expression-syntax\"></a>\n<h3 translation-origin=\"off\" id=\"expression-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#expression-syntax\"><i class=\"material-icons\">link</i></a>Expression syntax</h3>\n<p translation-origin=\"off\">The <em>collector</em> only understands a subset of JavaScript.\nDefine metadata objects with the following limited syntax:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Example</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td><code>{cherry: true, apple: true, mincemeat: false}</code></td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td><code>['cherries', 'flour', 'sugar']</code></td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td><code>['apples', 'flour', ...the_rest]</code></td>\n</tr>\n<tr>\n<td>Calls</td>\n<td><code>bake(ingredients)</code></td>\n</tr>\n<tr>\n<td>New</td>\n<td><code>new Oven()</code></td>\n</tr>\n<tr>\n<td>Property access</td>\n<td><code>pie.<a href=\"api/common/SlicePipe\" class=\"code-anchor\">slice</a></code></td>\n</tr>\n<tr>\n<td>Array index</td>\n<td><code>ingredients[0]</code></td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n</tr>\n<tr>\n<td>A template string</td>\n<td><code>\n`\npie is ${multiplier} times better than cake\n`\n</code></td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td><code>'pi'</code></td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td><code>3.14153265</code></td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td><code>true</code></td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td><code>null</code></td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td><code>!cake</code></td>\n</tr>\n<tr>\n<td>Supported Binary operator</td>\n<td><code>a + b</code></td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td><code>a ? b : c</code></td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td><code>(a + b)</code></td>\n</tr>\n</tbody>\n</table>\n<p translation-origin=\"off\">If an expression uses unsupported syntax, the <em>collector</em> writes an error node to the <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> file. The compiler later reports the error if it needs that\npiece of metadata to generate the application code.</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\"> If you want <code>ngc</code> to report syntax errors immediately rather than produce a <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> file with errors, set the <code>strictMetadataEmit</code> option in <code>tsconfig</code>.</p>\n<code-example>\n  \"angularCompilerOptions\": {\n   ...\n   \"strictMetadataEmit\" : true\n }\n</code-example>\n<p translation-origin=\"off\">Angular libraries have this option to ensure that all Angular <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> files are clean and it is a best practice to do the same when building your own libraries.</p>\n</div>\n<a id=\"function-expression\"></a>\n<a id=\"arror-functions\"></a>\n<h3 translation-origin=\"off\" id=\"no-arrow-functions\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#no-arrow-functions\"><i class=\"material-icons\">link</i></a>No arrow functions</h3>\n<p translation-origin=\"off\">The AOT compiler does not support <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/function\">function expressions</a>\nand <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions\">arrow functions</a>, also called <em>lambda</em> functions.</p>\n<p translation-origin=\"off\">Consider the following component decorator:</p>\n<code-example language=\"ts\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: () => new Server()}]\n})\n</code-example>\n<p translation-origin=\"off\">The AOT <em>collector</em> does not support the arrow function, <code>() => new Server()</code>, in a metadata expression.\nIt generates an error node in place of the function.</p>\n<p translation-origin=\"off\">When the compiler later interprets this node, it reports an error that invites you to turn the arrow function into an <em>exported function</em>.</p>\n<p translation-origin=\"off\">You can fix the error by converting to this:</p>\n<code-example language=\"ts\">\nexport function serverFactory() {\n  return new Server();\n}\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [{provide: server, useFactory: serverFactory}]\n})\n</code-example>\n<p translation-origin=\"off\">Beginning in version 5, the compiler automatically performs this rewritting while emitting the <code>.js</code> file.</p>\n<h3 translation-origin=\"off\" id=\"limited-function-calls\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#limited-function-calls\"><i class=\"material-icons\">link</i></a>Limited function calls</h3>\n<p translation-origin=\"off\">The <em>collector</em> can represent a function call or object creation with <code>new</code> as long as the syntax is valid. The <em>collector</em> only cares about proper syntax.</p>\n<p translation-origin=\"off\">But beware. The compiler may later refuse to generate a call to a <em>particular</em> function or creation of a <em>particular</em> object.\nThe compiler only supports calls to a small set of functions and will use <code>new</code> for only a few designated classes. These functions and classes are in a table of <a href=\"guide/metadata#supported-functions\">below</a>.</p>\n<h3 translation-origin=\"off\" id=\"folding\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#folding\"><i class=\"material-icons\">link</i></a>Folding</h3>\n<a id=\"exported-symbols\"></a>\n<p translation-origin=\"off\">The compiler can only resolve references to <strong><em>exported</em></strong> symbols.\nFortunately, the <em>collector</em> enables limited use of non-exported symbols through <em>folding</em>.</p>\n<p translation-origin=\"off\">The <em>collector</em> may be able to evaluate an expression during collection and record the result in the <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> instead of the original expression.</p>\n<p translation-origin=\"off\">For example, the <em>collector</em> can evaluate the expression <code>1 + 2 + 3 + 4</code> and replace it with the result, <code>10</code>.</p>\n<p translation-origin=\"off\">This process is called <em>folding</em>. An expression that can be reduced in this manner is <em>foldable</em>.</p>\n<a id=\"var-declaration\"></a>\n<p translation-origin=\"off\">The collector can evaluate references to\nmodule-local <code>const</code> declarations and initialized <code>var</code> and <code>let</code> declarations, effectively removing them from the <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> file.</p>\n<p translation-origin=\"off\">Consider the following component definition:</p>\n<code-example language=\"ts\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">The compiler could not refer to the <code>template</code> constant because it isn't exported.</p>\n<p translation-origin=\"off\">But the <em>collector</em> can <em>fold</em> the <code>template</code> constant into the metadata definition by inlining its contents.\nThe effect is the same as if you had written:</p>\n<code-example language=\"TypeScript\">\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: '&#x3C;div>{{hero.name}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">There is no longer a reference to <code>template</code> and, therefore, nothing to trouble the compiler when it later interprets the <em>collector's</em> output in <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>.</p>\n<p translation-origin=\"off\">You can take this example a step further by including the <code>template</code> constant in another expression:</p>\n<code-example language=\"TypeScript\">\nconst template = '&#x3C;div>{{hero.name}}&#x3C;/div>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-hero',\n  template: template + '&#x3C;div>{{hero.title}}&#x3C;/div>'\n})\nexport class HeroComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n</code-example>\n<p translation-origin=\"off\">The <em>collector</em> reduces this expression to its equivalent <em>folded</em> string:</p>\n<p translation-origin=\"off\"><code>'&#x3C;div>{{hero.name}}&#x3C;/div>&#x3C;div>{{hero.title}}&#x3C;/div>'</code>.</p>\n<h4 translation-origin=\"off\" id=\"foldable-syntax\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#foldable-syntax\"><i class=\"material-icons\">link</i></a>Foldable syntax</h4>\n<p translation-origin=\"off\">The following table describes which expressions the <em>collector</em> can and cannot fold:</p>\n<table>\n<thead>\n<tr>\n<th>Syntax</th>\n<th>Foldable</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Literal object</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal array</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Spread in literal array</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Calls</td>\n<td>no</td>\n</tr>\n<tr>\n<td>New</td>\n<td>no</td>\n</tr>\n<tr>\n<td>Property access</td>\n<td>yes, if target is foldable</td>\n</tr>\n<tr>\n<td>Array index</td>\n<td>yes, if target and index are foldable</td>\n</tr>\n<tr>\n<td>Identifier reference</td>\n<td>yes, if it is a reference to a local</td>\n</tr>\n<tr>\n<td>A template with no substitutions</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>A template with substitutions</td>\n<td>yes, if the substitutions are foldable</td>\n</tr>\n<tr>\n<td>Literal string</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal number</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal boolean</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Literal null</td>\n<td>yes</td>\n</tr>\n<tr>\n<td>Supported prefix operator</td>\n<td>yes, if operand is foldable</td>\n</tr>\n<tr>\n<td>Supported binary operator</td>\n<td>yes, if both left and right are foldable</td>\n</tr>\n<tr>\n<td>Conditional operator</td>\n<td>yes, if condition is foldable</td>\n</tr>\n<tr>\n<td>Parentheses</td>\n<td>yes, if the expression is foldable</td>\n</tr>\n</tbody>\n</table>\n<p translation-origin=\"off\">If an expression is not foldable, the collector writes it to <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> as an <a href=\"https://en.wikipedia.org/wiki/Abstract_syntax_tree\">AST</a> for the compiler to resolve.</p>\n<h2 translation-origin=\"off\" id=\"phase-2-code-generation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#phase-2-code-generation\"><i class=\"material-icons\">link</i></a>Phase 2: code generation</h2>\n<p translation-origin=\"off\">The <em>collector</em> makes no attempt to understand the metadata that it collects and outputs to <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>. It represents the metadata as best it can and records errors when it detects a metadata syntax violation.</p>\n<p translation-origin=\"off\">It's the compiler's job to interpret the <code>.metadata.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> in the code generation phase.</p>\n<p translation-origin=\"off\">The compiler understands all syntax forms that the <em>collector</em> supports, but it may reject <em>syntactically</em> correct metadata if the <em>semantics</em> violate compiler rules.</p>\n<p translation-origin=\"off\">The compiler can only reference <em>exported symbols</em>.</p>\n<p translation-origin=\"off\">Decorated component class members must be public. You cannot make an <code>@<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>()</code> property private or internal.</p>\n<p translation-origin=\"off\">Data bound properties must also be public.</p>\n<code-example language=\"TypeScript\">\n// BAD CODE - title is private\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'app-root',\n  template: '&#x3C;h1>{{title}}&#x3C;/h1>'\n})\nexport class AppComponent {\n  private title = 'My App'; // Bad\n}\n</code-example>\n<a id=\"supported-functions\"></a>\n<p translation-origin=\"off\">Most importantly, the compiler only generates code to create instances of certain classes, support certain decorators, and call certain functions from the following lists.</p>\n<h3 translation-origin=\"off\" id=\"new-instances\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#new-instances\"><i class=\"material-icons\">link</i></a>New instances</h3>\n<p translation-origin=\"off\">The compiler only allows metadata that create instances of the class <code><a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a></code> from <code>@angular/core</code>.</p>\n<h3 translation-origin=\"off\" id=\"annotationsdecorators\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#annotationsdecorators\"><i class=\"material-icons\">link</i></a>Annotations/Decorators</h3>\n<p translation-origin=\"off\">The compiler only supports metadata for these Angular decorators.</p>\n<table>\n<thead>\n<tr>\n<th>Decorator</th>\n<th>Module</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code><a href=\"api/core/Attribute\" class=\"code-anchor\">Attribute</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChild\" class=\"code-anchor\">ContentChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ContentChildren\" class=\"code-anchor\">ContentChildren</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Host\" class=\"code-anchor\">Host</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostBinding\" class=\"code-anchor\">HostBinding</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/HostListener\" class=\"code-anchor\">HostListener</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Input\" class=\"code-anchor\">Input</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Output\" class=\"code-anchor\">Output</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/Self\" class=\"code-anchor\">Self</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/SkipSelf\" class=\"code-anchor\">SkipSelf</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n<tr>\n<td><code><a href=\"api/core/ViewChild\" class=\"code-anchor\">ViewChild</a></code></td>\n<td><code>@angular/core</code></td>\n</tr>\n</tbody>\n</table>\n<h3 translation-origin=\"off\" id=\"macro-functions-and-macro-static-methods\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#macro-functions-and-macro-static-methods\"><i class=\"material-icons\">link</i></a>Macro-functions and macro-static methods</h3>\n<p translation-origin=\"off\">The compiler also supports <em>macros</em> in the form of functions or static\nmethods that return an expression.</p>\n<p translation-origin=\"off\">For example, consider the following function:</p>\n<code-example language=\"TypeScript\">\nexport function wrapInArray&#x3C;T>(value: T): T[] {\n  return [value];\n}\n</code-example>\n<p translation-origin=\"off\">You can call the <code>wrapInArray</code> in a metadata definition because it returns the value of an expression that conforms to the compiler's restrictive JavaScript subset.</p>\n<p translation-origin=\"off\">You might use  <code>wrapInArray()</code> like this:</p>\n<code-example language=\"TypeScript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: wrapInArray(TypicalComponent)\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">The compiler treats this usage as if you had written:</p>\n<code-example language=\"TypeScript\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  declarations: [TypicalComponent]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">The collector is simplistic in its determination of what qualifies as a macro\nfunction; it can only contain a single <code>return</code> statement.</p>\n<p translation-origin=\"off\">The Angular <a href=\"api/router/RouterModule\"><code>RouterModule</code></a> exports two macro static methods, <code>forRoot</code> and <code>forChild</code>, to help declare root and child routes.\nReview the <a href=\"https://github.com/angular/angular/blob/master/packages/router/src/router_module.ts#L139\" title=\"RouterModule.forRoot source code\">source code</a>\nfor these methods to see how macros can simplify configuration of complex Angular modules.</p>\n<h3 translation-origin=\"off\" id=\"metadata-rewriting\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#metadata-rewriting\"><i class=\"material-icons\">link</i></a>Metadata rewriting</h3>\n<p translation-origin=\"off\">The compiler treats object literals containing the fields <code>useClass</code>, <code>useValue</code>, <code>useFactory</code>, and <code>data</code> specially. The compiler converts the expression initializing one of these fields into an exported variable, which replaces the expression. This process of rewriting these expressions removes all the restrictions on what can be in them because\nthe compiler doesn't need to know the expression's value—it just needs to be able to generate a reference to the value.</p>\n<p translation-origin=\"off\">You might write something like:</p>\n<code-example language=\"ts\">\nclass TypicalServer {\n\n}\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: () => TypicalServer}]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">Without rewriting, this would be invalid because lambdas are not supported and <code>TypicalServer</code> is not exported.</p>\n<p translation-origin=\"off\">To allow this, the compiler automatically rewrites this to something like:</p>\n<code-example language=\"ts\">\nclass TypicalServer {\n\n}\n\nexport const ɵ0 = () => new TypicalServer();\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  providers: [{provide: SERVER, useFactory: ɵ0}]\n})\nexport class TypicalModule {}\n</code-example>\n<p translation-origin=\"off\">This allows the compiler to generate a reference to <code>ɵ0</code> in the\nfactory without having to know what the value of <code>ɵ0</code> contains.</p>\n<p translation-origin=\"off\">The compiler does the rewriting during the emit of the <code>.js</code> file. This doesn't rewrite the <code>.d.ts</code> file, however, so TypeScript doesn't recognize it as being an export. Thus, it does not pollute the ES module's exported API.</p>\n<h2 translation-origin=\"off\" id=\"metadata-errors\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#metadata-errors\"><i class=\"material-icons\">link</i></a>Metadata Errors</h2>\n<p translation-origin=\"off\">The following are metadata errors you may encounter, with explanations and suggested corrections.</p>\n<p translation-origin=\"off\"><a href=\"guide/metadata#expression-form-not-supported\">Expression form not supported</a><br>\n<a href=\"guide/metadata#reference-to-a-local-symbol\">Reference to a local (non-exported) symbol</a><br>\n<a href=\"guide/metadata#only-initialized-variables\">Only initialized variables and constants</a><br>\n<a href=\"guide/metadata#reference-to-a-non-exported-class\">Reference to a non-exported class</a><br>\n<a href=\"guide/metadata#reference-to-a-non-exported-function\">Reference to a non-exported function</a><br>\n<a href=\"guide/metadata#function-calls-not-supported\">Function calls are not supported</a><br>\n<a href=\"guide/metadata#destructured-variable-not-supported\">Destructured variable or constant not supported</a><br>\n<a href=\"guide/metadata#could-not-resolve-type\">Could not resolve type</a><br>\n<a href=\"guide/metadata#name-expected\">Name expected</a><br>\n<a href=\"guide/metadata#unsupported-enum-member-name\">Unsupported enum member name</a><br>\n<a href=\"guide/metadata#tagged-template-expressions-not-supported\">Tagged template expressions are not supported</a><br>\n<a href=\"guide/metadata#symbol-reference-expected\">Symbol reference expected</a><br></p>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"expression-form-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#expression-form-not-supported\"><i class=\"material-icons\">link</i></a>Expression form not supported</h3>\n<p translation-origin=\"off\">The compiler encountered an expression it didn't understand while evalutating Angular metadata.</p>\n<p translation-origin=\"off\">Language features outside of the compiler's <a href=\"guide/metadata#expression-syntax\">restricted expression syntax</a>\ncan produce this error, as seen in the following example:</p>\n<code-example>\n// ERROR\nexport class Fooish { ... }\n...\nconst prop = typeof Fooish; // typeof is not valid in metadata\n  ...\n  // bracket notation is not valid in metadata\n  { provide: 'token', useValue: { [prop]: 'value' } };\n  ...\n</code-example>\n<p translation-origin=\"off\">You can use <code>typeof</code> and bracket notation in normal application code.\nYou just can't use those features within expressions that define Angular metadata.</p>\n<p translation-origin=\"off\">Avoid this error by sticking to the compiler's <a href=\"guide/metadata#expression-syntax\">restricted expression syntax</a>\nwhen writing Angular metadata\nand be wary of new or unusual TypeScript features.</p>\n<hr>\n<a id=\"reference-to-a-local-symbol\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-local-non-exported-symbol\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#reference-to-a-local-non-exported-symbol\"><i class=\"material-icons\">link</i></a>Reference to a local (non-exported) symbol</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Reference to a local (non-exported) symbol 'symbol name'. Consider exporting the symbol.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler encountered a referenced to a locally defined symbol that either wasn't exported or wasn't initialized.</p>\n<p translation-origin=\"off\">Here's a <code>provider</code> example of the problem.</p>\n<code-example>\n// ERROR\nlet foo: number; // neither exported nor initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler generates the component factory, which includes the <code>useValue</code> provider code, in a separate module. <em>That</em> factory module can't reach back to <em>this</em> source module to access the local (non-exported) <code>foo</code> variable.</p>\n<p translation-origin=\"off\">You could fix the problem by initializing <code>foo</code>.</p>\n<code-example>\nlet foo = 42; // initialized\n</code-example>\n<p translation-origin=\"off\">The compiler will <a href=\"guide/metadata#folding\">fold</a> the expression into the provider as if you had written this.</p>\n<code-example>\n  providers: [\n    { provide: Foo, useValue: 42 }\n  ]\n</code-example>\n<p translation-origin=\"off\">Alternatively, you can fix it by exporting <code>foo</code> with the expectation that <code>foo</code> will be assigned at runtime when you actually know its value.</p>\n<code-example>\n// CORRECTED\nexport let foo: number; // exported\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: ... ,\n  providers: [\n    { provide: Foo, useValue: foo }\n  ]\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">Adding <code>export</code> often works for variables referenced in metadata such as <code>providers</code> and <code>animations</code> because the compiler can generate <em>references</em> to the exported variables in these expressions. It doesn't need the <em>values</em> of those variables.</p>\n<p translation-origin=\"off\">Adding <code>export</code> doesn't work when the compiler needs the <em>actual value</em>\nin order to generate code.\nFor example, it doesn't work for the <code>template</code> property.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string; // exported but not initialized\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler needs the value of the <code>template</code> property <em>right now</em> to generate the component factory.\nThe variable reference alone is insufficient.\nPrefixing the declaration with <code>export</code> merely produces a new error, \"<a href=\"guide/metadata#only-initialized-variables\"><code>Only initialized variables and constants can be referenced</code></a>\".</p>\n<hr>\n<a id=\"only-initialized-variables\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"only-initialized-variables-and-constants\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#only-initialized-variables-and-constants\"><i class=\"material-icons\">link</i></a>Only initialized variables and constants</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Only initialized variables and constants can be referenced because the value of this variable is needed by the template compiler.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler found a reference to an exported variable or static field that wasn't initialized.\nIt needs the value of that variable to generate code.</p>\n<p translation-origin=\"off\">The following example tries to set the component's <code>template</code> property to the value of\nthe exported <code>someTemplate</code> variable which is declared but <em>unassigned</em>.</p>\n<code-example>\n// ERROR\nexport let someTemplate: string;\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">You'd also get this error if you imported <code>someTemplate</code> from some other module and neglected to initialize it there.</p>\n<code-example>\n// ERROR - not initialized there either\nimport { someTemplate } from './config';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<p translation-origin=\"off\">The compiler cannot wait until runtime to get the template information.\nIt must statically derive the value of the <code>someTemplate</code> variable from the source code\nso that it can generate the component factory, which includes\ninstructions for building the element based on the template.</p>\n<p translation-origin=\"off\">To correct this error, provide the initial value of the variable in an initializer clause <em>on the same line</em>.</p>\n<code-example>\n// CORRECTED\nexport let someTemplate = '&#x3C;h1>Greetings from Angular&#x3C;/h1>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-component',\n  template: someTemplate\n})\nexport class MyComponent {}\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-non-exported-class\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#reference-to-a-non-exported-class\"><i class=\"material-icons\">link</i></a>Reference to a non-exported class</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Reference to a non-exported class <class name=\"\">. Consider exporting the class.</class></em></p>\n</div>\n<p translation-origin=\"off\">Metadata referenced a class that wasn't exported.</p>\n<p translation-origin=\"off\">For example, you may have defined a class and used it as an injection token in a providers array\nbut neglected to export that class.</p>\n<code-example>\n// ERROR\nabstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/metadata#exported-symbols\">can only access exported classes</a>.\nTo correct this error, export the referenced class.</p>\n<code-example>\n// CORRECTED\nexport abstract class MyStrategy { }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useValue: ... }\n  ]\n  ...\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"reference-to-a-non-exported-function\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#reference-to-a-non-exported-function\"><i class=\"material-icons\">link</i></a>Reference to a non-exported function</h3>\n<p translation-origin=\"off\">Metadata referenced a function that wasn't exported.</p>\n<p translation-origin=\"off\">For example, you may have set a providers <code>useFactory</code> property to a locally defined function that you neglected to export.</p>\n<code-example>\n// ERROR\nfunction myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">Angular generates a class factory in a separate module and that\nfactory <a href=\"guide/metadata#exported-symbols\">can only access exported functions</a>.\nTo correct this error, export the function.</p>\n<code-example>\n// CORRECTED\nexport function myStrategy() { ... }\n\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"function-calls-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"function-calls-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#function-calls-are-not-supported\"><i class=\"material-icons\">link</i></a>Function calls are not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Function calls are not supported. Consider replacing the function or lambda with a reference to an exported function.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler does not currently support <a href=\"guide/metadata#function-expression\">function expressions or lambda functions</a>.\nFor example, you cannot set a provider's <code>useFactory</code> to an anonymous function or arrow function like this.</p>\n<code-example>\n// ERROR\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: function() { ... } },\n    { provide: OtherStrategy, useFactory: () => { ... } }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">You also get this error if you call a function or method in a provider's <code>useValue</code>.</p>\n<code-example>\n// ERROR\nimport { calculateValue } from './utilities';\n\n  ...\n  providers: [\n    { provide: SomeValue, useValue: calculateValue() }\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">To correct this error, export a function from the module and refer to the function in a <code>useFactory</code> provider instead.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { calculateValue } from './utilities';\n\nexport function myStrategy() { ... }\nexport function otherStrategy() { ... }\nexport function someValueFactory() {\n  return calculateValue();\n}\n  ...\n  providers: [\n    { provide: MyStrategy, useFactory: myStrategy },\n    { provide: OtherStrategy, useFactory: otherStrategy },\n    { provide: SomeValue, useFactory: someValueFactory }\n  ]\n  ...\n</code-example>\n<hr>\n<a id=\"destructured-variable-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"destructured-variable-or-constant-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#destructured-variable-or-constant-not-supported\"><i class=\"material-icons\">link</i></a>Destructured variable or constant not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Referencing an exported destructured variable or constant is not supported by the template compiler. Consider simplifying this to avoid destructuring.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler does not support references to variables assigned by <a href=\"https://www.typescriptlang.org/docs/handbook/variable-declarations.html#destructuring\">destructuring</a>.</p>\n<p translation-origin=\"off\">For example, you cannot write something like this:</p>\n<code-example linenums=\"false\">\n// ERROR\nimport { configuration } from './configuration';\n\n// destructured assignment to foo and bar\nconst {foo, bar} = configuration;\n  ...\n  providers: [\n    {provide: Foo, useValue: foo},\n    {provide: Bar, useValue: bar},\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">To correct this error, refer to non-destructured values.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { configuration } from './configuration';\n  ...\n  providers: [\n    {provide: Foo, useValue: configuration.foo},\n    {provide: Bar, useValue: configuration.bar},\n  ]\n  ...\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"could-not-resolve-type\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#could-not-resolve-type\"><i class=\"material-icons\">link</i></a>Could not resolve type</h3>\n<p translation-origin=\"off\">The compiler encountered a type and can't determine which module exports that type.</p>\n<p translation-origin=\"off\">This can happen if you refer to an ambient type.\nFor example, the <code>Window</code> type is an ambiant type declared in the global <code>.d.ts</code> file.</p>\n<p translation-origin=\"off\">You'll get an error if you reference it in the component constructor,\nwhich the compiler must statically analyze.</p>\n<code-example>\n// ERROR\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ })\nexport class MyComponent {\n  constructor (private win: Window) { ... }\n}\n</code-example>\n<p translation-origin=\"off\">TypeScript understands ambiant types so you don't import them.\nThe Angular compiler does not understand a type that you neglect to export or import.</p>\n<p translation-origin=\"off\">In this case, the compiler doesn't understand how to inject something with the <code>Window</code> token.</p>\n<p translation-origin=\"off\">Do not refer to ambient types in metadata expressions.</p>\n<p translation-origin=\"off\">If you must inject an instance of an ambiant type,\nyou can finesse the problem in four steps:</p>\n<ol>\n<li>Create an injection token for an instance of the ambiant type.</li>\n<li>Create a factory function that returns that instance.</li>\n<li>Add a <code>useFactory</code> provider with that factory function.</li>\n<li>Use <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code> to inject the instance.</li>\n</ol>\n<p translation-origin=\"off\">Here's an illustrative example.</p>\n<code-example linenums=\"false\">\n// CORRECTED\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> } from '@angular/core';\n\nexport const WINDOW = new <a href=\"api/core/InjectionToken\" class=\"code-anchor\">InjectionToken</a>('Window');\nexport function _window() { return window; }\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  ...\n  providers: [\n    { provide: WINDOW, useFactory: _window }\n  ]\n})\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW) private win: Window) { ... }\n}\n</code-example>\n<p translation-origin=\"off\">The <code>Window</code> type in the constructor is no longer a problem for the compiler because it\nuses the <code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(WINDOW)</code> to generate the injection code.</p>\n<p translation-origin=\"off\">Angular does something similar with the <code>DOCUMENT</code> token so you can inject the browser's <code>document</code> object (or an abstraction of it, depending upon the platform in which the application runs).</p>\n<code-example linenums=\"false\">\nimport { <a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a> }   from '@angular/core';\nimport { DOCUMENT } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({ ... })\nexport class MyComponent {\n  constructor (@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a>(DOCUMENT) private doc: Document) { ... }\n}\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"name-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#name-expected\"><i class=\"material-icons\">link</i></a>Name expected</h3>\n<p translation-origin=\"off\">The compiler expected a name in an expression it was evaluating.\nThis can happen if you use a number as a property name as in the following example.</p>\n<code-example>\n// ERROR\nprovider: [{ provide: Foo, useValue: { 0: 'test' } }]\n</code-example>\n<p translation-origin=\"off\">Change the name of the property to something non-numeric.</p>\n<code-example>\n// CORRECTED\nprovider: [{ provide: Foo, useValue: { '0': 'test' } }]\n</code-example>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"unsupported-enum-member-name\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#unsupported-enum-member-name\"><i class=\"material-icons\">link</i></a>Unsupported enum member name</h3>\n<p translation-origin=\"off\">Angular couldn't determine the value of the <a href=\"https://www.typescriptlang.org/docs/handbook/enums.html\">enum member</a>\nthat you referenced in metadata.</p>\n<p translation-origin=\"off\">The compiler can understand simple enum values but not complex values such as those derived from computed properties.</p>\n<code-example linenums=\"false\">\n// ERROR\nenum Colors {\n  Red = 1,\n  White,\n  Blue = \"Blue\".length // computed\n}\n\n  ...\n  providers: [\n    { provide: BaseColor,   useValue: Colors.White } // ok\n    { provide: DangerColor, useValue: Colors.Red }   // ok\n    { provide: StrongColor, useValue: Colors.Blue }  // bad\n  ]\n  ...\n</code-example>\n<p translation-origin=\"off\">Avoid referring to enums with complicated initializers or computed properties.</p>\n<hr>\n<a id=\"tagged-template-expressions-not-supported\"></a>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"tagged-template-expressions-are-not-supported\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#tagged-template-expressions-are-not-supported\"><i class=\"material-icons\">link</i></a>Tagged template expressions are not supported</h3>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\"><em>Tagged template expressions are not supported in metadata.</em></p>\n</div>\n<p translation-origin=\"off\">The compiler encountered a JavaScript ES2015 <a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals#Tagged_template_literals\">tagged template expression</a> such as,</p>\n<code-example>\n// ERROR\nconst expression = 'funky';\nconst raw = String.raw`A tagged template ${expression} string`;\n ...\n template: '&#x3C;div>' + raw + '&#x3C;/div>'\n ...\n</code-example>\n<p translation-origin=\"off\"><a href=\"https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/raw\"><code>String.raw()</code></a>\nis a <em>tag function</em> native to JavaScript ES2015.</p>\n<p translation-origin=\"off\">The AOT compiler does not support tagged template expressions; avoid them in metadata expressions.</p>\n<hr>\n<h3 translation-origin=\"off\" class=\"no-toc\" id=\"symbol-reference-expected\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#symbol-reference-expected\"><i class=\"material-icons\">link</i></a>Symbol reference expected</h3>\n<p translation-origin=\"off\">The compiler expected a reference to a symbol at the location specified in the error message.</p>\n<p translation-origin=\"off\">This error can occur if you use an expression in the <code>extends</code> clause of a class.</p>\n<!--\n\nChuck: After reviewing your PR comment I'm still at a loss. See [comment there](https://github.com/angular/angular/pull/17712#discussion_r132025495).\n\n-->\n<h2 translation-origin=\"off\" id=\"conclusion\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/metadata#conclusion\"><i class=\"material-icons\">link</i></a>Conclusion</h2>\n<p translation-origin=\"off\">This page covered:</p>\n<ul>\n<li>What the AOT compiler does.</li>\n<li>Why metadata must be written in a subset of JavaScript.</li>\n<li>What that subset is.</li>\n<li>Other restrictions on metadata definition.</li>\n<li>Macro-functions and macro-static methods.</li>\n<li>Compiler errors related to metadata.</li>\n</ul>\n\n</div>"
}