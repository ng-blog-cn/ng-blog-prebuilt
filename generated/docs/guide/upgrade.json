{
  "id": "guide/upgrade",
  "title": "从 AngularJS 升级",
  "contents": "\n<div class=\"content\">\n<h1 translation-origin=\"off\" id=\"upgrading-from-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-from-angularjs\"><i class=\"material-icons\">link</i></a>Upgrading from AngularJS</h1>\n<h1 translation-result=\"\" id=\"从-angularjs-升级\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#从-angularjs-升级\"><i class=\"material-icons\">link</i></a>从 AngularJS 升级</h1>\n<p translation-origin=\"off\"><em>Angular</em> is the name for the Angular of today and tomorrow.\n<em>AngularJS</em> is the name for all v1.x versions of Angular.</p>\n<p translation-result=\"\"><em>Angular</em>这个名字专指现在和未来的Angular版本，而<em>AngularJS</em>专指Angular的所有v1.x版本。</p>\n<p translation-origin=\"off\">AngularJS apps are great.\nAlways consider the business case before moving to Angular.\nAn important part of that case is the time and effort to get there.\nThis guide describes the built-in tools for efficiently migrating AngularJS projects over to the\nAngular platform, a piece at a time.</p>\n<p translation-result=\"\">有很多大型AngularJS应用。\n在决定迁移到Angular之前，首先要深入思考业务案例。\n在这些案例中，最重要的部分之一是时间和需要付出的努力。\n本章描述用于把AngularJS应用高效迁移到Angular平台的内置工具，每次讲一点点。</p>\n<p translation-origin=\"off\">Some applications will be easier to upgrade than others, and there are\nmany ways to make it easier for yourself. It is possible to\nprepare and align AngularJS applications with Angular even before beginning\nthe upgrade process. These preparation steps are all about making the code\nmore decoupled, more maintainable, and better aligned with modern development\ntools. That means in addition to making the upgrade easier,\nyou will also improve the existing AngularJS applications.</p>\n<p translation-result=\"\">有些应用可能比其它的升级起来简单，还有一些方法能让把这项工作变得更简单。\n即使在正式开始升级过程之前，我们可以准备AngularJS的程序，让它向Angular看齐。\n这些准备步骤几乎都是关于如何让代码更加松耦合、更有可维护性，以及用现代开发工具提高速度的。\n这意味着，这种准备工作不仅能让最终的升级变得更简单，而且还能提升AngularJS程序的质量。</p>\n<p translation-origin=\"off\">One of the keys to a successful upgrade is to do it incrementally,\nby running the two frameworks side by side in the same application, and\nporting AngularJS components to Angular one by one. This makes it possible\nto upgrade even large and complex applications without disrupting other\nbusiness, because the work can be done collaboratively and spread over\na period of time. The <code>upgrade</code> module in Angular has been designed to\nmake incremental upgrading seamless.</p>\n<p translation-result=\"\">成功升级的关键之一是增量式的实现它，通过在同一个应用中一起运行这两个框架，并且逐个把AngularJS的组件迁移到Angular中。\n这意味着可以在不必打断其它业务的前提下，升级更大、更复杂的应用程序，因为这项工作可以多人协作完成，在一段时间内逐渐铺开。\nAngular <code>upgrade</code>模块的设计目标就是让你渐进、无缝的完成升级。</p>\n<h2 translation-origin=\"off\" id=\"preparation\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#preparation\"><i class=\"material-icons\">link</i></a>Preparation</h2>\n<h2 translation-result=\"\" id=\"准备工作\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#准备工作\"><i class=\"material-icons\">link</i></a>准备工作</h2>\n<p translation-origin=\"off\">There are many ways to structure AngularJS applications. When you begin\nto upgrade these applications to Angular, some will turn out to be\nmuch more easy to work with than others. There are a few key techniques\nand patterns that you can apply to future proof apps even before you\nbegin the migration.</p>\n<p translation-result=\"\">AngularJS应用程序的组织方式有很多种。当我们想把它们升级到Angular的时候，\n有些做起来会比其它的更容易些。即使在我们开始升级之前，也有一些关键的技术和模式可以让我们将来升级时更轻松。</p>\n<a id=\"follow-the-angular-styleguide\"></a>\n<h3 translation-origin=\"off\" id=\"follow-the-angularjs-style-guide\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#follow-the-angularjs-style-guide\"><i class=\"material-icons\">link</i></a>Follow the AngularJS Style Guide</h3>\n<h3 translation-result=\"\" id=\"遵循angular风格指南\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#遵循angular风格指南\"><i class=\"material-icons\">link</i></a>遵循Angular风格指南</h3>\n<p translation-origin=\"off\">The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS Style Guide</a>\ncollects patterns and practices that have been proven to result in\ncleaner and more maintainable AngularJS applications. It contains a wealth\nof information about how to write and organize AngularJS code - and equally\nimportantly - how <strong>not</strong> to write and organize AngularJS code.</p>\n<p translation-result=\"\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">Angular风格指南</a>收集了一些已证明能写出干净且可维护的AngularJS程序的模式与实践。\n它包含了很多关于如何书写和组织Angular代码的有价值信息，同样重要的是，<strong>不应该</strong>采用的书写和组织Angular代码的方式。</p>\n<p translation-origin=\"off\">Angular is a reimagined version of the best parts of AngularJS. In that\nsense, its goals are the same as the AngularJS Style Guide's: To preserve\nthe good parts of AngularJS, and to avoid the bad parts. There's a lot\nmore to Angular than just that of course, but this does mean that\n<em>following the style guide helps make your AngularJS app more closely\naligned with Angular</em>.</p>\n<p translation-result=\"\">Angular是一个基于AngularJS中最好的部分构思出来的版本。在这种意义上，它的目标和Angular风格指南是一样的：\n保留AngularJS中好的部分，去掉坏的部分。当然，Angular还做了更多。\n说这些的意思是：<em>遵循这个风格指南可以让你写出更接近Angular程序的AngularJS程序</em>。</p>\n<p translation-origin=\"off\">There are a few rules in particular that will make it much easier to do <em>an incremental upgrade</em> using the Angular <code><a href=\"api/upgrade/static\" class=\"code-anchor\">upgrade/static</a></code> module:</p>\n<p translation-result=\"\">有一些特别的规则可以让使用Angular的<code>upgrade</code>模块进行<em>增量升级</em>变得更简单：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">Rule of 1</a>\nstates that there should be one component per file. This not only makes\ncomponents easy to navigate and find, but will also allow us to migrate\nthem between languages and frameworks one at a time. In this example application,\neach controller, component, service, and filter is in its own source file.</p>\n<p translation-result=\"\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">单一规则</a>\n规定每个文件应该只放一个组件。这不仅让组件更容易浏览和查找，而且还将允许我们逐个迁移它们的语言和框架。\n在这个范例程序中，每个控制器、工厂和过滤器都在它自己的源文件中。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">Folders-by-Feature Structure</a>\nand <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">Modularity</a>\nrules define similar principles on a higher level of abstraction: Different parts of the\napplication should reside in different directories and NgModules.</p>\n<p translation-result=\"\"><a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">按特性分目录的结构</a>和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">模块化</a>规则在较高的抽象层定义了一些相似的原则：应用程序中的不同部分应该被分到不同的目录和Angular模块中。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">When an application is laid out feature per feature in this way, it can also be\nmigrated one feature at a time. For applications that don't already look like\nthis, applying the rules in the AngularJS style guide is a highly recommended\npreparation step. And this is not just for the sake of the upgrade - it is just\nsolid advice in general!</p>\n<p translation-result=\"\">如果应用程序能用这种方式把每个特性分到一个独立目录中，它也就能每次迁移一个特性。\n对于那些还没有这么做的程序，强烈建议把应用这条规则作为准备步骤。而且这也不仅仅对升级有价值，\n它还是一个通用的规则，可以让你的程序更“坚实”。</p>\n<h3 translation-origin=\"off\" id=\"using-a-module-loader\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-a-module-loader\"><i class=\"material-icons\">link</i></a>Using a Module Loader</h3>\n<h3 translation-result=\"\" id=\"使用模块加载器\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用模块加载器\"><i class=\"material-icons\">link</i></a>使用模块加载器</h3>\n<p translation-origin=\"off\">When you break application code down into one component per file, you often end\nup with a project structure with a large number of relatively small files. This is\na much neater way to organize things than a small number of large files, but it\ndoesn't work that well if you have to load all those files to the HTML page with\n&#x3C;script> tags. Especially when you also have to maintain those tags in the correct\norder. That's why it's a good idea to start using a <em>module loader</em>.</p>\n<p translation-result=\"\">当我们把应用代码分解成每个文件中放一个组件之后，我们通常会得到一个由大量相对较小的文件组成的项目结构。\n这比组织成少量大文件要整洁得多，但如果你不得不通过<code>&#x3C;script></code>标签在HTML页面中加载所有这些文件，那就不好玩了。\n尤其是当你不得不按正确的顺序维护这些标签时更是如此。\n这就是为什么开始使用<em>模块加载器</em>是一个好主意了。</p>\n<p translation-origin=\"off\">Using a module loader such as <a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>,\n<a href=\"http://webpack.github.io/\">Webpack</a>, or <a href=\"http://browserify.org/\">Browserify</a>\nallows us to use the built-in module systems of TypeScript or ES2015.\nYou can use the <code>import</code> and <code>export</code> features that explicitly specify what code can\nand will be shared between different parts of the application. For ES5 applications\nyou can use CommonJS style <code>require</code> and <code>module.exports</code> features. In both cases,\nthe module loader will then take care of loading all the code the application needs\nin the correct order.</p>\n<p translation-result=\"\">使用模块加载器，比如<a href=\"https://github.com/systemjs/systemjs\">SystemJS</a>、\n<a href=\"http://webpack.github.io/\">Webpack</a>或<a href=\"http://browserify.org/\">Browserify</a>，\n可以让我们在程序中使用TypeScript或ES2015语言内置的模块系统。\n我们可以使用<code>import</code>和<code>export</code>特性来明确指定哪些代码应该以及将会被在程序的不同部分之间共享。\n对于ES5程序来说，我们可以改用CommonJS风格的<code>require</code>和<code>module.exports</code>特性代替。\n无是论哪种情况，模块加载器都会按正确的顺序加载程序中用到的所有代码。</p>\n<p translation-origin=\"off\">When moving applications into production, module loaders also make it easier\nto package them all up into production bundles with batteries included.</p>\n<p translation-result=\"\">当我们的应用程序投入生产环境时，模块加载器也会让把所有这些文件打成完整的产品包变得更容易。</p>\n<h3 translation-origin=\"off\" id=\"migrating-to-typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#migrating-to-typescript\"><i class=\"material-icons\">link</i></a>Migrating to TypeScript</h3>\n<h3 translation-result=\"\" id=\"迁移到typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#迁移到typescript\"><i class=\"material-icons\">link</i></a>迁移到TypeScript</h3>\n<p translation-origin=\"off\">If part of the Angular upgrade plan is to also take TypeScript into use, it makes\nsense to bring in the TypeScript compiler even before the upgrade itself begins.\nThis means there's one less thing to learn and think about during the actual upgrade.\nIt also means you can start using TypeScript features in your AngularJS code.</p>\n<p translation-result=\"\">Angular升级计划的一部分是引入TypeScript，即使在开始升级之前，引入TypeScript编译器也是有意义的。\n这意味着等真正升级的时候需要学习和思考的东西更少。\n它还意味着我们可以在AngularJS代码中开始使用TypeScript的特性。</p>\n<p translation-origin=\"off\">Since TypeScript is a superset of ECMAScript 2015, which in turn is a superset\nof ECMAScript 5, \"switching\" to TypeScript doesn't necessarily require anything\nmore than installing the TypeScript compiler and renaming files from\n<code>*.js</code> to <code>*.ts</code>. But just doing that is not hugely useful or exciting, of course.\nAdditional steps like the following can give us much more bang for the buck:</p>\n<p translation-result=\"\">因为TypeScript是ECMAScript 2015的一个超集，而ES2015又是ECMAScript 5的一个超集。\n这意味着除了安装一个TypeScript编译器，并把文件名都从<code>*.js</code>改成<code>*.ts</code>之外，其实什么都不用做。\n当然，如果仅仅这样做也没什么大用，也没什么令人兴奋之处。\n下面这些额外步骤可以让我们精神抖擞起来：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">For applications that use a module loader, TypeScript imports and exports\n(which are really ECMAScript 2015 imports and exports) can be used to organize\ncode into modules.</p>\n<p translation-result=\"\">对那些使用了模块加载器的程序，TypeScript的导入和导出(这实际上是ECMAScript 2015导入和导出)可以把代码组织到模块中。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Type annotations can be gradually added to existing functions and variables\nto pin down their types and get benefits like build-time error checking,\ngreat autocompletion support and inline documentation.</p>\n<p translation-result=\"\">类型注解可以逐步添加到已存在的函数和变量上，以固定它们的类型，并获得其优点：比如编译期错误检查、更好的支持自动完成，以及内联式文档等。</p>\n</li>\n<li>\n<p translation-origin=\"off\">JavaScript features new to ES2015, like arrow functions, <code>let</code>s and <code>const</code>s,\ndefault function parameters, and destructuring assignments can also be gradually\nadded to make the code more expressive.</p>\n<p translation-result=\"\">那些ES2015中新增的特性，比如箭头函数、<code>let</code>、<code>const</code>、默认函数参数、解构赋值等也能逐渐添加进来，让代码更有表现力。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Services and controllers can be turned into <em>classes</em>. That way they'll be a step\ncloser to becoming Angular service and component classes, which will make\nlife easier after the upgrade.</p>\n<p translation-result=\"\">服务和控制器可以转成<em>类</em>。这样我们就能一步步接近Angular的服务和组件类了，这样等到我们开始升级时，也会更简单。</p>\n</li>\n</ul>\n<h4 translation-origin=\"off\" id=\"using-component-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-component-directives\"><i class=\"material-icons\">link</i></a>Using Component Directives</h4>\n<h4 translation-result=\"\" id=\"使用组件型指令\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用组件型指令\"><i class=\"material-icons\">link</i></a>使用组件型指令</h4>\n<p translation-origin=\"off\">In Angular, components are the main primitive from which user interfaces\nare built. You define the different portions of the UI as components and\ncompose them into a full user experience.</p>\n<p translation-result=\"\">在Angular中，组件是用来构建用户界面的主要元素。我们把UI中的不同部分定义成组件，然后通过在模板中使用这些组件最终合成为UI。</p>\n<p translation-origin=\"off\">You can also do this in AngularJS, using <em>component directives</em>. These are\ndirectives that define their own templates, controllers, and input/output bindings -\nthe same things that Angular components define. Applications built with\ncomponent directives are much easier to migrate to Angular than applications\nbuilt with lower-level features like <code>ng-controller</code>,  <code>ng-include</code>, and scope\ninheritance.</p>\n<p translation-result=\"\">我们在AngularJS中也能这么做。那就是一种定义了自己的模板、控制器和输入/输出绑定的指令 —— 跟Angular中对组件的定义是一样的。\n要迁移到Angular，通过组件型指令构建的应用程序会比直接用<code>ng-controller</code>、<code>ng-include</code>和作用域继承等底层特性构建的要容易得多。</p>\n<p translation-origin=\"off\">To be Angular compatible, an AngularJS component directive should configure\nthese attributes:</p>\n<p translation-result=\"\">要与Angular兼容，AngularJS的组件型指令应该配置下列属性：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>restrict: 'E'</code>. Components are usually used as elements.</p>\n<p translation-result=\"\"><code>restrict: 'E'</code>。组件通常会以元素的方式使用。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>scope: {}</code> - an isolate scope. In Angular, components are always isolated\nfrom their surroundings, and you should do this in AngularJS too.</p>\n<p translation-result=\"\"><code>scope: {}</code> - 一个独立作用域。在Angular中，组件永远是从它们的环境中被隔离出来的，在AngularJS中，我们也应该这么做。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>bindToController: {}</code>. Component inputs and outputs should be bound\nto the controller instead of using the <code>$scope</code>.</p>\n<p translation-result=\"\"><code>bindToController: {}</code>。组件的输入和输出应该绑定到控制器，而不是<code>$scope</code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>controller</code> and <code>controllerAs</code>. Components have their own controllers.</p>\n<p translation-result=\"\"><code>controller</code>和<code>controllerAs</code>。组件有它们自己的控制器。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>template</code> or <code>templateUrl</code>. Components have their own templates.</p>\n<p translation-result=\"\"><code>template</code>或<code>templateUrl</code>。组件有它们自己的模板。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Component directives may also use the following attributes:</p>\n<p translation-result=\"\">组件型指令还可能使用下列属性：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>transclude: true/{}</code>, if the component needs to transclude content from elsewhere.</p>\n<p translation-result=\"\"><code>transclude: true</code>：如果组件需要从其它地方透传内容，就设置它。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>require</code>, if the component needs to communicate with some parent component's\ncontroller.</p>\n<p translation-result=\"\"><code>require</code>：如果组件需要和父组件的控制器通讯，就设置它。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Component directives <strong>should not</strong> use the following attributes:</p>\n<p translation-result=\"\">组件型指令<strong>不能</strong>使用下列属性：</p>\n<ul>\n<li>\n<p translation-origin=\"off\"><code>compile</code>. This will not be supported in Angular.</p>\n<p translation-result=\"\"><code>compile</code>。它在Angular中将不再被支持。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>replace: true</code>. Angular never replaces a component element with the\ncomponent template. This attribute is also deprecated in AngularJS.</p>\n<p translation-result=\"\"><code>replace: true</code>。Angular永远不会用组件模板替换一个组件元素。这个特性在AngularJS中也同样不建议使用了。</p>\n</li>\n<li>\n<p translation-origin=\"off\"><code>priority</code> and <code>terminal</code>. While AngularJS components may use these,\nthey are not used in Angular and it is better not to write code\nthat relies on them.</p>\n<p translation-result=\"\"><code>priority</code>和<code>terminal</code>。虽然AngularJS的组件可能使用这些，但它们在Angular中已经没用了，并且最好不要再写依赖它们的代码。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">An AngularJS component directive that is fully aligned with the Angular\narchitecture may look something like this:</p>\n<p translation-result=\"\">AngularJS中一个完全向Angular架构对齐过的组件型指令是这样的：</p>\n<code-example path=\"upgrade-module/src/app/hero-detail.directive.ts\" title=\"hero-detail.directive.ts\">\nexport function heroDetailDirective() {\n  return {\n    restrict: 'E',\n    scope: {},\n    bindToController: {\n      hero: '=',\n      deleted: '&#x26;'\n    },\n    template: `\n      &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n      &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n      &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n    `,\n    controller: function() {\n      this.onDelete = () => {\n        this.deleted({hero: this.hero});\n      };\n    },\n    controllerAs: '$ctrl'\n  };\n}\n\n\n</code-example>\n<p translation-origin=\"off\">AngularJS 1.5 introduces the <a href=\"https://docs.angularjs.org/api/ng/type/angular.Module#component\">component API</a>\nthat makes it easier to define component directives like these. It is a good idea to use\nthis API for component directives for several reasons:</p>\n<p translation-result=\"\">AngularJS.5引入了<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\">组件API</a>，它让像这样定义指令变得更简单了。\n为组件型指令使用这个API是一个好主意，因为：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">It requires less boilerplate code.</p>\n<p translation-result=\"\">它需要更少的样板代码。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It enforces the use of component best practices like <code>controllerAs</code>.</p>\n<p translation-result=\"\">它强制使用组件的最佳实践，比如<code>controllerAs</code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">It has good default values for directive attributes like <code>scope</code> and <code>restrict</code>.</p>\n<p translation-result=\"\">对于指令中像<code>scope</code>和<code>restrict</code>这样的属性，它有良好的默认值。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">The component directive example from above looks like this when expressed\nusing the component API:</p>\n<p translation-result=\"\">如果使用这个组件API进行快捷定义，那么上面看到的组件型指令就变成了这样：</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p translation-origin=\"off\">Controller lifecycle hook methods <code>$onInit()</code>, <code>$onDestroy()</code>, and <code>$onChanges()</code>\nare another convenient feature that AngularJS 1.5 introduces. They all have nearly\nexact <a href=\"guide/lifecycle-hooks\">equivalents in Angular</a>, so organizing component lifecycle\nlogic around them will ease the eventual Angular upgrade process.</p>\n<p translation-result=\"\">控制器的生命周期钩子<code>$onInit()</code>、<code>$onDestroy()</code>和<code>$onChanges()</code>是AngularJS.5引入的另一些便利特性。\n它们都很接近于<a href=\"guide/lifecycle-hooks\">Angular中的等价物</a>，所以，围绕它们组织组件生命周期的逻辑会更容易升级。</p>\n<h2 translation-origin=\"off\" id=\"upgrading-with-ngupgrade\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-with-ngupgrade\"><i class=\"material-icons\">link</i></a>Upgrading with ngUpgrade</h2>\n<h2 translation-result=\"\" id=\"使用升级适配器进行升级\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用升级适配器进行升级\"><i class=\"material-icons\">link</i></a>使用升级适配器进行升级</h2>\n<p translation-origin=\"off\">The ngUpgrade library in Angular is a very useful tool for upgrading\nanything but the smallest of applications. With it you can mix and match\nAngularJS and Angular components in the same application and have them interoperate\nseamlessly. That means you don't have to do the upgrade work all at once,\nsince there's a natural coexistence between the two frameworks during the\ntransition period.</p>\n<p translation-result=\"\">不管要升级什么，Angular中的<code>ngUpgrade</code>库都会是一个非常有用的工具 —— 除非是小到没功能的应用。\n借助它，我们可以在同一个应用程序中混用并匹配AngularJS和2的组件，并让它们实现无缝的互操作。\n这意味着我们不用必须一次性做完所有升级工作，因为在整个演进过程中，这两个框架可以很自然的和睦相处。</p>\n<h3 translation-origin=\"off\" id=\"how-ngupgrade-works\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#how-ngupgrade-works\"><i class=\"material-icons\">link</i></a>How ngUpgrade Works</h3>\n<h3 translation-result=\"\" id=\"升级模块如何工作\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#升级模块如何工作\"><i class=\"material-icons\">link</i></a>升级模块如何工作</h3>\n<p translation-origin=\"off\">The primary tool provided by ngUpgrade is called the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nThis is a module that contains utilities for bootstrapping and managing hybrid\napplications that support both Angular and AngularJS code.</p>\n<p translation-result=\"\"><code>upgrade</code>模块提供的主要工具叫做<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。这是一个服务，它可以引导并管理同时支持Angular和AngularJS的混合式应用程序。</p>\n<p translation-origin=\"off\">When you use ngUpgrade, what you're really doing is <em>running both AngularJS and\nAngular at the same time</em>. All Angular code is running in the Angular\nframework, and AngularJS code in the AngularJS framework. Both of these are the\nactual, fully featured versions of the frameworks. There is no emulation going on,\nso you can expect to have all the features and natural behavior of both frameworks.</p>\n<p translation-result=\"\">当使用<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>时，我们实际做的是<em>同时运行两个版本的Angular</em>。所有Angular的代码运行在Angular框架中，\n而AngularJS的代码运行在AngularJS框架中。所有这些都是真实的、全功能的框架版本。\n没有进行任何仿真，所以我们可以期待同时存在这两个框架的所有特性和天生的行为。</p>\n<p translation-origin=\"off\">What happens on top of this is that components and services managed by one\nframework can interoperate with those from the other framework. This happens\nin three main areas: Dependency injection, the DOM, and change detection.</p>\n<p translation-result=\"\">所有这些事情的背后，本质上是一个框架中管理的组件和服务能和来自另一个中的进行互操作。\n这发生在三个主要的领域：依赖注入、DOM和变更检测。</p>\n<h4 translation-origin=\"off\" id=\"dependency-injection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#dependency-injection\"><i class=\"material-icons\">link</i></a>Dependency Injection</h4>\n<h4 translation-result=\"\" id=\"依赖注入\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#依赖注入\"><i class=\"material-icons\">link</i></a>依赖注入</h4>\n<p translation-origin=\"off\">Dependency injection is front and center in both AngularJS and\nAngular, but there are some key differences between the two\nframeworks in how it actually works.</p>\n<p translation-result=\"\">无论是在AngularJS中还是在Angular中，依赖注入都处于前沿和中心的位置，但在两个框架的工作原理上，却存在着一些关键的不同之处。</p>\n<table>\n  <tbody><tr>\n    <th>\n      AngularJS\n    </th>\n    <th>\n      Angular\n    </th>\n  </tr>\n  <tr>\n    <td>\n      Dependency injection tokens are always strings\n<p translation-result=\"\">      依赖注入的令牌(Token)永远是字符串(译注：指服务名称)。</p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      Tokens <a href=\"guide/dependency-injection\">can have different types</a>.\nThey are often classes. They may also be strings.</p>\n<p translation-result=\"\">      令牌<a href=\"guide/dependency-injection\">可能有不同的类型</a>。\n通常是类，也可能是字符串。</p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      There is exactly one injector. Even in multi-module applications,\neverything is poured into one big namespace.</p>\n<p translation-result=\"\">      只有一个注入器。即使在多模块的应用程序中，每样东西也都被装入一个巨大的命名空间中。</p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      There is a <a href=\"guide/hierarchical-dependency-injection\">tree hierarchy of injectors</a>,\nwith a root injector and an additional injector for each component.</p>\n<p translation-result=\"\">      有一组<a href=\"guide/hierarchical-dependency-injection\">树状多层注入器</a>，有一个根注入器，每个组件也另外有一个注入器。</p>\n    </td>\n  </tr>\n</tbody></table>\n<p translation-origin=\"off\">Even accounting for these differences you can still have dependency injection\ninteroperability. The <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> resolves the differences and makes\neverything work seamlessly:</p>\n<p translation-result=\"\">就算有这么多不同点，也并不妨碍我们在依赖注入时进行互操作。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>解决了这些差异，并让它们无缝的对接：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">You can make AngularJS services available for injection to Angular code\nby <em>upgrading</em> them. The same singleton instance of each service is shared\nbetween the frameworks. In Angular these services will always be in the\n<em>root injector</em> and available to all components.</p>\n<p translation-result=\"\">通过升级它们，我们就能让那些在AngularJS中能被注入的服务在Angular的代码中可用。\n在框架之间共享的是服务的同一个单例对象。在Angular中，这些外来服务总是被放在<em>根注入器</em>中，并可用于所有组件。\n它们总是具有<em>字符串令牌</em> —— 跟它们在AngularJS中的令牌相同。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You can also make Angular services available for injection to AngularJS code\nby <em>downgrading</em> them. Only services from the Angular root injector can\nbe downgraded. Again, the same singleton instances are shared between the frameworks.\nWhen you register a downgraded service, you must explicitly specify a <em>string token</em> that you want to\nuse in AngularJS.</p>\n</li>\n</ul>\n<p translation-result=\"\">通过降级它们，我们也能让那些在Angular中能被注入的服务在AngularJS的代码中可用。\n只有那些来自Angular根注入器的服务才能被降级。同样的，在框架之间共享的是同一个单例对象。\n当我们注册一个要降级的服务时，要明确指定一个打算在AngularJS中使用的<em>字符串令牌</em>。</p><figure>\n<img src=\"generated/images/guide/upgrade/injectors.png\" alt=\"The two injectors in a hybrid application\" width=\"700\" height=\"262\"><p></p>\n</figure>\n<h4 translation-origin=\"off\" id=\"components-and-the-dom\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#components-and-the-dom\"><i class=\"material-icons\">link</i></a>Components and the DOM</h4>\n<h4 translation-result=\"\" id=\"组件与dom\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#组件与dom\"><i class=\"material-icons\">link</i></a>组件与DOM</h4>\n<p translation-origin=\"off\">In the DOM of a hybrid ngUpgrade application are components and\ndirectives from both AngularJS and Angular. These components\ncommunicate with each other by using the input and output bindings\nof their respective frameworks, which ngUpgrade bridges together. They may also\ncommunicate through shared injected dependencies, as described above.</p>\n<p translation-result=\"\">在混合式应用中，我们能同时发现那些来自AngularJS和Angular中组件和指令的DOM。\n这些组件通过它们各自框架中的输入和输出绑定来互相通讯，它们由<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>桥接在一起。\n它们也能通过共享被注入的依赖彼此通讯，就像前面所说的那样。</p>\n<p translation-origin=\"off\">The key thing to understand about a hybrid application is that every element in the DOM is owned by exactly one of the two frameworks.\nThe other framework ignores it. If an element is\nowned by AngularJS, Angular treats it as if it didn't exist,\nand vice versa.</p>\n<p translation-result=\"\">理解混合式应用的关键在于，DOM中的每一个元素都只能属于这两个框架之一，而另一个框架则会忽略它。如果一个元素属于 AngularJS ，那么 Angular 就会当它不存在，反之亦然。</p>\n<p translation-origin=\"off\">So normally a hybrid application begins life as an AngularJS application,\nand it is AngularJS that processes the root template, e.g. the index.html.\nAngular then steps into the picture when an Angular component is used somewhere\nin an AngularJS template. That component's template will then be managed\nby Angular, and it may contain any number of Angular components and\ndirectives.</p>\n<p translation-result=\"\">所以，混合式应用总是像AngularJS程序那样启动，处理根模板的也是AngularJS.\n然后，当这个应用的模板中使用到了Angular的组件时，Angular才开始参与。\n这个组件的视图由Angular进行管理，而且它还可以使用一系列的Angular组件和指令。</p>\n<p translation-origin=\"off\">Beyond that, you may interleave the two frameworks.\nYou always cross the boundary between the two frameworks by one of two\nways:</p>\n<p translation-result=\"\">更进一步说，我们可以按照需要，任意穿插使用这两个框架。\n使用下面的两种方式之一，我们可以自由穿梭于这两个框架的边界：</p>\n<ol>\n<li>\n<p translation-origin=\"off\">By using a component from the other framework: An AngularJS template\nusing an Angular component, or an Angular template using an\nAngularJS component.</p>\n<p translation-result=\"\">通过使用来自另一个框架的组件：AngularJS的模板中用到了Angular的组件，或者Angular的模板中使用了AngularJS的组件。</p>\n</li>\n<li>\n<p translation-origin=\"off\">By transcluding or projecting content from the other framework. ngUpgrade\nbridges the related concepts of AngularJS transclusion and Angular content\nprojection together.</p>\n</li>\n</ol>\n<p translation-result=\"\">通过透传(transclude)或投影(project)来自另一个框架的内容。<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>牵线搭桥，把AngularJS的透传概念和Angular的内容投影概念关联起来。</p>\n<figure>\n  <img src=\"generated/images/guide/upgrade/dom.png\" alt=\"DOM element ownership in a hybrid application\" width=\"500\" height=\"294\">\n</figure>\n<p translation-result=\"\">Whenever you use a component that belongs to the other framework, a\nswitch between framework boundaries occurs. However, that switch only\nhappens to the elements in the template of thatcomponent . Consider a situation\nwhere you use an Angular component from AngularJS like this:\n当我们使用一个属于另一个框架的组件时，就会发生一个跨框架边界的切换。不过，这种切换只发生在该组件元素的<em>子节点</em>上。\n考虑一个场景，我们从AngularJS中使用一个Angular组件，就像这样：</p>\n<code-example language=\"html\" escape=\"html\">\n  &#x3C;a-component>&#x3C;/a-component>\n</code-example>\n<p translation-origin=\"off\">The DOM element <code>&#x3C;a-component></code> will remain to be an AngularJS managed\nelement, because it's defined in an AngularJS template. That also\nmeans you can apply additional AngularJS directives to it, but <em>not</em>\nAngular directives. It is only in the template of the <code>&#x3C;a-component></code>\nwhere Angular steps in. This same rule also applies when you\nuse AngularJS component directives from Angular.</p>\n<p translation-result=\"\">此时，<code>&#x3C;a-component></code>这个DOM元素仍然由AngularJS管理，因为它是在AngularJS的模板中定义的。\n这也意味着你可以往它上面添加别的AngularJS指令，却<em>不能</em>添加Angular的指令。\n只有在<code>&#x3C;a-component></code>组件的模板中才是Angular的天下。同样的规则也适用于在Angular中使用AngularJS组件型指令的情况。</p>\n<h4 translation-origin=\"off\" id=\"change-detection\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#change-detection\"><i class=\"material-icons\">link</i></a>Change Detection</h4>\n<h4 translation-result=\"\" id=\"变更检测\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#变更检测\"><i class=\"material-icons\">link</i></a>变更检测</h4>\n<p translation-origin=\"off\">The <code>scope.$apply()</code> is how AngularJS detects changes and updates data bindings.\nAfter every event that occurs, <code>scope.$apply()</code> gets called. This is done either\nautomatically by the framework, or manually by you.</p>\n<p translation-result=\"\">AngularJS中的变更检测全是关于<code>scope.$apply()</code>的。在每个事件发生之后，<code>scope.$apply()</code>就会被调用。\n这或者由框架自动调用，或者在某些情况下由我们自己的代码手动调用。它是发生变更检测以及更新数据绑定的时间点。</p>\n<p translation-origin=\"off\">In Angular things are different. While change detection still\noccurs after every event, no one needs to call <code>scope.$apply()</code> for\nthat to happen. This is because all Angular code runs inside something\ncalled the <a href=\"api/core/NgZone\">Angular zone</a>. Angular always\nknows when the code finishes, so it also knows when it should kick off\nchange detection. The code itself doesn't have to call <code>scope.$apply()</code>\nor anything like it.</p>\n<p translation-result=\"\">在Angular中，事情有点不一样。虽然变更检测仍然会在每一个事件之后发生，却不再需要每次调用<code>scope.$apply()</code>了。\n这是因为所有Angular代码都运行在一个叫做<a href=\"api/core/NgZone\">Angular zone</a>的地方。\nAngular总是知道什么时候代码执行完了，也就知道了它什么时候应该触发变更检测。代码本身并不需要调用<code>scope.$apply()</code>或其它类似的东西。</p>\n<p translation-origin=\"off\">In the case of hybrid applications, the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> bridges the\nAngularJS and Angular approaches. Here's what happens:</p>\n<p translation-result=\"\">在这种混合式应用的案例中，<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>在AngularJS的方法和Angular的方法之间建立了桥梁。发生了什么呢？</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Everything that happens in the application runs inside the Angular zone.\nThis is true whether the event originated in AngularJS or Angular code.\nThe zone triggers Angular change detection after every event.</p>\n<p translation-result=\"\">应用中发生的每件事都运行在Angular的zone里。\n无论事件发生在AngularJS还是Angular的代码中，都是如此。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> will invoke the AngularJS <code>$rootScope.$apply()</code> after\nevery turn of the Angular zone. This also triggers AngularJS change\ndetection after every event.</p>\n</li>\n</ul>\n<p translation-result=\"\"><code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>将在每一次离开Angular zone时调用AngularJS的<code>$rootScope.$apply()</code>。这样也就同样会在每个事件之后触发AngularJS的变更检测。</p>\n<figure>\n  <img src=\"generated/images/guide/upgrade/change_detection.png\" alt=\"Change detection in a hybrid application\" width=\"600\" height=\"163\">\n</figure>\n<p translation-origin=\"off\">In practice, you do not need to call <code>$apply()</code>,\nregardless of whether it is in AngularJS on Angular. The\n<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> does it for us. You <em>can</em> still call <code>$apply()</code> so there\nis no need to remove such calls from existing code. Those calls just trigger\nadditional AngularJS change detection checks in a hybrid application.</p>\n<p translation-result=\"\">在实践中，我们不用在自己的代码中调用<code>$apply()</code>，而不用管这段代码是在AngularJS还是Angular中。\n<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>都替我们做了。我们仍然<em>可以</em>调用<code>$apply()</code>，也就是说我们不必从现有代码中移除此调用。\n在混合式应用中，这些调用只会触发一次额外的 AngularJS 变更检测。</p>\n<p translation-origin=\"off\">When you downgrade an Angular component and then use it from AngularJS,\nthe component's inputs will be watched using AngularJS change detection.\nWhen those inputs change, the corresponding properties in the component\nare set. You can also hook into the changes by implementing the\n<a href=\"api/core/OnChanges\">OnChanges</a> interface in the component,\njust like you could if it hadn't been downgraded.</p>\n<p translation-result=\"\">当我们降级一个Angular组件，然后把它用于AngularJS中时，组件的输入属性就会被AngularJS的变更检测体系监视起来。\n当那些输入属性发生变化时，组件中相应的属性就会被设置。我们也能通过实现<a href=\"api/core/OnChanges\">OnChanges</a>\n接口来挂钩到这些更改，就像它未被降级时一样。</p>\n<p translation-origin=\"off\">Correspondingly, when you upgrade an AngularJS component and use it from Angular,\nall the bindings defined for the component directive's <code>scope</code> (or <code>bindToController</code>)\nwill be hooked into Angular change detection. They will be treated\nas regular Angular inputs. Their values will be written to the upgraded component's\nscope (or controller) when they change.</p>\n<p translation-result=\"\">相应的，当我们把AngularJS的组件升级给Angular使用时，在这个组件型指令的<code>scope</code>(或<code>bindToController</code>)中定义的所有绑定，\n都将被挂钩到Angular的变更检测体系中。它们将和标准的Angular输入属性被同等对待，并当它们发生变化时设置回scope(或控制器)上。</p>\n<h3 translation-origin=\"off\" id=\"using-upgrademodule-with-angular-ngmodules\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-upgrademodule-with-angular-ngmodules\"><i class=\"material-icons\">link</i></a>Using UpgradeModule with Angular <em>NgModules</em></h3>\n<h3 translation-result=\"\" id=\"通过angular的ngmodule来使用upgrademodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#通过angular的ngmodule来使用upgrademodule\"><i class=\"material-icons\">link</i></a>通过Angular的<em>NgModule</em>来使用UpgradeModule</h3>\n<p translation-origin=\"off\">Both AngularJS and Angular have their own concept of modules\nto help organize an application into cohesive blocks of functionality.</p>\n<p translation-result=\"\">AngularJS还是Angular都有自己的模块概念，来帮你我们把应用组织成一些紧密相关的功能块。</p>\n<p translation-origin=\"off\">Their details are quite different in architecture and implementation.\nIn AngularJS, you add Angular assets to the <code>angular.module</code> property.\nIn Angular, you create one or more classes adorned with an <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator\nthat describes Angular assets in metadata. The differences blossom from there.</p>\n<p translation-result=\"\">它们在架构和实现的细节上有着显著的不同。\n在AngularJS中，我们会把AngularJS的资源添加到<code>angular.module</code>属性上。\n在Angular中，我们会创建一个或多个带有<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>装饰器的类，这些装饰器用来在元数据中描述Angular资源。差异主要来自这里。</p>\n<p translation-origin=\"off\">In a hybrid application you run both versions of Angular at the same time.\nThat means that you need at least one module each from both AngularJS and Angular.\nYou will import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> inside the NgModule, and then use it for\nbootstrapping the AngularJS module.</p>\n<p translation-result=\"\">在混合式应用中，我们同时运行了两个版本的Angular。\n这意味着我们至少需要AngularJS和Angular各提供一个模块。\n当我们使用AngularJS的模块进行引导时，就得把Anuglar 2的模块传给<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>。我们来看看怎么做。</p>\n<div class=\"l-sub-section\">\n<p translation-result=\"\">Read more about <a href=\"guide/ngmodule\">NgModules</a>.\n要了解Angular模块的更多信息，请参阅<a href=\"guide/ngmodule\">Angular模块</a>页。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"bootstrapping-hybrid-applications\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-hybrid-applications\"><i class=\"material-icons\">link</i></a>Bootstrapping hybrid applications</h3>\n<h3 translation-result=\"\" id=\"引导angularjs2的混合式应用程序\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#引导angularjs2的混合式应用程序\"><i class=\"material-icons\">link</i></a>引导AngularJS+2的混合式应用程序</h3>\n<p translation-origin=\"off\">// TDOO: Translate\nTo bootstrap a hybrid application, you must bootstrap each of the Angular and\nAngularJS parts of the application. You must bootstrap the Angular bits first and\nthen ask the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to bootstrap the AngularJS bits next.</p>\n<p translation-origin=\"off\">In an AngularJS application you have a root AngularJS module, which will also\nbe used to bootstrap the AngularJS application.</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"ng1module\" title=\"app.module.ts\">\nangular.module('heroApp', [])\n  .controller('MainCtrl', function() {\n    this.message = 'Hello world';\n  });\n\n</code-example>\n<p translation-origin=\"off\">Pure AngularJS applications can be automatically bootstrapped by using an <code>ng-app</code>\ndirective somewhere on the HTML page. But for hybrid applications, you manually bootstrap via the\n<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>. Therefore, it is a good preliminary step to switch AngularJS applications to use the\nmanual JavaScript <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\"><code>angular.bootstrap</code></a>\nmethod even before switching them to hybrid mode.</p>\n<p translation-origin=\"off\">Say you have an <code>ng-app</code> driven bootstrap such as this one:</p>\n<code-example path=\"upgrade-module/src/index-ng-app.html\">\n&#x3C;!DOCTYPE HTML>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;base href=\"/\">\n    &#x3C;script src=\"https://ajax.googleapis.com/ajax/libs/angularjs/1.5.3/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"app/ajs-ng-app/app.module.js\">&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body ng-app=\"heroApp\" ng-strict-di>\n    &#x3C;div id=\"message\" ng-controller=\"MainCtrl as mainCtrl\">\n      {{ mainCtrl.message }}\n    &#x3C;/div>\n  &#x3C;/body>\n&#x3C;/html>\n\n\n</code-example>\n<p translation-origin=\"off\">You can remove the <code>ng-app</code> and <code>ng-strict-di</code> directives from the HTML\nand instead switch to calling <code>angular.bootstrap</code> from JavaScript, which\nwill result in the same thing:</p>\n<p translation-result=\"\">我们可以从HTML中移除<code>ng-app</code>和<code>ng-strict-di</code>指令，改为从JavaScript中调用<code>angular.bootstrap</code>，它能达到同样效果：</p>\n<code-example path=\"upgrade-module/src/app/ajs-bootstrap/app.module.ts\" region=\"bootstrap\" title=\"app.module.ts\">\nangular.bootstrap(document.body, ['heroApp'], { strictDi: true });\n\n</code-example>\n<p translation-origin=\"off\">To begin converting your AngularJS application to a hybrid, you need to load the Angular framework.\nYou can see how this can be done with SystemJS by following the instructions in <a href=\"guide/setup\">Setup</a>,\nselectively copying code from the <a href=\"https://github.com/angular/quickstart\">QuickStart github repository</a>.</p>\n<p translation-origin=\"off\">You also need to install the <code>@angular/upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package:</p>\n<code-example path=\"upgrade-module/src/systemjs.config.1.js\" region=\"upgrade-static-umd\" title=\"systemjs.config.js (map)\">\n'@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>.umd.js',\n\n</code-example>\n<p translation-result=\"\">现在，把Angular引入项目中。根据<a href=\"guide/setup\">搭建本地开发环境</a>中的指导，你可以有选择的从<a href=\"https://github.com/angular/quickstart\" target=\"_blank\">“快速上手”的Github仓库</a>中拷贝素材进来。</p>\n<p translation-origin=\"off\">Next, create an <code>app.module.ts</code> file and add the following <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n<p translation-result=\"\">接下来，创建一个<code>app.module.ts</code>文件，并添加下列<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>类：</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">This bare minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports <code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>, the module every Angular browser-based app must have.\nIt also imports <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>, which exports providers that will be used\nfor upgrading and downgrading services and components.</p>\n<p translation-result=\"\">最小化的<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>导入了<code><a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a></code>，它是每个基于浏览器的 Angular 应用必备的。\n它还从<code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>中导入了<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，它导出了一些服务提供商，这些提供商会用于升级、降级服务和组件。</p>\n<p translation-origin=\"off\">In the constructor of the <code>AppModule</code>, use dependency injection to get a hold of the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> instance,\nand use it to bootstrap the AngularJS app in the <code>AppModule.ngDoBootstrap</code> method.\nThe <code>upgrade.bootstrap</code> method takes the exact same arguments as <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\">angular.bootstrap</a>:</p>\n<p translation-result=\"\">在 <code>AppModule</code> 的构造函数中，使用依赖注入技术获取了一个 <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> 实例，并用它在<code>AppModule.ngDoBootstrap</code>方法中启动 AngularJS 应用。\n<code>upgrade.bootstrap</code> 方法接受和 <a href=\"https://docs.angularjs.org/api/ng/function/angular.bootstrap\">angular.bootstrap</a> 完全相同的参数。</p>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">Note that you do not add a <code>bootstrap</code> declaration to the <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> decorator, since\nAngularJS will own the root template of the application.</p>\n<p translation-result=\"\">注意，我们不需要在 <code>@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> 中加入 <code>bootstrap</code> 声明，因为 AngularJS 控制着该应用的根模板。</p>\n</div>\n<p translation-origin=\"off\">Now you can bootstrap <code>AppModule</code> using the <code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>.bootstrapModule</code> method.</p>\n<p translation-result=\"\">现在，我们就可以使用 <code><a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>.bootstrapModule</code> 方法来启动 <code>AppModule</code> 了。</p>\n<code-example path=\"upgrade-module/src/app/ajs-a-hybrid-bootstrap/app.module.ts\" region=\"bootstrap\" title=\"app.module.ts&#x27;\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p translation-origin=\"off\">Congratulations! You're running a hybrid application! The\nexisting AngularJS code works as before <em>and</em> you're ready to start adding Angular code.</p>\n<p translation-result=\"\">恭喜！我们就要开始运行AngularJS+2的混合式应用程序了！所有现存的AngularJS代码会像以前一样正常工作，但是我们现在也同样可以运行Angular代码了。</p>\n<h3 translation-origin=\"off\" id=\"using-angular-components-from-angularjs-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angular-components-from-angularjs-code\"><i class=\"material-icons\">link</i></a>Using Angular Components from AngularJS Code</h3>\n<h3 translation-result=\"\" id=\"在angularjs的代码中使用angular的组件\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#在angularjs的代码中使用angular的组件\"><i class=\"material-icons\">link</i></a>在AngularJS的代码中使用Angular的组件</h3>\n<img src=\"generated/images/guide/upgrade/ajs-to-a.png\" alt=\"Using an Angular component from AngularJS code\" class=\"left\" width=\"250\" height=\"44\">\n<p translation-origin=\"off\">Once you're running a hybrid app, you can start the gradual process of upgrading\ncode. One of the more common patterns for doing that is to use an Angular component\nin an AngularJS context. This could be a completely new component or one that was\npreviously AngularJS but has been rewritten for Angular.</p>\n<p translation-result=\"\">一旦我们开始运行混合式应用，我们就可以开始逐渐升级代码了。做这件事的一种更常见的模式就是在AngularJS的上下文中使用Angular的组件。\n该组件可能是全新的，也可能是把原本AngularJS的组件用Angular重写而成的。Say you have a simple Angular component that shows information about a hero:\n假设我们有一个简单的用来显示英雄信息的Angular组件：</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `\n})\nexport class HeroDetailComponent { }\n\n\n</code-example>\n<p translation-origin=\"off\">If you want to use this component from AngularJS, you need to <em>downgrade</em> it\nusing the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method. The result is an AngularJS\n<em>directive</em>, which you can then register in the AngularJS module:</p>\n<p translation-result=\"\">如果我们想在AngularJS中使用这个组件，我们就得用<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>方法把它<em>降级</em>。\n如果我们这么做，就会得到一个AngularJS的<em>指令</em>，我们可以把它注册到AngularJS的模块中：</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"downgradecomponent\" title=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n/* . . . */\n\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .directive(\n    'heroDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({ component: HeroDetailComponent }) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p translation-result=\"\">Because <code>HeroDetailComponent</code> is an Angular component, you must also add it to the\n<code>declarations</code> in the <code>AppModule</code>.由于<code>HeroDetailComponent</code>是一个Angular组件，所以我们必须同时把它加入<code>AppModule</code>的<code>declarations</code>字段中。</p>\n<p translation-origin=\"off\">And because this component is being used from the AngularJS module, and is an entry point into\nthe Angular application, you must add it to the <code>entryComponents</code> for the\nNgModule.</p>\n<p translation-result=\"\">并且由于这个组件在AngularJS模块中使用，也是我们Angular应用的一个入口点，我们还需要\n将它加入到Angular模块的<code>entryComponents</code>列表中。</p>\n<code-example path=\"upgrade-module/src/app/downgrade-static/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { HeroDetailComponent } from './hero-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailComponent\n  ],\n  entryComponents: [\n    HeroDetailComponent\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">All Angular components, directives and pipes must be declared in an NgModule.</p>\n<p translation-result=\"\">所有Angular组件、指令和管道都必须声明在NgModule中。</p>\n</div>\n<p translation-origin=\"off\">The net result is an AngularJS directive called <code>heroDetail</code>, that you can\nuse like any other directive in AngularJS templates.</p>\n<p translation-result=\"\">这里我们得到的是一个叫做<code>heroDetail</code>的AngularJS指令，我们可以像用其它指令一样把它用在AngularJS模板中。</p>\n<code-example path=\"upgrade-module/src/index-downgrade-static.html\" region=\"usecomponent\">\n&#x3C;hero-detail>&#x3C;/hero-detail>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">Note that this AngularJS is an element directive (<code>restrict: 'E'</code>) called <code>heroDetail</code>.\nAn AngularJS element directive is matched based on its <em>name</em>.\n<em>The <code>selector</code> metadata of the downgraded Angular component is ignored.</em></p>\n<p translation-result=\"\">注意，它在AngularJS中是一个名叫<code>heroDetail</code>的元素型指令（<code>restrict: 'E'</code>）。\nAngularJS的元素型指令是基于它的<em>名字</em>匹配的。\n<em>Angular组件中的<code>selector</code>元数据，在降级后的版本中会被忽略。</em></p>\n</div>\n<p translation-origin=\"off\">Most components are not quite this simple, of course. Many of them\nhave <em>inputs and outputs</em> that connect them to the outside world. An\nAngular hero detail component with inputs and outputs might look\nlike this:</p>\n<p translation-result=\"\">当然，大多数组件都不像这个这么简单。它们中很多都有<em>输入属性和输出属性</em>，来把它们连接到外部世界。\nAngular的英雄详情组件带有像这样的输入属性与输出属性：</p>\n<code-example path=\"upgrade-module/src/app/downgrade-io/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{hero.id}}&#x3C;/div>\n    &#x3C;button (click)=\"onDelete()\">Delete&#x3C;/button>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted = new <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>();\n  onDelete() {\n    this.deleted.emit(this.hero);\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">These inputs and outputs can be supplied from the AngularJS template, and the\n<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> method takes care of wiring them up:</p>\n<p translation-result=\"\">这些输入属性和输出属性的值来自于AngularJS的模板，而<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>方法负责桥接它们：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<p translation-origin=\"off\">Note that even though you are in an AngularJS template, <strong>you're using Angular\nattribute syntax to bind the inputs and outputs</strong>. This is a requirement for downgraded\ncomponents. The expressions themselves are still regular AngularJS expressions.</p>\n<p translation-result=\"\">注意，虽然我们正在AngularJS的模板中，<strong>但却在使用Angular的属性(Attribute)语法来绑定到输入属性与输出属性</strong>。\n这是降级的组件本身要求的。而表达式本身仍然是标准的AngularJS表达式。</p>\n<div class=\"callout is-important\">\n<header translation-origin=\"off\">\n  Use kebab-case for downgraded component attributes\n</header>\n<header translation-result=\"\">\n  在降级过的组件属性中使用中线命名法\n</header>\n<p translation-origin=\"off\">There's one notable exception to the rule of using Angular attribute syntax\nfor downgraded components. It has to do with input or output names that consist\nof multiple words. In Angular, you would bind these attributes using camelCase:</p>\n<p translation-result=\"\">为降级过的组件使用Angular的属性(Attribute)语法规则时有一个值得注意的例外。\n它适用于由多个单词组成的输入或输出属性。在Angular中，我们要使用小驼峰命名法绑定这些属性：</p>\n<code-example format=\"\">\n  [myHero]=\"hero\"\n\n</code-example>\n<p translation-origin=\"off\">But when using them from AngularJS templates, you must use kebab-case:</p>\n<p translation-result=\"\">但是从AngularJS的模板中使用它们时，我们得使用中线命名法：</p>\n<code-example format=\"\">\n  [my-hero]=\"hero\"\n</code-example>\n</div>\n<p translation-origin=\"off\">The <code>$event</code> variable can be used in outputs to gain access to the\nobject that was emitted. In this case it will be the <code>Hero</code> object, because\nthat is what was passed to <code>this.deleted.emit()</code>.</p>\n<p translation-result=\"\"><code>$event</code>变量能被用在输出属性里，以访问这个事件所发出的对象。这个案例中它是<code>Hero</code>对象，因为<code>this.deleted.emit()</code>函数曾把它传了出来。</p>\n<p translation-origin=\"off\">Since this is an AngularJS template, you can still use other AngularJS\ndirectives on the element, even though it has Angular binding attributes on it.\nFor example, you can easily make multiple copies of the component using <code>ng-repeat</code>:</p>\n<p translation-result=\"\">由于这是一个AngularJS模板，虽然它已经有了Angular中绑定的属性(Attribute)，我们仍可以在这个元素上使用其它AngularJS指令。\n例如，我们可以用<code>ng-repeat</code>简单的制作该组件的多份拷贝：</p>\n<code-example path=\"upgrade-module/src/index-downgrade-io.html\" region=\"userepeatedcomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"hero\"\n               (deleted)=\"mainCtrl.onDelete($event)\"\n               ng-repeat=\"hero in mainCtrl.heroes\">\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"using-angularjs-component-directives-from-angular-code\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-angularjs-component-directives-from-angular-code\"><i class=\"material-icons\">link</i></a>Using AngularJS Component Directives from Angular Code</h3>\n<h3 translation-result=\"\" id=\"从angular代码中使用angularjs组件型指令\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#从angular代码中使用angularjs组件型指令\"><i class=\"material-icons\">link</i></a>从Angular代码中使用AngularJS组件型指令</h3>\n<img src=\"generated/images/guide/upgrade/a-to-ajs.png\" alt=\"Using an AngularJS component from Angular code\" class=\"left\" width=\"250\" height=\"44\">\n<p translation-origin=\"off\">So, you can write an Angular component and then use it from AngularJS\ncode. This is useful when you start to migrate from lower-level\ncomponents and work your way up. But in some cases it is more convenient\nto do things in the opposite order: To start with higher-level components\nand work your way down. This too can be done using the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>.\nYou can <em>upgrade</em> AngularJS component directives and then use them from\nAngular.</p>\n<p translation-result=\"\">现在，我们已经能在Angular中写一个组件，并把它用于AngularJS代码中了。\n当我们从低级组件开始移植，并往上走时，这非常有用。但在另外一些情况下，从相反的方向进行移植会更加方便：\n从高级组件开始，然后往下走。这也同样能用<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>完成。\n我们可以<em>升级</em>AngularJS组件型指令，然后从Angular中用它们。</p>\n<p translation-origin=\"off\">Not all kinds of AngularJS directives can be upgraded. The directive\nreally has to be a <em>component directive</em>, with the characteristics\n<a href=\"guide/upgrade#using-component-directives\">described in the preparation guide above</a>.\nThe safest bet for ensuring compatibility is using the\n<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\">component API</a>\nintroduced in AngularJS 1.5.</p>\n<p translation-result=\"\">不是所有种类的AngularJS指令都能升级。该指令必须是一个严格的<em>组件型指令</em>，具有<a href=\"guide/upgrade#using-component-directives\">上面的准备指南中描述的</a>那些特征。\n确保兼容性的最安全的方式是AngularJS.5中引入的<a href=\"https://docs.angularjs.org/api/ng/type/angular.Module\">组件API</a>。</p>\n<p translation-origin=\"off\">A simple example of an upgradable component is one that just has a template\nand a controller:</p>\n<p translation-result=\"\">可升级组件的简单例子是只有一个模板和一个控制器的指令：</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  template: `\n    &#x3C;h2>Windstorm details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>1&#x3C;/div>\n  `,\n  controller: function() {\n  }\n};\n\n</code-example>\n<p translation-origin=\"off\">You can <em>upgrade</em> this component to Angular  using the <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> class.\nBy creating a new Angular  <strong>directive</strong> that extends <code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code> and doing a <code>super</code> call\ninside it's constructor, you have a fully upgraded AngularJS component to be used inside Angular .\nAll that is left is to add it to <code>AppModule</code>'s <code>declarations</code> array.</p>\n<p translation-result=\"\">我们可以使用<code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>方法来把这个组件<em>升级</em>到Angular。\n具体方法是创建一个Angular<strong>指令</strong>，继承<code><a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a></code>，在其构造函数中进行<code>super</code>调用，\n这样我们就得到一个完全升级的AngularJS组件，并且可以Angular中使用。\n剩下是工作就是把它加入到<code>AppModule</code>的<code>declarations</code>数组。</p>\n<code-example path=\"upgrade-module/src/app/upgrade-static/hero-detail.component.ts\" region=\"hero-detail-upgrade\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/SimpleChanges\" class=\"code-anchor\">SimpleChanges</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-static/app.module.ts\" region=\"hero-detail-upgrade\" title=\"app.module.ts\">\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  declarations: [\n    HeroDetailDirective,\n/* . . . */\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">Upgraded components are Angular <strong>directives</strong>, instead of <strong>components</strong>, because Angular\nis unaware that AngularJS will create elements under it. As far as Angular knows, the upgraded\ncomponent is just a directive - a tag - and Angular doesn't have to concern itself with\nit's children.</p>\n<p translation-result=\"\">升级后的组件是Angular的<strong>指令</strong>，而不是<strong>组件</strong>，因为Angular不知道AngularJS将在它下面创建元素。\nAngular所知道的是升级后的组件只是一个指令（一个标签），Angular不需要关心组件本身及其子元素。</p>\n</div>\n<p translation-result=\"\">An upgraded component may also have inputs and outputs, as defined by\nthe scope/controller bindings of the original AngularJS component\ndirective. When you use the component from an Angular template,\nprovide the inputs and outputs using <strong>Angular template syntax</strong>,\nobserving the following rules:\n升级后的组件也可能有输入属性和输出属性，它们是在原AngularJS组件型指令的scope/controller绑定中定义的。\n当我们从Angular模板中使用该组件时，我们要使用<strong>Angular模板语法</strong>来提供这些输入属性和输出属性，但要遵循下列规则：</p>\n<table>\n  <tbody><tr>\n    <th>\n    </th>\n    <th>\n      <p translation-origin=\"off\">\n        Binding definition\n      </p>\n      <p translation-result=\"\">\n        绑定定义\n      </p>\n    </th>\n    <th>\n      <p translation-origin=\"off\">\n        Template syntax\n      </p>\n      <p translation-result=\"\">\n        模板语法\n      </p>\n    </th>\n  </tr>\n  <tr>\n    <th>\n      <p translation-origin=\"off\">\n        Attribute binding\n      </p>\n      <p translation-result=\"\">\n        属性(Attribute)绑定\n      </p>\n    </th>\n    <td>\n<p translation-origin=\"off\">      <code>myAttribute: '@myAttribute'</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>&#x3C;my-component myAttribute=\"value\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <p translation-origin=\"off\">\n        Expression binding\n      </p>\n      <p translation-result=\"\">\n        表达式绑定\n      </p>\n    </th>\n    <td>\n<p translation-origin=\"off\">      <code>myOutput: '&#x26;myOutput'</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>&#x3C;my-component (myOutput)=\"action()\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <p translation-origin=\"off\">\n        One-way binding\n      </p>\n      <p translation-result=\"\">\n        单向绑定\n      </p>\n    </th>\n    <td>\n<p translation-origin=\"off\">      <code>myValue: '&#x3C;myValue'</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>&#x3C;my-component [myValue]=\"anExpression\"></code></p>\n    </td>\n  </tr>\n  <tr>\n    <th>\n      <p translation-origin=\"off\">\n        Two-way binding\n      </p>\n      <p translation-result=\"\">\n        双向绑定\n      </p>\n    </th>\n    <td>\n<p translation-origin=\"off\">      <code>myValue: '=myValue'</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      As a two-way binding: <code>&#x3C;my-component [(myValue)]=\"anExpression\"></code>.\nSince most AngularJS two-way bindings actually only need a one-way binding\nin practice, <code>&#x3C;my-component [myValue]=\"anExpression\"></code> is often enough.</p>\n<p translation-result=\"\">      用作输入：<code>&#x3C;my-component [myValue]=\"anExpression\"></code> 或\n用作双向绑定：<code>&#x3C;my-component [(myValue)]=\"anExpression\"</code></p>\n    </td>\n  </tr>\n</tbody></table>\n<p translation-origin=\"off\">For example, imagine a hero detail AngularJS component directive\nwith one input and one output:</p>\n<p translation-result=\"\">举个例子，假设我们在AngularJS中有一个表示“英雄详情”的组件型指令，它带有一个输入属性和一个输出属性：</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '&#x3C;',\n    deleted: '&#x26;'\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}} details!&#x3C;/h2>\n    &#x3C;div>&#x3C;label>id: &#x3C;/label>{{$ctrl.hero.id}}&#x3C;/div>\n    &#x3C;button ng-click=\"$ctrl.onDelete()\">Delete&#x3C;/button>\n  `,\n  controller: function() {\n    this.onDelete = () => {\n      this.deleted(this.hero);\n    };\n  }\n};\n\n</code-example>\n<p translation-result=\"\">You can upgrade this component to Angular, annotate inputs and outputs in the upgrade directive,\nand then provide the input and output using Angular template syntax:我们可以把这个组件升级到Angular，然后使用Angular的模板语法提供这个输入属性和输出属性：</p>\n<code-example path=\"upgrade-module/src/app/upgrade-io/hero-detail.component.ts\" region=\"hero-detail-io-upgrade\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>, <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a>, <a href=\"api/core/Output\" class=\"code-anchor\">Output</a>, <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a> } from '@angular/core';\nimport { <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Directive\" class=\"code-anchor\">Directive</a>({\n  selector: 'hero-detail'\n})\nexport class HeroDetailDirective extends <a href=\"api/upgrade/static/UpgradeComponent\" class=\"code-anchor\">UpgradeComponent</a> {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n  @<a href=\"api/core/Output\" class=\"code-anchor\">Output</a>() deleted: <a href=\"api/core/EventEmitter\" class=\"code-anchor\">EventEmitter</a>&#x3C;Hero>;\n\n  constructor(elementRef: <a href=\"api/core/ElementRef\" class=\"code-anchor\">ElementRef</a>, injector: <a href=\"api/core/Injector\" class=\"code-anchor\">Injector</a>) {\n    super('heroDetail', elementRef, injector);\n  }\n}\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/upgrade-io/container.component.ts\" title=\"container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;h1>Tour of Heroes&#x3C;/h1>\n    &#x3C;hero-detail [hero]=\"hero\"\n                 (deleted)=\"heroDeleted($event)\">\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm');\n  heroDeleted(hero: Hero) {\n    hero.name = 'Ex-' + hero.name;\n  }\n}\n\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"projecting-angularjs-content-into-angular-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#projecting-angularjs-content-into-angular-components\"><i class=\"material-icons\">link</i></a>Projecting AngularJS Content into Angular Components</h3>\n<h3 translation-result=\"\" id=\"把angularjs的内容投影到angular组件中\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#把angularjs的内容投影到angular组件中\"><i class=\"material-icons\">link</i></a>把AngularJS的内容投影到Angular组件中</h3>\n<img src=\"generated/images/guide/upgrade/ajs-to-a-with-projection.png\" alt=\"Projecting AngularJS content into Angular\" class=\"left\" width=\"250\" height=\"48\">\n<p translation-origin=\"off\">When you are using a downgraded Angular component from an AngularJS\ntemplate, the need may arise to <em>transclude</em> some content into it. This\nis also possible. While there is no such thing as transclusion in Angular,\nthere is a very similar concept called <em>content projection</em>. The <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>\nis able to make these two features interoperate.</p>\n<p translation-result=\"\">如果我们在AngularJS模板中使用降级后的Angular组件时，可能会需要把模板中的一些内容投影进那个组件。\n这也是可能的，虽然在Angular中并没有透传(transclude)这样的东西，但它有一个非常相似的概念，叫做<em>内容投影</em>。\n<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>也能让这两个特性实现互操作。</p>\n<p translation-origin=\"off\">Angular components that support content projection make use of an <code>&#x3C;ng-content></code>\ntag within them. Here's an example of such a component:</p>\n<p translation-result=\"\">Angular的组件通过使用<code>&#x3C;ng-content></code>标签来支持内容投影。下面是这类组件的一个例子：</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-projection/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a>, <a href=\"api/core/Input\" class=\"code-anchor\">Input</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-content>&#x3C;/ng-content>\n    &#x3C;/div>\n  `\n})\nexport class HeroDetailComponent {\n  @<a href=\"api/core/Input\" class=\"code-anchor\">Input</a>() hero: Hero;\n}\n\n\n</code-example>\n<p translation-origin=\"off\">When using the component from AngularJS, you can supply contents for it. Just\nlike they would be transcluded in AngularJS, they get projected to the location\nof the <code>&#x3C;ng-content></code> tag in Angular:</p>\n<p translation-result=\"\">当从AngularJS中使用该组件时，我们可以为它提供内容。正如它们将在AngularJS中被透传一样，\n它们也在Angular中被投影到了<code>&#x3C;ng-content></code>标签所在的位置：</p>\n<code-example path=\"upgrade-module/src/index-ajs-to-a-projection.html\" region=\"usecomponent\">\n&#x3C;div ng-controller=\"MainController as mainCtrl\">\n  &#x3C;hero-detail [hero]=\"mainCtrl.hero\">\n    &#x3C;!-- Everything here will get projected -->\n    &#x3C;p>{{mainCtrl.hero.description}}&#x3C;/p>\n  &#x3C;/hero-detail>\n&#x3C;/div>\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">When AngularJS content gets projected inside an Angular component, it still\nremains in \"AngularJS land\" and is managed by the AngularJS framework.</p>\n<p translation-result=\"\">当AngularJS的内容被投影到Angular组件中时，它仍然留在“AngularJS王国”中，并被AngularJS框架管理着。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"transcluding-angular-content-into-angularjs-component-directives\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#transcluding-angular-content-into-angularjs-component-directives\"><i class=\"material-icons\">link</i></a>Transcluding Angular Content into AngularJS Component Directives</h3>\n<h3 translation-result=\"\" id=\"把angular的内容透传进angularjs的组件型指令\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#把angular的内容透传进angularjs的组件型指令\"><i class=\"material-icons\">link</i></a>把Angular的内容透传进AngularJS的组件型指令</h3>\n<img src=\"generated/images/guide/upgrade/a-to-ajs-with-transclusion.png\" alt=\"Projecting Angular content into AngularJS\" class=\"left\" width=\"250\" height=\"48\">\n<p translation-origin=\"off\">Just as you can project AngularJS content into Angular components,\nyou can <em>transclude</em> Angular content into AngularJS components, whenever\nyou are using upgraded versions from them.</p>\n<p translation-result=\"\">就像我们能把AngularJS的内容投影进Angular组件一样，我们也能把Angular的内容<em>透传</em>进AngularJS的组件，\n但不管怎样，我们都要使用它们升级过的版本。</p>\n<p translation-origin=\"off\">When an AngularJS component directive supports transclusion, it may use\nthe <code>ng-transclude</code> directive in its template to mark the transclusion\npoint:</p>\n<p translation-result=\"\">如果一个AngularJS组件型指令支持透传，它就会在自己的模板中使用<code>ng-transclude</code>指令标记出透传到的位置：</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nexport const heroDetail = {\n  bindings: {\n    hero: '='\n  },\n  template: `\n    &#x3C;h2>{{$ctrl.hero.name}}&#x3C;/h2>\n    &#x3C;div>\n      &#x3C;ng-transclude>&#x3C;/ng-transclude>\n    &#x3C;/div>\n  `,\n  transclude: true\n};\n\n</code-example>\n<p translation-origin=\"off\">If you upgrade this component and use it from Angular, you can populate\nthe component tag with contents that will then get transcluded:</p>\n<p translation-result=\"\">如果我们升级这个组件，并把它用在Angular中，我们就能把准备透传的内容放进这个组件的标签中。</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-transclusion/container.component.ts\" title=\"container.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'my-container',\n  template: `\n    &#x3C;hero-detail [hero]=\"hero\">\n      &#x3C;!-- Everything here will get transcluded -->\n      &#x3C;p>{{hero.description}}&#x3C;/p>\n    &#x3C;/hero-detail>\n  `\n})\nexport class ContainerComponent {\n  hero = new Hero(1, 'Windstorm', 'Specific powers of controlling winds');\n}\n\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"making-angularjs-dependencies-injectable-to-angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\"><i class=\"material-icons\">link</i></a>Making AngularJS Dependencies Injectable to Angular</h3>\n<h3 translation-result=\"\" id=\"让angularjs中的依赖可被注入到angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#让angularjs中的依赖可被注入到angular\"><i class=\"material-icons\">link</i></a>让AngularJS中的依赖可被注入到Angular</h3>\n<p translation-origin=\"off\">When running a hybrid app, you may encounter situations where you need to inject\nsome AngularJS dependencies into your Angular code.\nMaybe you have some business logic still in AngularJS services.\nMaybe you want access to AngularJS's built-in services like <code>$location</code> or <code>$timeout</code>.</p>\n<p translation-result=\"\">当运行一个混合式应用时，我们可能会遇到这种情况：我们需要把某些AngularJS的依赖注入到Angular代码中。\n这可能是因为某些业务逻辑仍然在AngularJS服务中，或者需要某些AngularJS的内置服务，比如<code>$location</code>或<code>$timeout</code>。</p>\n<p translation-result=\"\">In these situations, it is possible to <em>upgrade</em> an AngularJS provider to\nAngular. This makes it possible to then inject it somewhere in Angular\ncode. For example, you might have a service called <code>HeroesService</code> in AngularJS:\n在这些情况下，把一个AngularJS提供商<em>升级到</em>Angular也是有可能的。这就让它将来有可能被注入到Angular代码中的某些地方。\n比如，我们可能在AngularJS中有一个名叫<code>HeroesService</code>的服务：</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/heroes.service.ts\" title=\"heroes.service.ts\">\nimport { Hero } from '../hero';\n\nexport class HeroesService {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">You can upgrade the service using a Angular <a href=\"guide/dependency-injection#factory-providers\">factory provider</a>\nthat requests the service from the AngularJS <code>$injector</code>.</p>\n<p translation-result=\"\">我们可以Angular的<a href=\"guide/dependency-injection#factory-providers\">工厂提供商（factory provider）</a>升级该服务，\n它从AngularJS的<code>$injector</code>请求服务。Angular依赖的名称由你确定：</p>\n<p translation-origin=\"off\">Many developers prefer to declare the factory provider in a separate <code>ajs-upgraded-providers.ts</code> file\nso that they are all together, making it easier to reference them, create new ones and\ndelete them once the upgrade is over.</p>\n<p translation-result=\"\">很多开发者都喜欢在一个独立的<code>ajs-upgraded-providers.ts</code>中声明这个工厂提供商，以便把它们都放在一起，这样便于引用、创建新的以及在升级完毕时删除它们。</p>\n<p translation-origin=\"off\">It's also recommended to export the <code>heroesServiceFactory</code> function so that Ahead-of-Time\ncompilation can pick it up.</p>\n<p translation-result=\"\">我们还建议导出<code>heroesServiceFactory</code>函数，以便AOT编译器可以拿到它们。</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/ajs-upgraded-providers.ts\" title=\"ajs-upgraded-providers.ts\">\nimport { HeroesService } from './heroes.service';\n\nexport function heroesServiceFactory(i: any) {\n  return i.get('heroes');\n}\n\nexport const heroesServiceProvider = {\n  provide: HeroesService,\n  useFactory: heroesServiceFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/app.module.ts\" region=\"register\" title=\"app.module.ts\">\nimport { heroesServiceProvider } from './ajs-upgraded-providers';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [\n    heroesServiceProvider\n  ],\n/* . . . */\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-result=\"\">You can then inject it in Angular using it's class as a type annotation:\n然后我们可以一个字符串型令牌，把它注入到Angular中：</p>\n<code-example path=\"upgrade-module/src/app/ajs-to-a-providers/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { HeroesService } from './heroes.service';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'hero-detail',\n  template: `\n    &#x3C;h2>{{hero.id}}: {{hero.name}}&#x3C;/h2>\n  `\n})\nexport class HeroDetailComponent {\n  hero: Hero;\n  constructor(heroes: HeroesService) {\n    this.hero = heroes.get()[0];\n  }\n}\n\n\n</code-example>\n<div class=\"alert is-helpful\">\n<p translation-origin=\"off\">In this example you upgraded a service class.\nYou can use a TypeScript type annotation when you inject it. While it doesn't\naffect how the dependency is handled, it enables the benefits of static type\nchecking. This is not required though, and any AngularJS service, factory, or\nprovider can be upgraded.</p>\n<p translation-result=\"\">在这个例子中，我们升级了服务类。当我们注入它时，我们可以使用TypeScript类型注解来获得这些额外的好处。\n它没有影响该依赖的处理过程，同时还得到了启用静态类型检查的好处。\n任何AngularJS中的服务、工厂和提供商都能被升级 —— 尽管这不是必须的。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"making-angular-dependencies-injectable-to-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#making-angular-dependencies-injectable-to-angularjs\"><i class=\"material-icons\">link</i></a>Making Angular Dependencies Injectable to AngularJS</h3>\n<h3 translation-result=\"\" id=\"让angular的依赖能被注入到angularjs中\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#让angular的依赖能被注入到angularjs中\"><i class=\"material-icons\">link</i></a>让Angular的依赖能被注入到AngularJS中</h3>\n<p translation-origin=\"off\">In addition to upgrading AngularJS dependencies, you can also <em>downgrade</em>\nAngular dependencies, so that you can use them from AngularJS. This can be\nuseful when you start migrating services to Angular or creating new services\nin Angular while retaining components written in AngularJS.</p>\n<p translation-result=\"\">除了能升级AngularJS依赖之外，我们还能<em>降级</em>Angular的依赖，以便我们能在AngularJS中使用它们。\n当我们已经开始把服务移植到Angular或在Angular中创建新服务，但同时还有一些用AngularJS写成的组件时，这会非常有用。For example, you might have an Angular service called <code>Heroes</code>:\n例如，我们可能有一个Angular的<code>Heroes</code>服务：</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/heroes.ts\" title=\"heroes.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { Hero } from '../hero';\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Heroes {\n  get() {\n    return [\n      new Hero(1, 'Windstorm'),\n      new Hero(2, 'Spiderman')\n    ];\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Again, as with Angular components, register the provider with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> by adding it to the module's <code>providers</code> list.</p>\n<p translation-result=\"\">仿照Angular组件，我们通过把该提供商加入<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的<code>providers</code>列表中来注册它。</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"ngmodule\" title=\"app.module.ts\">\nimport { Heroes } from './heroes';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>\n  ],\n  providers: [ Heroes ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.body, ['heroApp'], { strictDi: true });\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Now wrap the Angular <code>Heroes</code> in an <em>AngularJS factory function</em> using <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>\nand plug the factory into an AngularJS module.\nThe name of the AngularJS dependency is up to you:</p>\n<p translation-result=\"\">现在，我们使用<code>upgradeAdapter.downgradeNg2Provider()</code>来把Angular的<code>Heroes</code>包装成<em>AngularJS的工厂函数</em>，并把这个工厂注册进AngularJS的模块中。\n依赖在AngularJS中的名字你可以自己定：</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/app.module.ts\" region=\"register\" title=\"app.module.ts\">\nimport { Heroes } from './heroes';\n/* . . . */\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nangular.module('heroApp', [])\n  .factory('heroes', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Heroes))\n  .component('heroDetail', heroDetailComponent);\n\n</code-example>\n<p translation-result=\"\">After this, the service is injectable anywhere in  AngularJS code:\n此后，该服务就能被注入到AngularJS代码中的任何地方了：</p>\n<code-example path=\"upgrade-module/src/app/a-to-ajs-providers/hero-detail.component.ts\" title=\"hero-detail.component.ts\">\nexport const heroDetailComponent = {\n  template: `\n    &#x3C;h2>{{$ctrl.hero.id}}: {{$ctrl.hero.name}}&#x3C;/h2>\n  `,\n  controller: ['heroes', function(heroes: Heroes) {\n    this.hero = heroes.get()[0];\n  }]\n};\n\n\n</code-example>\n<h2 translation-origin=\"off\" id=\"using-ahead-of-time-compilation-with-hybrid-apps\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#using-ahead-of-time-compilation-with-hybrid-apps\"><i class=\"material-icons\">link</i></a>Using Ahead-of-time compilation with hybrid apps</h2>\n<h2 translation-result=\"\" id=\"在混合式应用中使用aot编译\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#在混合式应用中使用aot编译\"><i class=\"material-icons\">link</i></a>在混合式应用中使用AOT编译</h2>\n<p translation-origin=\"off\">You can take advantage of Ahead-of-time (AOT) compilation on hybrid apps just like on any other\nAngular application.\nThe setup for an hybrid app is mostly the same as described in\n<a href=\"guide/aot-compiler\">the Ahead-of-time Compilation chapter</a>\nsave for differences in <code>index.html</code> and <code>main-aot.ts</code></p>\n<p translation-result=\"\">我们也可以其它Angular应用一样在混合式应用中发挥AOT编译的优势。\n对混合式应用的设置过程和<a href=\"guide/aot-compiler\">预编译</a>章节中所讲的几乎完全一样，不同点在于<code>index.html</code>和<code>main-aot.ts</code>中。</p>\n<p translation-origin=\"off\">The <code>index.html</code> will likely have script tags loading AngularJS files, so the <code>index.html</code>\nfor AOT must also load those files.\nAn easy way to copy them is by adding each to the <code>copy-dist-files.js</code> file.</p>\n<p translation-result=\"\">我们的<code>index.html</code>仍然需要script标签来加载AngularJS的文件，因此我们使用AOT编译的<code>index.html</code>也需要加载那些文件。\n复制它们的简单方案是把它们全都添加到<code>copy-dist-files.js</code>文件中。</p>\n<p translation-origin=\"off\">You'll need to use the generated <code>AppModuleFactory</code>, instead of the original <code>AppModule</code> to\nbootstrap the hybrid app:</p>\n<p translation-result=\"\">我们还要使用所生成的<code>AppModuleFactory</code>而不是原来的<code>AppModule</code>来引导一个混合式应用：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" title=\"app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\nimport { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n<p translation-origin=\"off\">And that's all you need do to get the full benefit of AOT for Angular apps!</p>\n<p translation-result=\"\">这就是我们为获取Angular应用的AOT优势所要做的一切。</p>\n<h2 translation-origin=\"off\" id=\"phonecat-upgrade-tutorial\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat-upgrade-tutorial\"><i class=\"material-icons\">link</i></a>PhoneCat Upgrade Tutorial</h2>\n<h2 translation-result=\"\" id=\"phonecat升级教程\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#phonecat升级教程\"><i class=\"material-icons\">link</i></a>PhoneCat升级教程</h2>\n<p translation-origin=\"off\">In this section, you'll learn to prepare and upgrade an application with <code>ngUpgrade</code>.\nThe example app is <a href=\"https://github.com/angular/angular-phonecat\">Angular PhoneCat</a>\nfrom <a href=\"https://docs.angularjs.org/tutorial\">the original AngularJS tutorial</a>,\nwhich is where many of us began our Angular adventures. Now you'll see how to\nbring that application to the brave new world of Angular.</p>\n<p translation-result=\"\">在本节和下节中，我们将看一个完整的例子，它使用<code>upgrade</code>模块准备和升级了一个应用程序。\n该应用就是来自<a href=\"https://docs.angularjs.org/tutorial\">原AngularJS教程</a>中的<a href=\"https://github.com/angular/angular-phonecat\">Angular PhoneCat</a>。\n那是我们很多人当初开始Angular探险之旅的起点。\n现在，我们来看看如何把该应用带入Angular的美丽新世界。</p>\n<p translation-origin=\"off\">During the process you'll learn how to apply the steps outlined in the\n<a href=\"guide/upgrade#preparation\">preparation guide</a>. You'll align the application\nwith Angular and also start writing in TypeScript.</p>\n<p translation-result=\"\">这期间，我们将学到如何在实践中应用<a href=\"guide/upgrade#preparation\">准备指南</a>中列出的那些重点步骤：\n我们先让该应用向Angular看齐，然后为它引入SystemJS模块加载器和TypeScript。</p>\n<p translation-origin=\"off\">To follow along with the tutorial, clone the\n<a href=\"https://github.com/angular/angular-phonecat\">angular-phonecat</a> repository\nand apply the steps as you go.</p>\n<p translation-result=\"\">要跟随本教程，请先把<a href=\"https://github.com/angular/angular-phonecat\">angular-phonecat</a>仓库克隆到本地，并跟我们一起应用这些步骤。In terms of project structure, this is where the work begins:\n在项目结构方面，我们工作的起点是这样的：</p>\n<div class=\"filetree\">\n  <div class=\"file\">\n    angular-phonecat\n  </div>\n  <div class=\"children\">\n    <div class=\"file\">\n      bower.json\n    </div>\n    <div class=\"file\">\n      karma.conf.js\n    </div>\n    <div class=\"file\">\n      package.json\n    </div>\n    <div class=\"file\">\n      app\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        core\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          checkmark\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            checkmark.filter.js\n          </div>\n          <div class=\"file\">\n            checkmark.filter.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          phone\n        </div>\n        <div class=\"children\">\n          <div class=\"file\">\n            phone.module.js\n          </div>\n          <div class=\"file\">\n            phone.service.js\n          </div>\n          <div class=\"file\">\n            phone.service.spec.js\n          </div>\n        </div>\n        <div class=\"file\">\n          core.module.js\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-detail\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-detail.component.js\n        </div>\n        <div class=\"file\">\n          phone-detail.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-detail.module.js\n        </div>\n        <div class=\"file\">\n          phone-detail.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        phone-list\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n          phone-list.component.js\n        </div>\n        <div class=\"file\">\n          phone-list.component.spec.js\n        </div>\n        <div class=\"file\">\n          phone-list.module.js\n        </div>\n        <div class=\"file\">\n          phone-list.template.html\n        </div>\n      </div>\n      <div class=\"file\">\n        img\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        phones\n      </div>\n      <div class=\"children\">\n        <div class=\"file\">\n           ...\n        </div>\n      </div>\n      <div class=\"file\">\n        app.animations.js\n      </div>\n      <div class=\"file\">\n        app.config.js\n      </div>\n      <div class=\"file\">\n        app.css\n      </div>\n      <div class=\"file\">\n        app.module.js\n      </div>\n      <div class=\"file\">\n        index.html\n      </div>\n    </div>\n    <div class=\"file\">\n      e2e-tests\n    </div>\n    <div class=\"children\">\n      <div class=\"file\">\n        protractor-conf.js\n      </div>\n      <div class=\"file\">\n        scenarios.js\n      </div>\n    </div>\n  </div>\n</div>\n<p translation-origin=\"off\">This is actually a pretty good starting point. The code uses the AngularJS 1.5\ncomponent API and the organization follows the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS Style Guide</a>,\nwhich is an important <a href=\"guide/upgrade#follow-the-angular-styleguide\">preparation step</a> before\na successful upgrade.</p>\n<p translation-result=\"\">这确实是一个很好地起点。特别是，该结构遵循了<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md\">AngularJS 风格指南</a>，\n要想成功升级，这是一个很重要的<a href=\"guide/upgrade#follow-the-angular-styleguide\">准备步骤</a>。</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Each component, service, and filter is in its own source file, as per the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">Rule of 1</a>.</p>\n<p translation-result=\"\">每个组件、服务和过滤器都在它自己的源文件中 —— 就像<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#single-responsibility\">单一规则</a>所要求的。</p>\n</li>\n<li>\n<p translation-origin=\"off\">The <code>core</code>, <code>phone-detail</code>, and <code>phone-list</code> modules are each in their\nown subdirectory. Those subdirectories contain the JavaScript code as well as\nthe HTML templates that go with each particular feature. This is in line with the\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#folders-by-feature-structure\">Folders-by-Feature Structure</a>\nand <a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">Modularity</a>\nrules.</p>\n<p translation-result=\"\"><code>core</code>、<code>phone-detail</code>和<code>phone-list</code>模块都在它们自己的子目录中。那些子目录除了包含HTML模板之外，还包含JavaScript代码，它们共同完成一个特性。\n这是<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#style-y152\">按特性分目录的结构</a>\n和<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#modularity\">模块化</a>规则所要求的。</p>\n</li>\n<li>\n<p translation-origin=\"off\">Unit tests are located side-by-side with application code where they are easily\nfound, as described in the rules for\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\">Organizing Tests</a>.</p>\n<p translation-result=\"\">单元测试都和应用代码在一起，它们很容易找到。就像规则\n<a href=\"https://github.com/johnpapa/angular-styleguide/blob/master/a1/README.md#organizing-tests\">组织测试文件</a>中要求的那样。</p>\n</li>\n</ul>\n<h3 translation-origin=\"off\" id=\"switching-to-typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#switching-to-typescript\"><i class=\"material-icons\">link</i></a>Switching to TypeScript</h3>\n<h3 translation-result=\"\" id=\"切换到typescript\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#切换到typescript\"><i class=\"material-icons\">link</i></a>切换到TypeScript</h3>\n<p translation-origin=\"off\">Since you're going to be writing Angular code in TypeScript, it makes sense to\nbring in the TypeScript compiler even before you begin upgrading.</p>\n<p translation-result=\"\">因为我们将使用TypeScript编写Angular的代码，所以在开始升级之前，我们把TypeScript的编译器设置好是很合理的。</p>\n<p translation-origin=\"off\">You'll also start to gradually phase out the Bower package manager in favor\nof NPM, installing all new dependencies using NPM, and eventually removing Bower from the project.</p>\n<p translation-result=\"\">我们还将开始逐步淘汰Bower包管理器，换成我们更喜欢的NPM。后面我们将使用NPM来安装新的依赖包，并最终从项目中移除Bower。</p>\n<p translation-origin=\"off\">Begin by installing TypeScript to the project.</p>\n<p translation-result=\"\">让我们先把TypeScript包安装到项目中。</p>\n<code-example format=\"\">\n  npm i typescript --save-dev\n</code-example>\n<p translation-origin=\"off\">Install type definitions for the existing libraries that\nyou're using but that don't come with prepackaged types: AngularJS and the\nJasmine unit test framework.</p>\n<p translation-result=\"\">我们还要为那些没有自带类型信息的库（比如 AngularJS 和 Jasmine）安装类型定义文件。</p>\n<code-example format=\"\">\n  npm install @types/jasmine @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p translation-origin=\"off\">You should also configure the TypeScript compiler with a <code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> in the project directory\nas described in the <a href=\"guide/typescript-configuration\">TypeScript Configuration</a> guide.\nThe <code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> file tells the TypeScript compiler how to turn your TypeScript files\ninto ES5 code bundled into CommonJS modules.</p>\n<p translation-result=\"\">我们还应该配置TypeScript编译器，以便它能理解我们的项目结构。我们要往项目目录下添加一个<code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>文件，\n就像在<a href=\"guide/setup\">搭建本地开发环境</a>中做过的那样。它将告诉TypeScript编译器，该如何编译我们的源文件。\n<code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>文件会告诉 TypeScript 编译器如何把 TypeScript 文件转成 ES5 代码，并打包进 CommonJS 模块中。</p>\n<p translation-origin=\"off\">Finally, you should add some npm scripts in <code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> to compile the TypeScript files to\nJavaScript (based on the <code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> configuration file):</p>\n<p translation-result=\"\">最后，我们应该把下列 npm 脚本添加到 <code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> 中，用于把 TypeScript 文件编译成 JavaScript （根据<code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>的配置）：</p>\n<code-example format=\"\">\n  \"script\": {\n    \"tsc\": \"tsc\",\n    \"tsc:w\": \"tsc -w\",\n    ...\n</code-example>\n<p translation-origin=\"off\">Now launch the TypeScript compiler from the command line in watch mode:</p>\n<p translation-result=\"\">现在，从命令行中用监视模式启动 TypeScript 编译器：</p>\n<code-example format=\"\">\n  npm run tsc:w\n</code-example>\n<p translation-origin=\"off\">Keep this process running in the background, watching and recompiling as you make changes.</p>\n<p translation-origin=\"off\">Next, convert your current JavaScript files into TypeScript. Since\nTypeScript is a super-set of ECMAScript 2015, which in turn is a super-set\nof ECMAScript 5, you can simply switch the file extensions from <code>.js</code> to <code>.ts</code>\nand everything will work just like it did before. As the TypeScript compiler\nruns, it emits the corresponding <code>.js</code> file for every <code>.ts</code> file and the\ncompiled JavaScript is what actually gets executed. If you start\nthe project HTTP server with <code>npm start</code>, you should see the fully functional\napplication in your browser.</p>\n<p translation-result=\"\">我们要做的下一件事是把JavaScript文件转换成TypeScript文件。\n由于TypeScript是ECMAScript 2015的一个超集，而ES2015又是ECMAScript 5的超集，所以我们可以简单的把文件的扩展名从<code>.js</code>换成<code>.ts</code>，\n它们还是会像以前一样工作。由于TypeScript编译器仍在运行，它会为每一个<code>.ts</code>文件生成对应的<code>.js</code>文件，而真正运行的是编译后的<code>.js</code>文件。\n如果你用<code>npm start</code>开启了本项目的HTTP服务器，你会在浏览器中看到一个功能完好的应用。</p>\n<p translation-origin=\"off\">Now that you have TypeScript though, you can start benefiting from some of its\nfeatures. There's a lot of value the language can provide to AngularJS applications.</p>\n<p translation-result=\"\">有了TypeScript，我们就可以从它的一些特性中获益了。此语言可以为AngularJS应用提供很多价值。</p>\n<p translation-origin=\"off\">For one thing, TypeScript is a superset of ES2015. Any app that has previously\nbeen written in ES5 - like the PhoneCat example has - can with TypeScript\nstart incorporating all of the JavaScript features that are new to ES2015.\nThese include things like <code>let</code>s and <code>const</code>s, arrow functions, default function\nparameters, and destructuring assignments.</p>\n<p translation-result=\"\">首先，TypeScript是一个ES2015的超集。任何以前用ES5写的程序(就像PhoneCat范例)都可以开始通过TypeScript\n纳入那些添加到ES2015中的新特性。\n这包括<code>let</code>、<code>const</code>、箭头函数、函数默认参数以及解构(destructure)赋值。</p>\n<p translation-origin=\"off\">Another thing you can do is start adding <em>type safety</em> to your code. This has\nactually partially already happened because of the AngularJS typings you installed.\nTypeScript are checking that you are calling AngularJS APIs correctly when you do\nthings like register components to Angular modules.</p>\n<p translation-result=\"\">我们能做的另一件事就是把<em>类型安全</em>添加到代码中。这实际上已经部分完成了，因为我们已经安装了AngularJS的类型定义。\n当我们正确调用AngularJS的API时，TypeScript会帮我们检查它 —— 比如往Angular模块中注册组件。</p>\n<p translation-origin=\"off\">But you can also start adding <em>type annotations</em> to get even more\nout of TypeScript's type system. For instance, you can annotate the checkmark\nfilter so that it explicitly expects booleans as arguments. This makes it clearer\nwhat the filter is supposed to do.</p>\n<p translation-result=\"\">我们还能开始把<em>类型注解</em>添加到自己的代码中，来从TypeScript的类型系统中获得更多帮助。\n比如，我们可以给<code>checkmark</code>过滤器加上注解，表明它期待一个<code>boolean</code>类型的参数。\n这可以更清楚的表明此过滤器打算做什么</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/checkmark/checkmark.filter.ts\" title=\"app/core/checkmark/checkmark.filter.ts\">\nangular.\n  module('core').\n  filter('checkmark', function() {\n    return function(input: boolean) {\n      return input ? '\\u2713' : '\\u2718';\n    };\n  });\n\n\n</code-example>\n<p translation-origin=\"off\">In the <code>Phone</code> service, you can explicitly annotate the <code>$resource</code> service dependency\nas an <code>angular.resource.IResourceService</code> - a type defined by the AngularJS typings.</p>\n<p translation-result=\"\">在<code>Phone</code>服务中，我们可以明确的把<code>$resource</code>服务声明为<code>angular.resource.IResourceService</code>，一个AngularJS类型定义提供的类型。</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/core/phone/phone.service.ts\" title=\"app/core/phone/phone.service.ts\">\nangular.\n  module('core.phone').\n  factory('Phone', ['$resource',\n    function($resource: angular.resource.IResourceService) {\n      return $resource('phones/:phoneId.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>', {}, {\n        <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: {\n          method: 'GET',\n          params: {phoneId: 'phones'},\n          isArray: true\n        }\n      });\n    }\n  ]);\n\n\n</code-example>\n<p translation-result=\"\">You can apply the same trick to the application's route configuration file in <code>app.config.ts</code>,\nwhere you are using the location and route services. By annotating them accordingly TypeScript\ncan verify you're calling their APIs with the correct kinds of arguments.\n我们可以在应用的路由配置中使用同样的技巧，那里我们用到了location和route服务。\n一旦给它们提供了类型信息，TypeScript就能检查我们是否在用类型的正确参数来调用它们了。</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/app.config.ts\" title=\"app/app.config.ts\">\nangular.\n  module('phonecatApp').\n  config(['$locationProvider', '$routeProvider',\n    function config($locationProvider: angular.ILocationProvider,\n                    $routeProvider: angular.route.IRouteProvider) {\n      $locationProvider.hashPrefix('!');\n\n      $routeProvider.\n        when('/phones', {\n          template: '&#x3C;phone-list>&#x3C;/phone-list>'\n        }).\n        when('/phones/:phoneId', {\n          template: '&#x3C;phone-detail>&#x3C;/phone-detail>'\n        }).\n        otherwise('/phones');\n    }\n  ]);\n\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">The <a href=\"https://www.npmjs.com/package/@types/angular\">AngularJS 1.x type definitions</a>\nyou installed are not officially maintained by the Angular team,\nbut are quite comprehensive. It is possible to make an AngularJS 1.x application\nfully type-annotated with the help of these definitions.</p>\n<p translation-result=\"\">我们用typings工具安装的这个<a href=\"https://github.com/DefinitelyTyped/DefinitelyTyped/tree/master/angularjs\">AngularJS.x类型定义文件</a>\n并不是由Angular开发组维护的，但它也已经足够全面了。借助这些类型定义的帮助，它可以为AngularJS.x程序加上全面的类型注解。</p>\n<p translation-result=\"\">If this is something you wanted to do, it would be a good idea to enable\nthe <code>noImplicitAny</code> configuration option in <code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>. This would\ncause the TypeScript compiler to display a warning when there's any code that\ndoes not yet have type annotations. You could use it as a guide to inform\nus about how close you are to having a fully annotated project.\n如果我们想这么做，那么在<code>tsconfig.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>中启用<code>noImplicitAny</code>配置项就是一个好主意。\n这样，如果遇到什么还没有类型注解的代码，TypeScript编译器就会显示一个警告。\n我们可以用它作为指南，告诉我们现在与一个完全类型化的项目距离还有多远。</p>\n</div>\n<p translation-origin=\"off\">Another TypeScript feature you can make use of is <em>classes</em>. In particular, you\ncan turn component controllers into classes. That way they'll be a step\ncloser to becoming Angular component classes, which will make life\neasier once you upgrade.</p>\n<p translation-result=\"\">我们能用的另一个TypeScript特性是<em>类</em>。具体来讲，我们可以把控制器转换成类。\n这种方式下，我们离成为Angular组件类就又近了一步，它会令我们的升级之路变得更简单。</p>\n<p translation-origin=\"off\">AngularJS expects controllers to be constructor functions. That's exactly what\nES2015/TypeScript classes are under the hood, so that means you can just plug in a\nclass as a component controller and AngularJS will happily use it.</p>\n<p translation-result=\"\">AngularJS期望控制器是一个构造函数。这实际上就是ES2015/TypeScript中的类，\n这也就意味着只要我们把一个类注册为组件控制器，AngularJS就会愉快的使用它。Here's what the new class for the phone list component controller looks like:\n新的“电话列表(phone list)”组件控制器类是这样的：</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-list/phone-list.component.ts\" title=\"app/phone-list/phone-list.component.ts\">\nclass PhoneListController {\n  phones: any[];\n  orderProp: string;\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> = ['Phone'];\n  constructor(Phone: any) {\n    this.phones = Phone.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>();\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<p translation-origin=\"off\">What was previously done in the controller function is now done in the class\nconstructor function. The dependency injection annotations are attached\nto the class using a static property <code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>. At runtime this becomes the\n<code>PhoneListController.$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code> property.</p>\n<p translation-result=\"\">以前在控制器函数中实现的一切，现在都改由类的构造函数来实现了。类型注入注解通过静态属性<code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>\n被附加到了类上。在运行时，它们变成了<code>PhoneListController.$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>。</p>\n<p translation-origin=\"off\">The class additionally declares three members: The array of phones, the name of\nthe current sort key, and the search query. These are all things you have already\nbeen attaching to the controller but that weren't explicitly declared anywhere.\nThe last one of these isn't actually used in the TypeScript code since it's only\nreferred to in the template, but for the sake of clarity you should define all of the\ncontroller members.</p>\n<p translation-result=\"\">该类还声明了另外三个成员：电话列表、当前排序键的名字和搜索条件。\n这些东西我们以前就加到了控制器上，只是从来没有在任何地方显式定义过它们。最后一个成员从未真正在TypeScript代码中用过，\n因为它只是在模板中被引用过。但为了清晰起见，我们还是应该定义出此控制器应有的所有成员。</p>\n<p translation-origin=\"off\">In the Phone detail controller, you'll have two members: One for the phone\nthat the user is looking at and another for the URL of the currently displayed image:</p>\n<p translation-result=\"\">在电话详情控制器中，我们有两个成员：一个是用户正在查看的电话，另一个是正在显示的图像：</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\nclass PhoneDetailController {\n  phone: any;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> = ['$routeParams', 'Phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, Phone: any) {\n    let phoneId = $routeParams['phoneId'];\n    this.phone = Phone.get({phoneId}, (phone: any) => {\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p translation-origin=\"off\">This makes the controller code look a lot more like Angular already. You're\nall set to actually introduce Angular into the project.</p>\n<p translation-result=\"\">这已经让我们的控制器代码看起来更像Angular了。我们的准备工作做好了，可以引进Angular到项目中了。</p>\n<p translation-origin=\"off\">If you had any AngularJS services in the project, those would also be\na good candidate for converting to classes, since like controllers,\nthey're also constructor functions. But you only have the <code>Phone</code> factory\nin this project, and that's a bit special since it's an <code>ngResource</code>\nfactory. So you won't be doing anything to it in the preparation stage.\nYou'll instead turn it directly into an Angular service.</p>\n<p translation-result=\"\">如果项目中有任何AngularJS的服务，它们也是转换成类的优秀候选人，像控制器一样，它们也是构造函数。\n但是在本项目中，我们只有一个<code>Phone</code>工厂，这有点特别，因为它是一个<code>ngResource</code>工厂。\n所以我们不会在准备阶段中处理它，而是在下一节中直接把它转换成Angular服务。</p>\n<h3 translation-origin=\"off\" id=\"installing-angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#installing-angular\"><i class=\"material-icons\">link</i></a>Installing Angular</h3>\n<h3 translation-result=\"\" id=\"安装angular\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#安装angular\"><i class=\"material-icons\">link</i></a>安装Angular</h3>\n<p translation-origin=\"off\">Having completed the preparation work, get going with the Angular\nupgrade of PhoneCat. You'll do this incrementally with the help of\n<a href=\"guide/upgrade#upgrading-with-ngupgrade\">ngUpgrade</a> that comes with Angular.\nBy the time you're done, you'll be able to remove AngularJS from the project\ncompletely, but the key is to do this piece by piece without breaking the application.</p>\n<p translation-result=\"\">我们已经完成了准备工作，接下来就开始把PhoneCat升级到Angular。\n我们将在Angular<a href=\"guide/upgrade#upgrading-with-ngupgrade\">升级模块</a>的帮助下增量式的完成此项工作。\n等我们完成的那一刻，就能把AngularJS从项目中完全移除了，但其中的关键是在不破坏此程序的前提下一小块一小块的完成它。</p>\n<div class=\"alert is-important\">\n<p translation-origin=\"off\">The project also contains some animations.\nYou won't upgrade them in this version of the guide.\nTurn to the <a href=\"guide/animations\">Angular animations</a> guide to learn about that.</p>\n<p translation-result=\"\">该项目还包含一些动画，在此指南的当前版本我们先不升级它，等到后面的发行版再改。</p>\n</div>\n<p translation-origin=\"off\">Install Angular into the project, along with the SystemJS module loader.\nTake a look at the results of the <a href=\"guide/setup\">Setup</a> instructions\nand get the following configurations from there:</p>\n<p translation-result=\"\">我们来使用SystemJS模块加载器把Angular安装到项目中。\n看看<a href=\"guide/setup\">搭建本地开发环境</a>中的指南，并从那里获得如下配置：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">Add Angular and the other new dependencies to <code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code></p>\n<p translation-result=\"\">把Angular和其它新依赖添加到<code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>中</p>\n</li>\n<li>\n<p translation-origin=\"off\">The SystemJS configuration file <code>systemjs.config.js</code> to the project root directory.</p>\n<p translation-result=\"\">把SystemJS的配置文件<code>systemjs.config.js</code>添加到项目的根目录。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Once these are done, run:</p>\n<p translation-result=\"\">这些完成之后，就运行：</p>\n<code-example format=\"\">\n  npm install\n</code-example>\n<p translation-origin=\"off\">Soon you can load Angular dependencies into the application via <code>index.html</code>,\nbut first you need to do some directory path adjustments.\nYou'll need to load files from <code>node_modules</code> and the project root instead of\nfrom the <code>/app</code> directory as you've been doing to this point.</p>\n<p translation-result=\"\">我们可以通过<code>index.html</code>来把Angular的依赖快速加载到应用中，\n但首先，我们得做一些目录结构调整。这是因为我们正准备从<code>node_modules</code>中加载文件，然而目前项目中的每一个文件都是从<code>/app</code>目录下加载的。</p>\n<p translation-origin=\"off\">Move the <code>app/index.html</code> file to the project root directory. Then change the\ndevelopment server root path in <code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> to also point to the project root\ninstead of <code>app</code>:</p>\n<p translation-result=\"\">把<code>app/index.html</code>移入项目的根目录，然后把<code>package.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>中的开发服务器根目录也指向项目的根目录，而不再是<code>app</code>目录：</p>\n<code-example format=\"\">\n  \"start\": \"http-server ./ -a localhost -p 8000 -c-1\",\n</code-example>\n<p translation-origin=\"off\">Now you're able to serve everything from the project root to the web browser. But you do <em>not</em>\nwant to have to change all the image and data paths used in the application code to match\nthe development setup. For that reason, you'll add a <code>&#x3C;base></code> tag to <code>index.html</code>, which will\ncause relative URLs to be resolved back to the <code>/app</code> directory:</p>\n<p translation-result=\"\">现在，我们能把项目根目录下的每一样东西发给浏览器了。但我们不想为了适应开发环境中的设置，被迫修改应用代码中用到的所有图片和数据的路径。因此，我们往<code>index.html</code>中添加一个<code>&#x3C;base></code>标签，它将导致各种相对路径被解析回<code>/app</code>目录：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"base\" title=\"index.html\">\n&#x3C;base href=\"/app/\">\n\n</code-example>\n<p translation-origin=\"off\">Now you can load Angular via SystemJS. You'll add the Angular polyfills and the\nSystemJS config to the end of the <code>&#x3C;head></code> section, and then you'll use <code>System.import</code>\nto load the actual application:</p>\n<p translation-result=\"\">现在我们可以通过SystemJS加载Angular了。我们将把Angular的填充库(polyfills)\n和SystemJS的配置加到<code>&#x3C;head></code>区的末尾，然后，我们就用<code>System.import</code>来加载实际的应用：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/index.html\" region=\"angular\" title=\"index.html\">\n&#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/zone.js/dist/zone.js\">&#x3C;/script>\n&#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n&#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n&#x3C;script>\n  System.import('/app');\n&#x3C;/script>\n\n</code-example>\n<p translation-origin=\"off\">You also need to make a couple of adjustments\nto the <code>systemjs.config.js</code> file installed during <a href=\"guide/setup\">setup</a>.</p>\n<p translation-result=\"\">我们还需要对<a href=\"guide/setup\">环境设置</a>期间安装的<code>systemjs.config.js</code>文件做一些调整。</p>\n<p translation-origin=\"off\">Point the browser to the project root when loading things through SystemJS,\ninstead of using the  <code>&#x3C;base></code> URL.</p>\n<p translation-result=\"\">我们要在通过SystemJS加载期间为浏览器指出项目的根在哪里，而不再使用<code>&#x3C;base></code> URL。</p>\n<p translation-origin=\"off\">Install the <code>upgrade</code> package via <code>npm install @angular/upgrade --save</code>\nand add a mapping for the <code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> package.</p>\n<p translation-result=\"\">我们还要通过<code>npm install @angular/upgrade --save</code>来安装<code>upgrade</code>包，并为<code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>包添加一个映射。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/systemjs.config.1.js\" region=\"paths\" title=\"systemjs.config.js\">\n  System.config({\n    paths: {\n      // paths serve as alias\n      'npm:': '/node_modules/'\n    },\n    map: {\n      'ng-loader': '../src/systemjs-angular-loader.js',\n      app: '/app',\n/* . . . */\n      '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>': 'npm:@angular/upgrade/bundles/upgrade-<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>.umd.js',\n/* . . . */\n    },\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"creating-the-appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#creating-the-appmodule\"><i class=\"material-icons\">link</i></a>Creating the <em>AppModule</em></h3>\n<h3 translation-result=\"\" id=\"创建appmodule\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#创建appmodule\"><i class=\"material-icons\">link</i></a>创建<em>AppModule</em></h3>\n<p translation-origin=\"off\">Now create the root <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class called <code>AppModule</code>.\nThere is already a file named <code>app.module.ts</code> that holds the AngularJS module.\nRename it to <code>app.module.ajs.ts</code> and update the corresponding script name in the <code>index.html</code> as well.\nThe file contents remain:</p>\n<p translation-result=\"\">现在，创建一个名叫<code>AppModule</code>的根<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>类。\n我们已经有了一个名叫<code>app.module.ts</code>的文件，其中存放着AngularJS的模块。\n把它改名为<code>app.module.ng1.ts</code>，同时也要在<code>index.html</code>中更新对应的脚本名。\n文件的内容保留：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ajs.ts\" title=\"app.module.ajs.ts\">\n'use strict';\n\n// Define the `phonecatApp` AngularJS module\nangular.module('phonecatApp', [\n  'ngAnimate',\n  'ngRoute',\n  'core',\n  'phoneDetail',\n  'phoneList',\n]);\n\n\n</code-example>\n<p translation-origin=\"off\">Now create a new <code>app.module.ts</code> with the minimum <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> class:</p>\n<p translation-result=\"\">然后创建一个新的<code>app.module.ts</code>文件，其中是一个最小化的<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>类：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"bare\" title=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n  ],\n})\nexport class AppModule {\n}\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"bootstrapping-a-hybrid-phonecat\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#bootstrapping-a-hybrid-phonecat\"><i class=\"material-icons\">link</i></a>Bootstrapping a hybrid PhoneCat</h3>\n<h3 translation-result=\"\" id=\"引导phonecat的12混合式应用\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#引导phonecat的12混合式应用\"><i class=\"material-icons\">link</i></a>引导PhoneCat的1+2混合式应用</h3>\n<p translation-origin=\"off\">Next, you'll bootstrap the application as a <em>hybrid application</em>\nthat supports both AngularJS and Angular components. After that,\nyou can start converting the individual pieces to Angular.</p>\n<p translation-result=\"\">接下来，我们把该应用程序引导改装为一个同时支持AngularJS和Angular的<em>混合式应用</em>。\n然后，就能开始把这些不可分割的小块转换到Angular了。</p>\n<p translation-origin=\"off\">The application is currently bootstrapped using the AngularJS <code>ng-app</code> directive\nattached to the <code>&#x3C;html></code> element of the host page. This will no longer work in the hybrid\napp. Switch to the <a href=\"guide/upgrade#bootstrapping-hybrid-applications\">ngUpgrade bootstrap</a> method\ninstead.</p>\n<p translation-result=\"\">我们的应用现在是使用宿主页面中附加到<code>&#x3C;html></code>元素上的<code>ng-app</code>指令引导的。\n但在混合式应用中，它不再工作了。我们得用<a href=\"guide/upgrade#bootstrapping-hybrid-applications\">ngUpgrade bootstrap</a>方法代替。</p>\n<p translation-origin=\"off\">First, remove the <code>ng-app</code> attribute from <code>index.html</code>.\nThen import <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> in the <code>AppModule</code>, and override it's <code>ngDoBootstrap</code> method:</p>\n<p translation-result=\"\">首先，从<code>index.html</code>中移除<code>ng-app</code>。然后在<code>AppModule</code>中导入<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>，并改写它的<code>ngDoBootstrap</code>方法：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"upgrademodule\" title=\"app/app.module.ts\">\nimport { <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Note that you are bootstrapping the AngularJS module from inside <code>ngDoBootstrap</code>.\nThe arguments are the same as you would pass to <code>angular.bootstrap</code> if you were manually\nbootstrapping AngularJS: the root element of the application; and an array of the\nAngularJS 1.x modules that you want to load.</p>\n<p translation-result=\"\">注意，我们正在从内部的<code>ngDoBootstrap</code>中引导 AngularJS 模块。\n它的参数和我们在手动引导AngularJS时传给<code>angular.bootstrap</code>的是一样的：应用的根元素，和所要加载的 AngularJS 1.x 模块的数组。</p>\n<p translation-origin=\"off\">Finally, bootstrap the <code>AppModule</code> in <code>src/main.ts</code>.\nThis file has been configured as the application entrypoint in <code>systemjs.config.js</code>,\nso it is already being loaded by the browser.</p>\n<p translation-result=\"\">最后，在<code>src/main.ts</code>中引导这个<code>AppModule</code>。该文件在<code>systemjs.config.js</code>中被配置为了应用的入口，所以它已经被加载进了浏览器中。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main.ts\" region=\"bootstrap\" title=\"app/main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic';\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n</code-example>\n<p translation-origin=\"off\">Now you're running both AngularJS and Angular at the same time. That's pretty\nexciting! You're not running any actual Angular components yet. That's next.</p>\n<p translation-result=\"\">现在，我们同时运行着AngularJS和Angular。漂亮！不过我们还没有运行什么实际的Angular组件，接下来我们就做这件事。</p>\n<div class=\"l-sub-section\">\n<h4 translation-origin=\"off\" id=\"why-declare-angular-as-angulariangularstatic\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#why-declare-angular-as-angulariangularstatic\"><i class=\"material-icons\">link</i></a>Why declare <em>angular</em> as <em>angular.IAngularStatic</em>?</h4>\n<h4 translation-result=\"\" id=\"为何要声明angular为angulariangularstatic？\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#为何要声明angular为angulariangularstatic？\"><i class=\"material-icons\">link</i></a>为何要声明<em>angular</em>为<em>angular.IAngularStatic</em>？</h4>\n<p translation-origin=\"off\"><code>@types/angular</code> is declared as a UMD module, and due to the way\n<a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\">UMD typings</a>\nwork, once you have an ES6 <code>import</code> statement in a file all UMD typed modules must also be\nimported via <code>import</code> statements instead of being globally available.</p>\n<p translation-result=\"\"><code>@types/angular</code>声明为UMD模块，根据<a href=\"https://github.com/Microsoft/TypeScript/wiki/What&#x27;s-new-in-TypeScript#support-for-umd-module-definitions\" target=\"_blank\">UMD类型</a>\n的工作方式，一旦你在文件中有一条ES6的<code>import</code>语句，所有的UMD类型化的模型必须都通过<code>import</code>语句导入，\n而是不是全局可用。</p>\n<p translation-origin=\"off\">AngularJS is currently loaded by a script tag in <code>index.html</code>, which means that the whole app\nhas access to it as a global and uses the same instance of the <code>angular</code> variable.\nIf you used <code>import * as angular from 'angular'</code> instead, you'd also have to\nload every file in the AngularJS app to use ES2015 modules in order to ensure AngularJS was being\nloaded correctly.</p>\n<p translation-result=\"\">AngularJS是日前是通过<code>index.html</code>中的script标签加载，这意味着整个应用是作为一个全局变量进行访问的，\n使用同一个<code>angular</code>变量的实例。\n但如果我们使用<code>import * as angular from 'angular'</code>，我还需要彻底修改AngularJS应用中加载每个文件的方式，\n确保AngularJS应用被正确加载。</p>\n<p translation-origin=\"off\">This is a considerable effort and it often isn't worth it, especially since you are in the\nprocess of moving your code to Angular.\nInstead, declare <code>angular</code> as <code>angular.IAngularStatic</code> to indicate it is a global variable\nand still have full typing support.</p>\n<p translation-result=\"\">这需要相当多的努力，通常也不值得去做，特别是我们的应用正在朝着Angular前进。\n但如果我们声明<code>angular</code>为<code>angular.IAngularStatic</code>，指明它是一个全局变量，\n仍然可以获得全面的类型支持。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"upgrading-the-phone-service\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-the-phone-service\"><i class=\"material-icons\">link</i></a>Upgrading the Phone service</h3>\n<h3 translation-result=\"\" id=\"升级phone服务\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#升级phone服务\"><i class=\"material-icons\">link</i></a>升级<code>Phone</code>服务</h3>\n<p translation-origin=\"off\">The first piece you'll port over to Angular is the <code>Phone</code> service, which\nresides in <code>app/core/phone/phone.service.ts</code> and makes it possible for components\nto load phone information from the server. Right now it's implemented with\nngResource and you're using it for two things:</p>\n<p translation-result=\"\">我们要移植到Angular的第一块是<code>Phone</code>工厂(位于<code>app/js/core/phones.factory.ts</code>)，\n并且让它能帮助控制器从服务器上加载电话信息。目前，它是用<code>ngResource</code>实现的，我们用它做两件事：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">For loading the list of all phones into the phone list component.</p>\n<p translation-result=\"\">把所有电话的列表加载到电话列表组件中。</p>\n</li>\n<li>\n<p translation-origin=\"off\">For loading the details of a single phone into the phone detail component.</p>\n<p translation-result=\"\">把一台电话的详情加载到电话详情组件中。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">You can replace this implementation with an Angular service class, while\nkeeping the controllers in AngularJS land.</p>\n<p translation-result=\"\">我们可以用Angular的服务类来替换这个实现，而把控制器继续留在AngularJS的地盘上。</p>\n<p translation-origin=\"off\">In the new version, you import the Angular HTTP module and call its <code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code> service instead of <code>ngResource</code>.</p>\n<p translation-result=\"\">在这个新版本中，我们导入了Angular的HTTP模块，并且用它的<code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code>服务替换掉<code>NgResource</code>。</p>\n<p translation-origin=\"off\">Re-open the <code>app.module.ts</code> file, import and add <code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code> to the <code>imports</code> array of the <code>AppModule</code>:</p>\n<p translation-result=\"\">再次打开<code>app.module.ts</code>文件，导入并把<code><a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a></code>添加到<code>AppModule</code>的<code>imports</code>数组中：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"httpmodule\" title=\"app.module.ts\">\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> } from '@angular/http';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n  ],\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Now you're ready to upgrade the Phone service itself. Replace the ngResource-based\nservice in <code>phone.service.ts</code> with a TypeScript class decorated as <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>:</p>\n<p translation-result=\"\">现在，我们已经准备好了升级<code>Phones</code>服务本身。我们将为<code>phone.service.ts</code>文件中基于ngResource的服务加上<code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>装饰器：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"classdef\" title=\"app/core/phone/phone.service.ts (skeleton)\" linenums=\"false\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\n</code-example>\n<p translation-origin=\"off\">The <code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code> decorator will attach some dependency injection metadata\nto the class, letting Angular know about its dependencies. As described\nby the <a href=\"guide/dependency-injection\">Dependency Injection Guide</a>,\nthis is a marker decorator you need to use for classes that have no other\nAngular decorators but still need to have their dependencies injected.</p>\n<p translation-result=\"\"><code>@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a></code>装饰器将把一些依赖注入相关的元数据附加到该类上，让Angular知道它的依赖信息。\n就像在<a href=\"guide/dependency-injection\">依赖注入指南</a>中描述过的那样，\n这是一个标记装饰器，我们要把它用在那些没有其它Angular装饰器，并且自己有依赖注入的类上。</p>\n<p translation-origin=\"off\">In its constructor the class expects to get the <code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code> service. It will\nbe injected to it and it is stored as a private field. The service is then\nused in the two instance methods, one of which loads the list of all phones,\nand the other loads the details of a specified phone:</p>\n<p translation-result=\"\">在它的构造函数中，该类期待一个<code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code>服务。<code><a href=\"api/http/Http\" class=\"code-anchor\">Http</a></code>服务将被注入进来并存入一个私有字段。\n然后该服务在两个实例方法中被使用到，一个加载所有电话的列表，另一个加载一台指定电话的详情：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"fullclass\" title=\"app/core/phone/phone.service.ts\">\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get(`phones/phones.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>`)\n      .map((res: <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>) => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>());\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get(`phones/${id}.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>`)\n      .map((res: <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>) => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>());\n  }\n}\n\n</code-example>\n<p translation-result=\"\">The methods now return Observables of type <code>PhoneData</code> and <code>PhoneData[]</code>. This is\na type you don't have yet. Add a simple interface for it:\n该方法现在返回一个<code>Phone</code>类型或<code>Phone[]</code>类型的可观察对象(Observable)。\n这是一个我们从未用过的类型，因此我们得为它新增一个简单的接口：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"phonedata-interface\" title=\"app/core/phone/phone.service.ts (interface)\" linenums=\"false\">\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n</code-example>\n<p translation-origin=\"off\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code> has a <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code> method for the purpose of making\nAngular services available to AngularJS code. Use it to plug in the <code>Phone</code> service:</p>\n<p translation-result=\"\"><code>@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a></code>有一个<code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a></code>方法，可以使Angular服务在AngularJS的代码中可用。\n使用它来插入<code>Phone</code>服务：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" region=\"downgrade-injectable\" title=\"app/core/phone/phone.service.ts (downgrade)\" linenums=\"false\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n/* . . . */\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n/* . . . */\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n</code-example>\n<p translation-origin=\"off\">Here's the full, final code for the service:</p>\n<p translation-result=\"\">最终，该类的全部代码如下：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.ts\" title=\"app/core/phone/phone.service.ts\">\nimport { <a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a> } from '@angular/core';\nimport { <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>, <a href=\"api/http/Response\" class=\"code-anchor\">Response</a> } from '@angular/http';\nimport { Observable } from 'rxjs/Rx';\n\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport 'rxjs/add/operator/map';\n\nexport interface PhoneData {\n  name: string;\n  snippet: string;\n  images: string[];\n}\n\n@<a href=\"api/core/Injectable\" class=\"code-anchor\">Injectable</a>()\nexport class Phone {\n  constructor(private http: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>) { }\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return this.http.get(`phones/phones.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>`)\n      .map((res: <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>) => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>());\n  }\n  get(id: string): Observable&#x3C;PhoneData> {\n    return this.http.get(`phones/${id}.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>`)\n      .map((res: <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>) => res.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>());\n  }\n}\n\nangular.module('core.phone')\n  .factory('phone', <a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>(Phone));\n\n\n</code-example>\n<p translation-origin=\"off\">Notice that you're importing the <code>map</code> operator of the RxJS <code>Observable</code> separately.\nDo this for every RxJS operator.</p>\n<p translation-result=\"\">注意，我们单独导入了RxJS <code>Observable</code>中的<code>map</code>操作符。\n我们需要对想用的所有RxJS操作符这么做，因为Angular默认不会加载所有RxJS操作符。The new <code>Phone</code> service has the same features as the original, <code>ngResource</code>-based service.\nBecause it's an Angular service, you register it with the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> providers:\n这个新的<code>Phone</code>服务具有和老的基于<code>ngResource</code>的服务相同的特性。\n因为它是Angular服务，我们通过<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的<code>providers</code>数组来注册它：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phone\" title=\"app.module.ts\">\nimport { Phone } from './core/phone/phone.service';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n  ],\n  providers: [\n    Phone,\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Now that you are loading <code>phone.service.ts</code> through an import that is resolved\nby SystemJS, you should <strong>remove the &#x3C;script> tag</strong> for the service from <code>index.html</code>.\nThis is something you'll do to all components as you upgrade them. Simultaneously\nwith the AngularJS to Angular upgrade you're also migrating code from scripts to modules.</p>\n<p translation-result=\"\">现在，我们正在用SystemJS加载<code>phone.service.ts</code>，我们应该从<code>index.html</code>中<strong>移除该服务的<code>&#x3C;script></code>标签</strong>。\n这也是我们在升级所有组件时将会做的事。在从AngularJS向Angular升级的同时，我们也把代码从脚本移植为模块。</p>\n<p translation-origin=\"off\">At this point, you can switch the two components to use the new service\ninstead of the old one.  While you <code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code> it as the downgraded <code>phone</code> factory,\nit's really an instance of the <code>Phone</code> class and you annotate its type accordingly:</p>\n<p translation-result=\"\">这时，我们可以把两个控制器从使用老的服务切换成使用新的。我们像降级过的<code>phones</code>工厂一样<code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>它，\n但它实际上是一个<code>Phones</code>类的实例，并且我们可以据此注解它的类型：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ajs.ts\" title=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneListController {\n  phones: PhoneData[];\n  orderProp: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> = ['phone'];\n  constructor(phone: Phone) {\n    phone.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n\n}\n\nangular.\n  module('phoneList').\n  component('phoneList', {\n    templateUrl: 'app/phone-list/phone-list.template.html',\n    controller: PhoneListController\n  });\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ajs.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass PhoneDetailController {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  <a href=\"api/upgrade/static\" class=\"code-anchor\">static</a> $<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a> = ['$routeParams', 'phone'];\n  constructor($routeParams: angular.route.IRouteParamsService, phone: Phone) {\n    let phoneId = $routeParams['phoneId'];\n    phone.get(phoneId).subscribe(data => {\n      this.phone = data;\n      this.setImage(data.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.\n  module('phoneDetail').\n  component('phoneDetail', {\n    templateUrl: 'phone-detail/phone-detail.template.html',\n    controller: PhoneDetailController\n  });\n\n\n</code-example>\n<p translation-origin=\"off\">Now there are two AngularJS components using an Angular service!\nThe components don't need to be aware of this, though the fact that the\nservice returns Observables and not Promises is a bit of a giveaway.\nIn any case, what you've achieved is a migration of a service to Angular\nwithout having to yet migrate the components that use it.</p>\n<p translation-result=\"\">这里的两个AngularJS控制器在使用Angular的服务！控制器不需要关心这一点，尽管实际上该服务返回的是可观察对象(Observable)，而不是承诺(Promise)。\n无论如何，我们达到的效果都是把服务移植到Angular，而不用被迫移植组件来使用它。</p>\n<div class=\"alert is-helpful\">\n<p translation-result=\"\">You could  use the <code>toPromise</code> method of <code>Observable</code> to turn those\nObservables into Promises in the service. In many cases that\nreduce the number of changes to the component controllers.\n我们也能使用<code>Observable</code>的<code>toPromise</code>方法来在服务中把这些可观察对象转变成承诺，以进一步减小组件控制器中需要修改的代码量。</p>\n</div>\n<h3 translation-origin=\"off\" id=\"upgrading-components\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#upgrading-components\"><i class=\"material-icons\">link</i></a>Upgrading Components</h3>\n<h3 translation-result=\"\" id=\"升级组件\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#升级组件\"><i class=\"material-icons\">link</i></a>升级组件</h3>\n<p translation-origin=\"off\">Upgrade the AngularJS components to Angular components next.\nDo it one component at a time while still keeping the application in hybrid mode.\nAs you make these conversions, you'll also define your first Angular <em>pipes</em>.</p>\n<p translation-result=\"\">接下来，我们把AngularJS的控制器升级成Angular的组件。我们每次升级一个，同时仍然保持应用运行在混合模式下。\n在做转换的同时，我们还将自定义首个Angular<em>管道</em>。</p>\n<p translation-origin=\"off\">Look at the phone list component first. Right now it contains a TypeScript\ncontroller class and a component definition object. You can morph this into\nan Angular component by just renaming the controller class and turning the\nAngularJS component definition object into an Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code> decorator.\nYou can then also remove the static <code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code> property from the class:</p>\n<p translation-result=\"\">让我们先看看电话列表组件。它目前包含一个TypeScript控制器类和一个组件定义对象。重命名控制器类，\n并把AngularJS的组件定义对象更换为Angular <code>@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a></code>装饰器，这样我们就把它变形为Angular\n的组件了。然后，我们还从类中移除静态<code>$<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a></code>属性。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"initialclass\" title=\"app/phone-list/phone-list.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n  phones: PhoneData[];\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>: string;\n  orderProp: string;\n\n  constructor(phone: Phone) {\n    phone.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>().subscribe(phones => {\n      this.phones = phones;\n    });\n    this.orderProp = 'age';\n  }\n/* . . . */\n}\n\n</code-example>\n<p translation-origin=\"off\">The <code>selector</code> attribute is a CSS selector that defines where on the page the component\nshould go. In AngularJS you do matching based on component names, but in Angular you\nhave these explicit selectors. This one will match elements with the name <code>phone-list</code>,\njust like the AngularJS version did.</p>\n<p translation-result=\"\"><code>selector</code>属性是一个CSS选择器，用来定义组件应该被放在页面的哪。在AngularJS，我们基于组件名字来匹配，\n但是在Angular中，我们要有一个专门指定的选择器。本组件将会对应元素名字<code>phone-list</code>，和AngularJS版本一样。</p>\n<p translation-origin=\"off\">Now convert the template of this component into Angular syntax.\nThe search controls replace the AngularJS <code>$ctrl</code> expressions\nwith Angular's two-way <code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code> binding syntax:</p>\n<p translation-result=\"\">现在，我们还需要将组件的模版也转换为Angular语法。在搜索控件中，我们要为把AngularJS的<code>$ctrl</code>表达式替换成Angular的双向绑定语法<code>[(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]</code>：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"controls\" title=\"app/phone-list/phone-list.template.html (search controls)\" linenums=\"false\">\n&#x3C;p>\n  Search:\n  &#x3C;input [(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]=\"<a href=\"api/animations/query\" class=\"code-anchor\">query</a>\" />\n&#x3C;/p>\n\n&#x3C;p>\n  Sort by:\n  &#x3C;select [(<a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a>)]=\"orderProp\">\n    &#x3C;<a href=\"api/forms/NgSelectOption\" class=\"code-anchor\">option</a> value=\"name\">Alphabetical&#x3C;/<a href=\"api/forms/NgSelectOption\" class=\"code-anchor\">option</a>>\n    &#x3C;<a href=\"api/forms/NgSelectOption\" class=\"code-anchor\">option</a> value=\"age\">Newest&#x3C;/<a href=\"api/forms/NgSelectOption\" class=\"code-anchor\">option</a>>\n  &#x3C;/select>\n&#x3C;/p>\n\n</code-example>\n<p translation-origin=\"off\">Replace the list's <code>ng-repeat</code> with an <code>*ngFor</code> as\n<a href=\"guide/template-syntax#directives\">described in the Template Syntax page</a>.\nReplace the image tag's <code>ng-src</code> with a binding to the native <code>src</code> property.</p>\n<p translation-result=\"\">我们需要把列表中的<code>ng-repeat</code>替换为<code>*ngFor</code>以及它的<code>let var of iterable</code>语法，\n该语法在<a href=\"guide/template-syntax#directives\">模板语法指南中讲过</a>。\n对于图片，我们可以把<code>img</code>标签的<code>ng-src</code>替换为一个标准的<code>src</code>属性(property)绑定。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.template.html\" region=\"list\" title=\"app/phone-list/phone-list.template.html (phones)\" linenums=\"false\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *ngFor=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a href=\"/#!/phones/{{phone.id}}\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<h4 translation-origin=\"off\" id=\"no-angular-filter-or-orderby-filters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#no-angular-filter-or-orderby-filters\"><i class=\"material-icons\">link</i></a>No Angular <em>filter</em> or <em>orderBy</em> filters</h4>\n<h4 translation-result=\"\" id=\"angular中没有filter或orderby过滤器\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#angular中没有filter或orderby过滤器\"><i class=\"material-icons\">link</i></a>Angular中没有<code>filter</code>或<code>orderBy</code>过滤器</h4>\n<p translation-origin=\"off\">The built-in AngularJS <code>filter</code> and <code>orderBy</code> filters do not exist in Angular,\nso you need to do the filtering and sorting yourself.</p>\n<p translation-result=\"\">Angular中并不存在AngularJS中内置的<code>filter</code>和<code>orderBy</code>过滤器。\n所以我们得自己实现进行过滤和排序。</p>\n<p translation-origin=\"off\">You replaced the <code>filter</code> and <code>orderBy</code> filters with bindings to the <code>getPhones()</code> controller method,\nwhich implements the filtering and ordering logic inside the component itself.</p>\n<p translation-result=\"\">我们把<code>filter</code>和<code>orderBy</code>过滤器改成绑定到控制器中的<code>getPhones()</code>方法，通过该方法，组件本身实现了过滤和排序逻辑。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"getphones\" title=\"app/phone-list/phone-list.component.ts\">\ngetPhones(): PhoneData[] {\n  return this.sortPhones(this.filterPhones(this.phones));\n}\n\nprivate filterPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>) {\n    return phones.filter(phone => {\n      let name = phone.name.toLowerCase();\n      let snippet = phone.snippet.toLowerCase();\n      return name.indexOf(this.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>) >= 0 || snippet.indexOf(this.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>) >= 0;\n    });\n  }\n  return phones;\n}\n\nprivate sortPhones(phones: PhoneData[]) {\n  if (phones &#x26;&#x26; this.orderProp) {\n    return phones\n      .<a href=\"api/common/SlicePipe\" class=\"code-anchor\">slice</a>(0) // Make a copy\n      .sort((a, b) => {\n        if (a[this.orderProp] &#x3C; b[this.orderProp]) {\n          return -1;\n        } else if ([b[this.orderProp] &#x3C; a[this.orderProp]]) {\n          return 1;\n        } else {\n          return 0;\n        }\n      });\n  }\n  return phones;\n}\n\n</code-example>\n<p translation-origin=\"off\">Now you need to downgrade the Angular component so you can use it in AngularJS.\nInstead of registering a component, you register a <code>phoneList</code> <em>directive</em>,\na downgraded version of the Angular component.</p>\n<p translation-result=\"\">现在我们需要降级我们的Angular组件，这样我们就可以在AngularJS中使用它。\n我们需要注册一个<code>phoneList</code><em>指令</em>，而不是注册一个组件，它是一个降级版的Angular组件。</p>\n<p translation-origin=\"off\">The <code>as angular.IDirectiveFactory</code> cast tells the TypeScript compiler\nthat the return value of the <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code> method is a directive factory.</p>\n<p translation-result=\"\">强制类型转换<code>as angular.IDirectiveFactory</code>告诉TypeScript编译器<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a></code>方法\n的返回值是一个指令工厂。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.ts\" region=\"downgrade-component\" title=\"app/phone-list/phone-list.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\n/* . . . */\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-list',\n  templateUrl: './phone-list.template.html'\n})\nexport class PhoneListComponent {\n/* . . . */\n}\n\nangular.module('phoneList')\n  .directive(\n    'phoneList',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneListComponent}) as angular.IDirectiveFactory\n  );\n\n</code-example>\n<p translation-result=\"\">The new <code>PhoneListComponent</code> uses the Angular <code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code> directive, located in the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>.\nAdd the <code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code> to <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> imports, declare the new <code>PhoneListComponent</code> and\nfinally add it to <code>entryComponents</code> since you downgraded it:\n新的<code>PhoneListComponent</code>使用Angular的<code><a href=\"api/forms/NgControlStatus\" class=\"code-anchor\">ngModel</a></code>指令，它位于<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>中。\n把<code><a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a></code>添加到<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的<code>imports</code>中，并声明新的<code>PhoneListComponent</code>组件，\n最后由我们把它降级了，添加到<code>entryComponents</code>：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonelist\" title=\"app.module.ts\">\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { PhoneListComponent } from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">Remove the &#x3C;script> tag for the phone list component from <code>index.html</code>.</p>\n<p translation-result=\"\">从<code>index.html</code>中移除电话列表组件的&#x3C;script>标签。</p>\n<p translation-origin=\"off\">Now set the remaining <code>phone-detail.component.ts</code> as follows:</p>\n<p translation-result=\"\">现在，剩下的<code>phone-detail.component.ts</code>文件变成了这样：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\ndeclare var angular: angular.IAngularStatic;\nimport { <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a> } from '@angular/upgrade/<a href=\"api/upgrade/static\" class=\"code-anchor\">static</a>';\n\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { RouteParams } from '../ajs-upgraded-providers';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html',\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(routeParams: RouteParams, phone: Phone) {\n    phone.get(routeParams['phoneId']).subscribe(phone => {\n      this.phone = phone;\n      this.setImage(phone.images[0]);\n    });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\nangular.module('phoneDetail')\n  .directive(\n    'phoneDetail',\n    <a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>({component: PhoneDetailComponent}) as angular.IDirectiveFactory\n  );\n\n\n</code-example>\n<p translation-origin=\"off\">This is similar to the phone list component.\nThe new wrinkle is the <code>RouteParams</code> type annotation that identifies the <code>routeParams</code> dependency.</p>\n<p translation-result=\"\">这和电话列表组件很相似。\n这里的窍门在于<code>@<a href=\"api/core/Inject\" class=\"code-anchor\">Inject</a></code>装饰器，它标记出了<code>$routeParams</code>依赖。</p>\n<p translation-origin=\"off\">The AngularJS injector has an AngularJS router dependency called <code>$routeParams</code>,\nwhich was injected into <code>PhoneDetails</code> when it was still an AngularJS controller.\nYou intend to inject it into the new <code>PhoneDetailsComponent</code>.</p>\n<p translation-result=\"\">AngularJS注入器具有AngularJS路由器的依赖，叫做<code>$routeParams</code>。\n它被注入到了<code>PhoneDetails</code>中，但<code>PhoneDetails</code>现在还是一个AngularJS控制器。\n我们应该把它注入到新的<code>PhoneDetailsComponent</code>中。</p>\n<p translation-origin=\"off\">Unfortunately, AngularJS dependencies are not automatically available to Angular components.\nYou must upgrade this service via a <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">factory provider</a>\nto make <code>$routeParams</code> an Angular injectable.\nDo that in a new file called <code>ajs-upgraded-providers.ts</code> and import it in <code>app.module.ts</code>:</p>\n<p translation-result=\"\">不幸的是，AngularJS的依赖不会自动在Angular的组件中可用。\n我们必须使用<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工厂提供商（factory provider）</a>\n来把<code>$routeParams</code>包装成Angular的服务提供商。\n新建一个名叫<code>ajs-upgraded-providers.ts</code>的文件，并且在<code>app.module.ts</code>中导入它：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/ajs-upgraded-providers.ts\" title=\"app/ajs-upgraded-providers.ts\">\nexport abstract class RouteParams {\n  [key: string]: string;\n}\n\nexport function routeParamsFactory(i: any) {\n  return i.get('$routeParams');\n}\n\nexport const routeParamsProvider = {\n  provide: RouteParams,\n  useFactory: routeParamsFactory,\n  deps: ['$injector']\n};\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"routeparams\" title=\"app/app.module.ts ($routeParams)\" linenums=\"false\">\nimport { routeParamsProvider } from './ajs-upgraded-providers';\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n\n</code-example>\n<p translation-origin=\"off\">Convert the phone detail component template into Angular syntax as follows:</p>\n<p translation-result=\"\">我们现在也要把该组件的模板转变成Angular的语法。\n这里是它完整的新模板：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.template.html\" title=\"app/phone-detail/phone-detail.template.html\">\n&#x3C;div *<a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a>=\"phone\">\n  &#x3C;div class=\"phone-images\">\n    &#x3C;img [src]=\"img\" class=\"phone\"\n        [<a href=\"api/common/NgClass\" class=\"code-anchor\">ngClass</a>]=\"{'selected': img === mainImageUrl}\"\n        *ngFor=\"let img of phone.images\" />\n  &#x3C;/div>\n\n  &#x3C;h1>{{phone.name}}&#x3C;/h1>\n\n  &#x3C;p>{{phone.description}}&#x3C;/p>\n\n  &#x3C;ul class=\"phone-thumbs\">\n    &#x3C;li *ngFor=\"let img of phone.images\">\n      &#x3C;img [src]=\"img\" (click)=\"setImage(img)\" />\n    &#x3C;/li>\n  &#x3C;/ul>\n\n  &#x3C;ul class=\"specs\">\n    &#x3C;li>\n      &#x3C;span>Availability and Networks&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Availability&#x3C;/dt>\n        &#x3C;dd *ngFor=\"let availability of phone.availability\">{{availability}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Battery&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt><a href=\"api/core/Type\" class=\"code-anchor\">Type</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.type}}&#x3C;/dd>\n        &#x3C;dt>Talk <a href=\"api/common/Time\" class=\"code-anchor\">Time</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.talkTime}}&#x3C;/dd>\n        &#x3C;dt>Standby time (max)&#x3C;/dt>\n        &#x3C;dd>{{phone.battery?.standbyTime}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Storage and Memory&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>RAM&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.ram}}&#x3C;/dd>\n        &#x3C;dt>Internal Storage&#x3C;/dt>\n        &#x3C;dd>{{phone.storage?.flash}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Connectivity&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Network Support&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.cell}}&#x3C;/dd>\n        &#x3C;dt>WiFi&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.wifi}}&#x3C;/dd>\n        &#x3C;dt>Bluetooth&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.bluetooth}}&#x3C;/dd>\n        &#x3C;dt>Infrared&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.infrared | checkmark}}&#x3C;/dd>\n        &#x3C;dt>GPS&#x3C;/dt>\n        &#x3C;dd>{{phone.connectivity?.gps | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Android&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>OS <a href=\"api/core/Version\" class=\"code-anchor\">Version</a>&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.os}}&#x3C;/dd>\n        &#x3C;dt>UI&#x3C;/dt>\n        &#x3C;dd>{{phone.android?.ui}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Size and Weight&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Dimensions&#x3C;/dt>\n        &#x3C;dd *ngFor=\"let dim of phone.sizeAndWeight?.dimensions\">{{dim}}&#x3C;/dd>\n        &#x3C;dt>Weight&#x3C;/dt>\n        &#x3C;dd>{{phone.sizeAndWeight?.weight}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Display&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Screen size&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenSize}}&#x3C;/dd>\n        &#x3C;dt>Screen resolution&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.screenResolution}}&#x3C;/dd>\n        &#x3C;dt>Touch screen&#x3C;/dt>\n        &#x3C;dd>{{phone.display?.touchScreen | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Hardware&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>CPU&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.cpu}}&#x3C;/dd>\n        &#x3C;dt>USB&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.usb}}&#x3C;/dd>\n        &#x3C;dt>Audio / headphone jack&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.audioJack}}&#x3C;/dd>\n        &#x3C;dt>FM Radio&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.fmRadio | checkmark}}&#x3C;/dd>\n        &#x3C;dt>Accelerometer&#x3C;/dt>\n        &#x3C;dd>{{phone.hardware?.accelerometer | checkmark}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Camera&#x3C;/span>\n      &#x3C;dl>\n        &#x3C;dt>Primary&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.primary}}&#x3C;/dd>\n        &#x3C;dt>Features&#x3C;/dt>\n        &#x3C;dd>{{phone.camera?.features?.join(', ')}}&#x3C;/dd>\n      &#x3C;/dl>\n    &#x3C;/li>\n    &#x3C;li>\n      &#x3C;span>Additional Features&#x3C;/span>\n      &#x3C;dd>{{phone.additionalFeatures}}&#x3C;/dd>\n    &#x3C;/li>\n  &#x3C;/ul>\n&#x3C;/div>\n\n\n</code-example>\n<p translation-origin=\"off\">There are several notable changes here:</p>\n<p translation-result=\"\">这里有几个值得注意的改动：</p>\n<ul>\n<li>\n<p translation-origin=\"off\">You've removed the <code>$ctrl.</code> prefix from all expressions.</p>\n<p translation-result=\"\">我们从所有表达式中移除了<code>$ctrl.</code>前缀。</p>\n</li>\n</ul>\n<ul>\n<li>\n<p translation-origin=\"off\">You've replaced <code>ng-src</code> with property\nbindings for the standard <code>src</code> property.</p>\n<p translation-result=\"\">正如我们在电话列表中做过的那样，我们把<code>ng-src</code>替换成了标准的<code>src</code>属性绑定。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You're using the property binding syntax around <code>ng-class</code>. Though Angular\ndoes have <a href=\"guide/template-syntax#directives\">a very similar <code>ngClass</code></a>\nas AngularJS does, its value is not magically evaluated as an expression.\nIn Angular, you always specify  in the template when an attribute's value is\na property expression, as opposed to a literal string.</p>\n<p translation-result=\"\">我们在<code>ng-class</code>周围使用了属性绑定语法。虽然Angular中有一个\n和AngularJS中<a href=\"guide/template-syntax#directives\">非常相似的<code>ngClass</code></a>指令，\n但是它的值不会神奇的作为表达式进行计算。在Angular中，模板中的属性(Attribute)值总是被作为\n属性(Property)表达式计算，而不是作为字符串字面量。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You've replaced <code>ng-repeat</code>s with <code>*ngFor</code>s.</p>\n<p translation-result=\"\">我们把<code>ng-repeat</code>替换成了<code>*ngFor</code>。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You've replaced <code>ng-click</code> with an event binding for the standard <code>click</code>.</p>\n<p translation-result=\"\">我们把<code>ng-click</code>替换成了一个到标准<code>click</code>事件的绑定。</p>\n</li>\n<li>\n<p translation-origin=\"off\">You've wrapped the whole template in an <code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code> that causes it only to be\nrendered when there is a phone present. You need this because when the component\nfirst loads, you don't have <code>phone</code> yet and the expressions will refer to a\nnon-existing value. Unlike in AngularJS, Angular expressions do not fail silently\nwhen you try to refer to properties on undefined objects. You need to be explicit\nabout cases where this is expected.</p>\n<p translation-result=\"\">我们把整个模板都包裹进了一个<code><a href=\"api/common/NgIf\" class=\"code-anchor\">ngIf</a></code>中，这导致只有当存在一个电话时它才会渲染。我们必须这么做，\n是因为组件首次加载时我们还没有<code>phone</code>变量，这些表达式就会引用到一个不存在的值。\n和AngularJS不同，当我们尝试引用未定义对象上的属性时，Angular中的表达式不会默默失败。\n我们必须明确指出这种情况是我们所期望的。</p>\n</li>\n</ul>\n<p translation-origin=\"off\">Add <code>PhoneDetailComponent</code> component to the <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> <em>declarations</em> and <em>entryComponents</em>:</p>\n<p translation-result=\"\">把<code>PhoneDetailComponent</code>组件添加到<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>的<em>declarations</em>和<em>entryComponents</em>中：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"phonedetail\" title=\"app.module.ts\">\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<p translation-origin=\"off\">You should now also remove the phone detail component &#x3C;script> tag from <code>index.html</code>.</p>\n<p translation-result=\"\">我们现在应该从<code>index.html</code>中移除电话详情组件的&#x3C;script>。</p>\n<h4 translation-origin=\"off\" id=\"add-the-checkmarkpipe\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-checkmarkpipe\"><i class=\"material-icons\">link</i></a>Add the <em>CheckmarkPipe</em></h4>\n<h4 translation-result=\"\" id=\"添加checkmarkpipe\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加checkmarkpipe\"><i class=\"material-icons\">link</i></a>添加<em>CheckmarkPipe</em></h4>\n<p translation-origin=\"off\">The AngularJS directive had a <code>checkmark</code> <em>filter</em>.\nTurn that into an Angular <strong>pipe</strong>.</p>\n<p translation-result=\"\">AngularJS指令中有一个<code>checkmark</code><em>过滤器</em>，我们把它转换成Angular的<strong>管道</strong>。</p>\n<p translation-origin=\"off\">There is no upgrade method to convert filters into pipes.\nYou won't miss it.\nIt's easy to turn the filter function into an equivalent Pipe class.\nThe implementation is the same as before, repackaged in the <code>transform</code> method.\nRename the file to <code>checkmark.pipe.ts</code> to conform with Angular conventions:</p>\n<p translation-result=\"\">没有什么升级方法能把过滤器转换成管道。\n但我们也并不需要它。\n把过滤器函数转换成等价的Pipe类非常简单。\n实现方式和以前一样，但把它们包装进<code>transform</code>方法中就可以了。\n把该文件改名成<code>checkmark.pipe.ts</code>，以符合Angular中的命名约定：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.ts\" title=\"app/core/checkmark/checkmark.pipe.ts\" linenums=\"false\">\nimport { <a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>, <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> } from '@angular/core';\n\n@<a href=\"api/core/Pipe\" class=\"code-anchor\">Pipe</a>({name: 'checkmark'})\nexport class CheckmarkPipe implements <a href=\"api/core/PipeTransform\" class=\"code-anchor\">PipeTransform</a> {\n  transform(input: boolean) {\n    return input ? '\\u2713' : '\\u2718';\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">Now import and declare the newly created pipe and\nremove the filter &#x3C;script> tag from <code>index.html</code>:</p>\n<p translation-result=\"\">当我们做这个修改时，也要同时从<code>core</code>模块文件中移除对该过滤器的注册。该模块的内容变成了：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/app.module.ts\" region=\"checkmarkpipe\" title=\"app.module.ts\">\nimport { CheckmarkPipe } from './core/checkmark/checkmark.pipe';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n  ],\n  declarations: [\n    PhoneListComponent,\n    PhoneDetailComponent,\n    CheckmarkPipe\n  ],\n  entryComponents: [\n    PhoneListComponent,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone,\n    routeParamsProvider\n  ]\n})\nexport class AppModule {\n  constructor(private upgrade: <a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a>) { }\n  ngDoBootstrap() {\n    this.upgrade.bootstrap(document.documentElement, ['phonecatApp']);\n  }\n}\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"aot-compile-the-hybrid-app\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#aot-compile-the-hybrid-app\"><i class=\"material-icons\">link</i></a>AOT compile the hybrid app</h3>\n<h3 translation-result=\"\" id=\"对混合式应用做aot编译\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#对混合式应用做aot编译\"><i class=\"material-icons\">link</i></a>对混合式应用做AOT编译</h3>\n<p translation-origin=\"off\">To use AOT with a hybrid app, you have to first set it up like any other Angular application,\nas shown in <a href=\"guide/aot-compiler\">the Ahead-of-time Compilation chapter</a>.</p>\n<p translation-result=\"\">要在混合式应用中使用AOT编译，我们首先要像其它Angular应用一样设置它，就像<a href=\"guide/aot-compiler\">AOT编译一章</a>所讲的那样。</p>\n<p translation-origin=\"off\">Then change <code>main-aot.ts</code> to bootstrap the <code>AppComponentFactory</code> that was generated\nby the AOT compiler:</p>\n<p translation-result=\"\">然后，我们就要修改<code>main-aot.ts</code>的引导代码，通过所生成的<code>AppComponentFactory</code>来引导AngularJS应用：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/main-aot.ts\" title=\"app/main-aot.ts\">\nimport { <a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\n\nimport { AppModuleNgFactory } from '../aot/app/app.module.ngfactory';\n\n<a href=\"api/platform-browser/platformBrowser\" class=\"code-anchor\">platformBrowser</a>().bootstrapModuleFactory(AppModuleNgFactory);\n\n\n</code-example>\n<p translation-origin=\"off\">You need to load all the AngularJS files you already use in <code>index.html</code> in <code>aot/index.html</code>\nas well:</p>\n<p translation-result=\"\">我们还要把在<code>index.html</code>中已经用到的所有AngularJS文件加载到<code>aot/index.html</code>中：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/aot/index.html\" title=\"aot/index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n\n    &#x3C;base href=\"/app/\">\n\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.animations.css\" />\n\n    &#x3C;script src=\"https://code.jquery.com/jquery-2.2.4.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-animate.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-resource.js\">&#x3C;/script>\n    &#x3C;script src=\"https://code.angularjs.org/1.5.5/angular-route.js\">&#x3C;/script>\n\n    &#x3C;script src=\"app.module.ajs.js\">&#x3C;/script>\n    &#x3C;script src=\"app.config.js\">&#x3C;/script>\n    &#x3C;script src=\"app.animations.js\">&#x3C;/script>\n    &#x3C;script src=\"core/core.module.js\">&#x3C;/script>\n    &#x3C;script src=\"core/phone/phone.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-list/phone-list.module.js\">&#x3C;/script>\n    &#x3C;script src=\"phone-detail/phone-detail.module.js\">&#x3C;/script>\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/dist/zone.min.js\">&#x3C;/script>\n\n    &#x3C;script>window.module = 'aot';&#x3C;/script>\n  &#x3C;/head>\n\n  &#x3C;body>\n    &#x3C;div class=\"view-container\">\n      &#x3C;div ng-view class=\"view-frame\">&#x3C;/div>\n    &#x3C;/div>\n  &#x3C;/body>\n  &#x3C;script src=\"/dist/build.js\">&#x3C;/script>\n&#x3C;/html>\n\n\n</code-example>\n<p translation-origin=\"off\">These files need to be copied together with the polyfills. The files the application\nneeds at runtime, like the <code>.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code> phone lists and images, also need to be copied.</p>\n<p translation-result=\"\">这些文件要带着相应的填充库复制到一起。应用运行时需要的文件，比如电话列表<code>.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a></code>和图片，也需要复制过去。</p>\n<p translation-origin=\"off\">Install <code>fs-extra</code> via <code>npm install fs-extra --save-dev</code> for better file copying, and change\n<code>copy-dist-files.js</code> to the following:</p>\n<p translation-result=\"\">通过<code>npm install fs-extra --save-dev</code>安装<code>fs-extra</code>可以更好的复制文件，并且把<code>copy-dist-files.js</code>文件改成这样：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/copy-dist-files.js\" title=\"copy-dist-files.js\">\nvar fsExtra = require('fs-extra');\nvar resources = [\n  // polyfills\n  'node_modules/core-js/client/shim.min.js',\n  'node_modules/zone.js/dist/zone.min.js',\n  // css\n  'app/app.css',\n  'app/app.animations.css',\n  // images and <a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a> files\n  'app/img/',\n  'app/phones/',\n  // app files\n  'app/app.module.ajs.js',\n  'app/app.config.js',\n  'app/app.animations.js',\n  'app/core/core.module.js',\n  'app/core/phone/phone.module.js',\n  'app/phone-list/phone-list.module.js',\n  'app/phone-detail/phone-detail.module.js'\n];\nresources.map(function(sourcePath) {\n  var destPath = `aot/${sourcePath}`;\n  fsExtra.copySync(sourcePath, destPath);\n});\n\n\n</code-example>\n<p translation-result=\"\">And that's all you need to use AOT while upgrading your app!\n这就是想要在升级应用期间AOT编译所需的一切！</p>\n<h3 translation-origin=\"off\" id=\"adding-the-angular-router-and-bootstrap\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#adding-the-angular-router-and-bootstrap\"><i class=\"material-icons\">link</i></a>Adding The Angular Router And Bootstrap</h3>\n<h3 translation-result=\"\" id=\"添加angular路由器和引导程序\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加angular路由器和引导程序\"><i class=\"material-icons\">link</i></a>添加Angular路由器和引导程序</h3>\n<p translation-origin=\"off\">At this point, you've replaced all AngularJS application components with\ntheir Angular counterparts, even though you're still serving them from the AngularJS router.</p>\n<p translation-result=\"\">此刻，我们已经把所有AngularJS的组件替换成了它们在Angular中的等价物，不过我们仍然在AngularJS路由器中使用它们。</p>\n<h4 translation-origin=\"off\" id=\"add-the-angular-router\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#add-the-angular-router\"><i class=\"material-icons\">link</i></a>Add the Angular router</h4>\n<h4 translation-result=\"\" id=\"添加angular路由器\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#添加angular路由器\"><i class=\"material-icons\">link</i></a>添加Angular路由器</h4>\n<p translation-origin=\"off\">Angular has an <a href=\"guide/router\">all-new router</a>.</p>\n<p translation-result=\"\">Angular有一个<a href=\"guide/router\">全新的路由器</a>。</p>\n<p translation-origin=\"off\">Like all routers, it needs a place in the UI to display routed views.\nFor Angular that's the <code>&#x3C;router-outlet></code> and it belongs in a <em>root component</em>\nat the top of the applications component tree.</p>\n<p translation-result=\"\">像所有的路由器一样，它需要在UI中指定一个位置来显示路由的视图。\n在Angular中，它是<code>&#x3C;router-outlet></code>，并位于应用组件树顶部的<em>根组件</em>中。</p>\n<p translation-origin=\"off\">You don't yet have such a root component, because the app is still managed as an AngularJS app.\nCreate a new <code>app.component.ts</code> file with the following <code>AppComponent</code> class:</p>\n<p translation-result=\"\">我们还没有这样一个根组件，因为该应用仍然是像一个AngularJS应用那样被管理的。\n创建新的<code>app.component.ts</code>文件，放入像这样的<code>AppComponent</code>类：</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.component.ts\" title=\"app/app.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> } from '@angular/core';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phonecat-app',\n  template: '&#x3C;router-outlet>&#x3C;/router-outlet>'\n})\nexport class AppComponent { }\n\n\n</code-example>\n<p translation-origin=\"off\">It has a simple template that only includes the `<router-outlet>.\nThis component just renders the contents of the active route and nothing else.</router-outlet></p>\n<p translation-result=\"\">它有一个很简单的模板，只包含Angular路由的<code>&#x3C;router-outlet></code>和AngularJS路由的<code>ng-view</code>指令。\n该组件只负责渲染活动路由的内容，此外啥也不干。</p>\n<p translation-origin=\"off\">The selector tells Angular to plug this root component into the <code>&#x3C;phonecat-app></code>\nelement on the host web page when the application launches.</p>\n<p translation-result=\"\">该选择器告诉Angular：当应用启动时就把这个根组件插入到宿主页面的<code>&#x3C;phonecat-app></code>元素中。</p>\n<p translation-origin=\"off\">Add this <code>&#x3C;phonecat-app></code> element to the <code>index.html</code>.\nIt replaces the old AngularJS <code>ng-view</code> directive:</p>\n<p translation-result=\"\">把这个<code>&#x3C;phonecat-app></code>元素插入到<code>index.html</code>中。\n用它来代替AngularJS中的<code>ng-view</code>指令：</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"appcomponent\" title=\"index.html (body)\" linenums=\"false\">\n&#x3C;body>\n  &#x3C;phonecat-app>&#x3C;/phonecat-app>\n&#x3C;/body>\n\n</code-example>\n<h4 translation-origin=\"off\" id=\"create-the-routing-module\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#create-the-routing-module\"><i class=\"material-icons\">link</i></a>Create the <em>Routing Module</em></h4>\n<h4 translation-result=\"\" id=\"创建路由模块\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#创建路由模块\"><i class=\"material-icons\">link</i></a>创建<em>路由模块</em></h4>\n<p translation-origin=\"off\">A router needs configuration whether it's the AngularJS or Angular or any other router.</p>\n<p translation-result=\"\">无论在AngularJS还是Angular或其它框架中，路由器都需要进行配置。</p>\n<p translation-origin=\"off\">The details of Angular router configuration are best left to the <a href=\"guide/router\">Routing documentation</a>\nwhich recommends that you create a <code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code> dedicated to router configuration\n(called a <em>Routing Module</em>).</p>\n<p translation-result=\"\">Angular路由器配置的详情最好去查阅下<a href=\"guide/router\">路由与导航</a>文档。\n它建议你创建一个专们用于路由器配置的<code><a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a></code>（名叫<em>路由模块</em>）。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app-routing.module.ts\" title=\"app/app-routing.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a>, <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> } from '@angular/router';\nimport { <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a>, <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a> } from '@angular/common';\n\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\nconst routes: <a href=\"api/router/Routes\" class=\"code-anchor\">Routes</a> = [\n  { path: '', redirectTo: 'phones', pathMatch: 'full' },\n  { path: 'phones',          component: PhoneListComponent },\n  { path: 'phones/:phoneId', component: PhoneDetailComponent }\n];\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot(routes) ],\n  exports: [ <a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a> ],\n  providers: [\n    { provide: <a href=\"api/common/APP_BASE_HREF\" class=\"code-anchor\">APP_BASE_HREF</a>, useValue: '!' },\n    { provide: <a href=\"api/common/LocationStrategy\" class=\"code-anchor\">LocationStrategy</a>, useClass: <a href=\"api/common/HashLocationStrategy\" class=\"code-anchor\">HashLocationStrategy</a> },\n  ]\n})\nexport class AppRoutingModule { }\n\n\n</code-example>\n<p translation-origin=\"off\">This module defines a <code>routes</code> object with two routes to the two phone components\nand a default route for the empty path.\nIt passes the <code>routes</code> to the <code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot</code> method which does the rest.</p>\n<p translation-result=\"\">该模块定义了一个<code>routes</code>对象，它带有两个路由，分别指向两个电话组件，以及为空路径指定的默认路由。\n它把<code>routes</code>传给<code><a href=\"api/router/RouterModule\" class=\"code-anchor\">RouterModule</a>.forRoot</code>方法，该方法会完成剩下的事。</p>\n<p translation-origin=\"off\">A couple of extra providers enable routing with \"hash\" URLs such as <code>#!/phones</code>\ninstead of the default \"push state\" strategy.</p>\n<p translation-result=\"\">一些额外的提供商让路由器使用“hash”策略解析URL，比如<code>#!/phones</code>，而不是默认的“Push State”策略。</p>\n<p translation-origin=\"off\">Now update the <code>AppModule</code> to import this <code>AppRoutingModule</code> and also the\ndeclare the root <code>AppComponent</code> as the bootstrap component.\nThat tells Angular that it should bootstrap the app with the <em>root</em> <code>AppComponent</code> and\ninsert it's view into the host web page.</p>\n<p translation-result=\"\">现在，修改<code>AppModule</code>，让它导入这个<code>AppRoutingModule</code>，并同时声明根组件<code>AppComponent</code>。\n这会告诉Angular，它应该使用根组件<code>AppComponent</code>引导应用，并把它的视图插入到宿主页面中。</p>\n<p translation-origin=\"off\">You must also remove the bootstrap of the AngularJS module from <code>ngDoBootstrap()</code> in <code>app.module.ts</code>\nand the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> import.</p>\n<p translation-result=\"\">我们还要从<code>app.module.ts</code>中移除调用<code>ngDoBootstrap()</code>来引导AngularJS模块的代码，以及对<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>的导入代码。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" title=\"app/app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> } from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent }     from './app.component';\nimport { CheckmarkPipe }    from './core/checkmark/checkmark.pipe';\nimport { Phone }            from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p translation-origin=\"off\">And since you are routing to <code>PhoneListComponent</code> and <code>PhoneDetailComponent</code> directly rather than\nusing a route template with a <code>&#x3C;phone-list></code> or <code>&#x3C;phone-detail></code> tag, you can do away with their\nAngular selectors as well.</p>\n<p translation-result=\"\">而且，由于我们现在直接路由到<code>PhoneListComponent</code>和<code>PhoneDetailComponent</code>，而不在使用带<code>&#x3C;phone-list></code>或<code>&#x3C;phone-detail></code>标签的路由模板，因此我们同样不再需要它们的 Angular 选择器。</p>\n<h4 translation-origin=\"off\" id=\"generate-links-for-each-phone\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#generate-links-for-each-phone\"><i class=\"material-icons\">link</i></a>Generate links for each phone</h4>\n<h4 translation-result=\"\" id=\"为每个电话生成链接\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#为每个电话生成链接\"><i class=\"material-icons\">link</i></a>为每个电话生成链接</h4>\n<p translation-origin=\"off\">You no longer have to hardcode the links to phone details in the phone list.\nYou can generate data bindings for each phone's <code>id</code> to the <code>routerLink</code> directive\nand let that directive construct the appropriate URL to the <code>PhoneDetailComponent</code>:</p>\n<p translation-result=\"\">在电话列表中，我们不用再被迫硬编码电话详情的链接了。\n我们可以通过把每个电话的<code>id</code>绑定到<code>routerLink</code>指令来生成它们了，该指令的构造函数会为<code>PhoneDetailComponent</code>生成正确的URL：</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.template.html\" region=\"list\" title=\"app/phone-list/phone-list.template.html (list with links)\" linenums=\"false\">\n&#x3C;ul class=\"phones\">\n  &#x3C;li *ngFor=\"let phone of getPhones()\"\n      class=\"thumbnail phone-list-item\">\n    &#x3C;a [routerLink]=\"['/phones', phone.id]\" class=\"thumb\">\n      &#x3C;img [src]=\"phone.imageUrl\" [alt]=\"phone.name\" />\n    &#x3C;/a>\n    &#x3C;a [routerLink]=\"['/phones', phone.id]\" class=\"name\">{{phone.name}}&#x3C;/a>\n    &#x3C;p>{{phone.snippet}}&#x3C;/p>\n  &#x3C;/li>\n&#x3C;/ul>\n\n</code-example>\n<div class=\"l-sub-section\">\n<p translation-origin=\"off\">See the <a href=\"guide/router\">Routing</a> page for details.</p>\n<p translation-result=\"\">要了解详情，请查看<a href=\"guide/router\">路由与导航</a>页。</p>\n</div><br>\n<h4 translation-origin=\"off\" id=\"use-route-parameters\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#use-route-parameters\"><i class=\"material-icons\">link</i></a>Use route parameters</h4>\n<h4 translation-result=\"\" id=\"使用路由参数\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#使用路由参数\"><i class=\"material-icons\">link</i></a>使用路由参数</h4>\n<p translation-origin=\"off\">The Angular router passes route parameters differently.\nCorrect the <code>PhoneDetail</code> component constructor to expect an injected <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object.\nExtract the <code>phoneId</code> from the <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>.snapshot.params</code> and fetch the phone data as before:</p>\n<p translation-result=\"\">Angular路由器会传入不同的路由参数。\n改正<code>PhoneDetail</code>组件的构造函数，让它改用注入进来的<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code>对象。\n从<code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>.snapshot.params</code>中提取出<code>phoneId</code>，并像以前一样获取手机的数据：</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.ts\" title=\"app/phone-detail/phone-detail.component.ts\">\nimport { <a href=\"api/core/Component\" class=\"code-anchor\">Component</a> }      from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n@<a href=\"api/core/Component\" class=\"code-anchor\">Component</a>({\n  selector: 'phone-detail',\n  templateUrl: './phone-detail.template.html'\n})\nexport class PhoneDetailComponent {\n  phone: PhoneData;\n  mainImageUrl: string;\n\n  constructor(activatedRoute: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, phone: Phone) {\n    phone.get(activatedRoute.snapshot.paramMap.get('phoneId'))\n      .subscribe((p: PhoneData) => {\n        this.phone = p;\n        this.setImage(p.images[0]);\n      });\n  }\n\n  setImage(imageUrl: string) {\n    this.mainImageUrl = imageUrl;\n  }\n}\n\n\n</code-example>\n<p translation-origin=\"off\">You are now running a pure Angular application!</p>\n<p translation-result=\"\">我们现在运行的就是纯正的Angular应用了！</p>\n<h3 translation-origin=\"off\" id=\"say-goodbye-to-angularjs\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#say-goodbye-to-angularjs\"><i class=\"material-icons\">link</i></a>Say Goodbye to AngularJS</h3>\n<h3 translation-result=\"\" id=\"再见，angularjs！\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#再见，angularjs！\"><i class=\"material-icons\">link</i></a>再见，AngularJS！</h3>\n<p translation-origin=\"off\">It is time to take off the training wheels and let the application begin\nits new life as a pure, shiny Angular app. The remaining tasks all have to\ndo with removing code - which of course is every programmer's favorite task!</p>\n<p translation-result=\"\">是时候把辅助训练的轮子摘下来了！让我们的应用作为一个纯粹、闪亮的Angular程序开始它的新生命吧。\n剩下的所有任务就是移除代码 —— 这当然是每个程序员最喜欢的任务！</p>\n<p translation-origin=\"off\">The application is still bootstrapped as a hybrid app.\nThere's no need for that anymore.</p>\n<p translation-result=\"\">应用仍然以混合式应用的方式启动，然而这再也没有必要了。</p>\n<p translation-origin=\"off\">Switch the bootstrap method of the application from the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to the Angular way.</p>\n<p translation-result=\"\">把应用的引导（<code>bootstrap</code>）方法从<code><a href=\"api/upgrade/UpgradeAdapter\" class=\"code-anchor\">UpgradeAdapter</a></code>的改为Angular的。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/main.ts\" title=\"main.ts\">\nimport { <a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic';\n\nimport { AppModule } from './app.module';\n\n<a href=\"api/platform-browser-dynamic/platformBrowserDynamic\" class=\"code-anchor\">platformBrowserDynamic</a>().bootstrapModule(AppModule);\n\n\n</code-example>\n<p translation-origin=\"off\">If you haven't already, remove all references to the <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> from <code>app.module.ts</code>,\nas well as any <a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">factory provider</a>\nfor AngularJS services, and the <code>app/ajs-upgraded-providers.ts</code> file.</p>\n<p translation-result=\"\">如果你还没有这么做，请从<code>app.module.ts删除所有</code>UpgradeModule的引用，\n以及所有用于AngularJS服务的<a href=\"guide/upgrade#making-angularjs-dependencies-injectable-to-angular\">工厂供应商（factory provider）</a>和<code>app/ajs-upgraded-providers.ts</code>文件。</p>\n<p translation-origin=\"off\">Also remove any <code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code> or <code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code> you find,\ntogether with the associated AngularJS factory or directive declarations.\nSince you no longer have downgraded components, you no longer list them\nin <code>entryComponents</code>.</p>\n<p translation-result=\"\">还要删除所有的<code><a href=\"api/upgrade/static/downgradeInjectable\" class=\"code-anchor\">downgradeInjectable</a>()</code>或<code><a href=\"api/upgrade/static/downgradeComponent\" class=\"code-anchor\">downgradeComponent</a>()</code>以及与AngularJS相关的工厂或指令声明。\n因为我们不再需要降级任何组件了，也不再需要把它们列在<code>entryComponents</code>中。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/app.module.ts\" title=\"app.module.ts\">\nimport { <a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a> } from '@angular/core';\nimport { <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a> } from '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>';\nimport { <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a> } from '@angular/forms';\nimport { <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a> } from '@angular/http';\n\nimport { AppRoutingModule } from './app-routing.module';\nimport { AppComponent }     from './app.component';\nimport { CheckmarkPipe }    from './core/checkmark/checkmark.pipe';\nimport { Phone }            from './core/phone/phone.service';\nimport { PhoneDetailComponent } from './phone-detail/phone-detail.component';\nimport { PhoneListComponent }   from './phone-list/phone-list.component';\n\n@<a href=\"api/core/NgModule\" class=\"code-anchor\">NgModule</a>({\n  imports: [\n    <a href=\"api/platform-browser/BrowserModule\" class=\"code-anchor\">BrowserModule</a>,\n    <a href=\"api/forms/FormsModule\" class=\"code-anchor\">FormsModule</a>,\n    <a href=\"api/http/HttpModule\" class=\"code-anchor\">HttpModule</a>,\n    AppRoutingModule\n  ],\n  declarations: [\n    AppComponent,\n    PhoneListComponent,\n    CheckmarkPipe,\n    PhoneDetailComponent\n  ],\n  providers: [\n    Phone\n  ],\n  bootstrap: [ AppComponent ]\n})\nexport class AppModule {}\n\n\n</code-example>\n<p translation-origin=\"off\">You may also completely remove the following files. They are AngularJS\nmodule configuration files and not needed in Angular:</p>\n<p translation-result=\"\">我们还要完全移除了下列文件。它们是AngularJS的模块配置文件和类型定义文件，在Angular中不需要了：</p>\n<ul>\n<li><code>app/app.module.ajs.ts</code></li>\n<li><code>app/app.config.ts</code></li>\n<li><code>app/core/core.module.ts</code></li>\n<li><code>app/core/phone/phone.module.ts</code></li>\n<li><code>app/phone-detail/phone-detail.module.ts</code></li>\n<li><code>app/phone-list/phone-list.module.ts</code></li>\n</ul>\n<p translation-origin=\"off\">The external typings for AngularJS may be uninstalled as well. The only ones\nyou still need are for Jasmine and Angular polyfills.\nThe <code>@angular/upgrade</code> package and it's mapping in <code>systemjs.config.js</code> can also go.</p>\n<p translation-result=\"\">还需要反安装AngularJS的外部类型定义文件。我们现在只需要Jasmine的那些。\n<code>systemjs.config.js</code>中的<code>@angular/upgrade</code>包及其映射也可以移除了。</p>\n<code-example format=\"\">\n  npm uninstall @angular/upgrade --save\n  npm uninstall @types/angular @types/angular-animate @types/angular-cookies @types/angular-mocks @types/angular-resource @types/angular-route @types/angular-sanitize --save-dev\n</code-example>\n<p translation-origin=\"off\">Finally, from <code>index.html</code>, remove all references to AngularJS scripts and jQuery.\nWhen you're done, this is what it should look like:</p>\n<p translation-result=\"\">最后，从<code>index.html</code>和<code>karma.conf.js</code>中，移除所有对AngularJS和jQuery脚本的引用。\n当这些全部做完时，<code>index.html</code>应该是这样的：</p>\n<code-example path=\"upgrade-phonecat-3-final/index.html\" region=\"full\" title=\"index.html\">\n&#x3C;!doctype html>\n&#x3C;html lang=\"en\">\n  &#x3C;head>\n    &#x3C;meta charset=\"utf-8\">\n    &#x3C;base href=\"/app/\">\n    &#x3C;title>Google Phone Gallery&#x3C;/title>\n    &#x3C;link rel=\"stylesheet\" href=\"https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css\" />\n    &#x3C;link rel=\"stylesheet\" href=\"app.css\" />\n\n    &#x3C;script src=\"/node_modules/core-js/client/shim.min.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/zone.js/dist/zone.js\">&#x3C;/script>\n    &#x3C;script src=\"/node_modules/systemjs/dist/system.src.js\">&#x3C;/script>\n    &#x3C;script src=\"/systemjs.config.js\">&#x3C;/script>\n    &#x3C;script>\n      System.import('/app');\n    &#x3C;/script>\n  &#x3C;/head>\n  &#x3C;body>\n    &#x3C;phonecat-app>&#x3C;/phonecat-app>\n  &#x3C;/body>\n&#x3C;/html>\n\n</code-example>\n<p translation-origin=\"off\">That is the last you'll see of AngularJS! It has served us well but now\nit's time to say goodbye.</p>\n<p translation-result=\"\">这是我们最后一次看到AngularJS了！它曾经带给我们很多帮助，不过现在，是时候说再见了。</p>\n<h2 translation-origin=\"off\" id=\"appendix-upgrading-phonecat-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#appendix-upgrading-phonecat-tests\"><i class=\"material-icons\">link</i></a>Appendix: Upgrading PhoneCat Tests</h2>\n<h2 translation-result=\"\" id=\"附录：升级phonecat的测试\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#附录：升级phonecat的测试\"><i class=\"material-icons\">link</i></a>附录：升级PhoneCat的测试</h2>\n<p translation-origin=\"off\">Tests can not only be retained through an upgrade process, but they can also be\nused as a valuable safety measure when ensuring that the application does not\nbreak during the upgrade. E2E tests are especially useful for this purpose.</p>\n<p translation-result=\"\">测试不仅要在升级过程中被保留，它还是确保应用在升级过程中不会被破坏的一个安全指示器。\n要达到这个目的，E2E测试尤其有用。</p>\n<h3 translation-origin=\"off\" id=\"e2e-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e-tests\"><i class=\"material-icons\">link</i></a>E2E Tests</h3>\n<h3 translation-result=\"\" id=\"e2e测试\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#e2e测试\"><i class=\"material-icons\">link</i></a>E2E测试</h3>\n<p translation-origin=\"off\">The PhoneCat project has both E2E Protractor tests and some Karma unit tests in it.\nOf these two, E2E tests can be dealt with much more easily: By definition,\nE2E tests access the application from the <em>outside</em> by interacting with\nthe various UI elements the app puts on the screen. E2E tests aren't really that\nconcerned with the internal structure of the application components. That\nalso means that, although you modify the project quite a bit during the upgrade, the E2E\ntest suite should keep passing with just minor modifications. You\ndidn't change how the application behaves from the user's point of view.</p>\n<p translation-result=\"\">PhoneCat项目中同时有基于Protractor的E2E测试和一些基于Karma的单元测试。\n对这两者来说，E2E测试的转换要容易得多：根据定义，E2E测试通过与应用中显示的这些UI元素互动，从<em>外部</em>访问我们的应用来进行测试。\nE2E测试实际上并不关心这些应用中各部件的内部结构。这也意味着，虽然我们已经修改了此应用程序，\n但是E2E测试套件仍然应该能像以前一样全部通过。因为从用户的角度来说，我们并没有改变应用的行为。</p>\n<p translation-origin=\"off\">During TypeScript conversion, there is nothing to do to keep E2E tests\nworking. But when you change the bootstrap to that of a Hybrid app,\nyou must make a few changes.</p>\n<p translation-result=\"\">在转成TypeScript期间，我们不用做什么就能让E2E测试正常工作。\n只有当我们想做些修改而把组件及其模板升级到Angular时才需要做些处理。</p>\n<p translation-origin=\"off\">Update the <code>protractor-conf.js</code> to sync with hybrid apps:</p>\n<p translation-result=\"\">再对<code>protractor-conf.js</code>做下列修改，与混合应用同步：</p>\n<code-example format=\"\">\n  ng12Hybrid: true\n</code-example>\n<p translation-result=\"\">When you start to upgrade components and their templates to Angular, you'll make more changes\nbecause the E2E tests have matchers that are specific to AngularJS.\nFor PhoneCat you need to make the following changes in order to make things work with Angular:\n当我们开始组件和模块升级到Angular时，还需要一系列后续的修改。\n这是因为E2E测试有一些匹配器是AngularJS中特有的。对于PhoneCat来说，为了让它能在Angular下工作，我们得做下列修改：</p>\n<table>\n  <tbody><tr>\n    <th>\n      <p translation-origin=\"off\">\n        Previous code\n      </p>\n      <p translation-result=\"\">\n        老代码\n      </p>\n    </th>\n    <th>\n      <p translation-origin=\"off\">\n        New code\n      </p>\n      <p translation-result=\"\">\n        新代码\n      </p>\n    </th>\n    <th>\n      <p translation-origin=\"off\">\n        Notes\n      </p>\n      <p translation-result=\"\">\n        说明\n      </p>\n    </th>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      <code>by.repeater('phone in $ctrl.phones').column('phone.name')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>by.css('.phones .name')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      The repeater matcher relies on AngularJS <code>ng-repeat</code></p>\n<p translation-result=\"\">      repeater匹配器依赖于AngularJS中的<code>ng-repeat</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      <code>by.repeater('phone in $ctrl.phones')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>by.css('.phones li')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      The repeater matcher relies on AngularJS <code>ng-repeat</code></p>\n<p translation-result=\"\">      repeater匹配器依赖于AngularJS中的<code>ng-repeat</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      <code>by.model('$ctrl.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>by.css('input')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      The model matcher relies on AngularJS <code>ng-model</code></p>\n<p translation-result=\"\">      model匹配器依赖于AngularJS中的<code>ng-model</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      <code>by.model('$ctrl.orderProp')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>by.css('select')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      The model matcher relies on AngularJS <code>ng-model</code></p>\n<p translation-result=\"\">      model匹配器依赖于AngularJS中的<code>ng-model</code></p>\n    </td>\n  </tr>\n  <tr>\n    <td>\n<p translation-origin=\"off\">      <code>by.binding('$ctrl.phone.name')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      <code>by.css('h1')</code></p>\n    </td>\n    <td>\n<p translation-origin=\"off\">      The binding matcher relies on AngularJS data binding</p>\n<p translation-result=\"\">      binding匹配器依赖于AngularJS的数据绑定</p>\n    </td>\n  </tr>\n</tbody></table>\n<p translation-origin=\"off\">When the bootstrap method is switched from that of <code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code> to\npure Angular, AngularJS ceases to exist on the page completely.\nAt this point, you need to tell Protractor that it should not be looking for\nan AngularJS app anymore, but instead it should find <em>Angular apps</em> from\nthe page.</p>\n<p translation-result=\"\">当引导方式从<code><a href=\"api/upgrade/static/UpgradeModule\" class=\"code-anchor\">UpgradeModule</a></code>切换到纯Angular的时，AngularJS就从页面中完全消失了。\n此时，我们需要告诉Protractor，它不用再找AngularJS应用了，而是从页面中查找<em>Angular</em>应用。\n于是在<code>protractor-conf.js</code>中做下列修改：\nReplace the <code>ng12Hybrid</code> previously added with the following in <code>protractor-conf.js</code>:</p>\n<p translation-result=\"\">替换之前在<code>protractor-conf.js</code>中加入 <code>ng12Hybrid</code>，象这样：</p>\n<code-example format=\"\">\n  useAllAngular2AppRoots: true,\n</code-example>\n<p translation-origin=\"off\">Also, there are a couple of Protractor API calls in the PhoneCat test code that\nare using the AngularJS <code>$location</code> service under the hood. As that\nservice is no longer present after the upgrade, replace those calls with ones\nthat use WebDriver's generic URL APIs instead. The first of these is\nthe redirection spec:</p>\n<p translation-result=\"\">同样，我们的测试代码中有两个Protractor API调用内部使用了<code>$location</code>。该服务没有了，\n我们就得把这些调用用一个WebDriver的通用URL API代替。第一个API是“重定向(redirect)”规约：</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"redirect\" title=\"e2e-tests/scenarios.ts\">\nit('should redirect `index.html` to `index.html#!/phones', function() {\n  <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>.get('index.html');\n  <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>.waitForAngular();\n  <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>.getCurrentUrl().then(function(url: string) {\n    expect(url.endsWith('/phones')).toBe(true);\n  });\n});\n\n</code-example>\n<p translation-origin=\"off\">And the second is the phone links spec:</p>\n<p translation-result=\"\">然后是“电话链接(phone links)”规约：</p>\n<code-example path=\"upgrade-phonecat-3-final/e2e-spec.ts\" region=\"links\" title=\"e2e-tests/scenarios.ts\">\nit('should render phone specific links', function() {\n  let <a href=\"api/animations/query\" class=\"code-anchor\">query</a> = element(by.css('input'));\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>.sendKeys('nexus');\n  element.all(by.css('.phones li a')).first().click();\n  <a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>.getCurrentUrl().then(function(url: string) {\n    expect(url.endsWith('/phones/nexus-s')).toBe(true);\n  });\n});\n\n</code-example>\n<h3 translation-origin=\"off\" id=\"unit-tests\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#unit-tests\"><i class=\"material-icons\">link</i></a>Unit Tests</h3>\n<h3 translation-result=\"\" id=\"单元测试\"><a title=\"Link to this heading\" class=\"header-link\" aria-hidden=\"true\" href=\"guide/upgrade#单元测试\"><i class=\"material-icons\">link</i></a>单元测试</h3>\n<p translation-origin=\"off\">For unit tests, on the other hand, more conversion work is needed. Effectively\nthey need to be <em>upgraded</em> along with the production code.</p>\n<p translation-result=\"\">另一方面，对于单元测试来说，需要更多的转化工作。实际上，它们需要随着产品代码一起升级。</p>\n<p translation-origin=\"off\">During TypeScript conversion no changes are strictly necessary. But it may be\na good idea to convert the unit test code into TypeScript as well.</p>\n<p translation-result=\"\">在转成TypeScript期间，严格来讲没有什么改动是必须的。但把单元测试代码转成TypeScript仍然是个好主意，\n产品代码从TypeScript中获得的那些增益也同样适用于测试代码。For instance, in the phone detail component spec , you can use  ES2015\nfeatures like arrow functions and block-scoped variablesand benefit from the type\ndefinitions  of the AngularJS services you're consuming:\n比如，在这个电话详情组件的规约中，我们不仅用到了ES2015中的箭头函数和块作用域变量这些特性，还为所用的一些\nAngularJS服务提供了类型定义。</p>\n<code-example path=\"upgrade-phonecat-1-typescript/app/phone-detail/phone-detail.component.spec.ts\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\ndescribe('phoneDetail', () => {\n\n  // Load the module that contains the `phoneDetail` component before each test\n  beforeEach(angular.mock.module('phoneDetail'));\n\n  // Test the controller\n  describe('PhoneDetailController', () => {\n    let $httpBackend: angular.IHttpBackendService;\n    let ctrl: any;\n    let xyzPhoneData = {\n      name: 'phone xyz',\n      images: ['image/url1.png', 'image/url2.png']\n    };\n\n    beforeEach(<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a>(($componentController: any,\n                       _$httpBackend_: angular.IHttpBackendService,\n                       $routeParams: angular.route.IRouteParamsService) => {\n      $httpBackend = _$httpBackend_;\n      $httpBackend.expectGET('phones/xyz.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>').respond(xyzPhoneData);\n\n      $routeParams['phoneId'] = 'xyz';\n\n      ctrl = $componentController('phoneDetail');\n    }));\n\n    it('should fetch the phone details', () => {\n      jasmine.addCustomEqualityTester(angular.equals);\n\n      expect(ctrl.phone).toEqual({});\n\n      $httpBackend.<a href=\"api/core/testing/flush\" class=\"code-anchor\">flush</a>();\n      expect(ctrl.phone).toEqual(xyzPhoneData);\n    });\n\n  });\n\n});\n\n\n</code-example>\n<p translation-origin=\"off\">Once you start the upgrade process and bring in SystemJS, configuration changes\nare needed for Karma. You need to let SystemJS load all the new Angular code,\nwhich can be done with the following kind of shim file:</p>\n<p translation-result=\"\">一旦我们开始了升级过程并引入了SystemJS，还需要对Karma进行配置修改。\n我们需要让SystemJS加载所有的Angular新代码，</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma-test-shim.1.js\" title=\"karma-test-shim.js\">\n// /*global jasmine, __karma__, window*/\nError.stackTraceLimit = 0; // \"No stacktrace\"\" is usually best for app testing.\n\n// Uncomment to get full stacktrace output. Sometimes helpful, usually not.\n// Error.stackTraceLimit = Infinity; //\n\njasmine.DEFAULT_TIMEOUT_INTERVAL = 1000;\n\nvar builtPath = '/base/app/';\n\n__karma__.loaded = function () { };\n\nfunction isJsFile(path) {\n  return path.<a href=\"api/common/SlicePipe\" class=\"code-anchor\">slice</a>(-3) == '.js';\n}\n\nfunction isSpecFile(path) {\n  return /\\.spec\\.(.*\\.)?js$/.test(path);\n}\n\nfunction isBuiltFile(path) {\n  return isJsFile(path) &#x26;&#x26; (path.substr(0, builtPath.length) == builtPath);\n}\n\nvar allSpecFiles = Object.keys(window.__karma__.files)\n  .filter(isSpecFile)\n  .filter(isBuiltFile);\n\nSystem.config({\n  baseURL: '/base',\n  // Extend usual application package list with test folder\n  packages: { 'testing': { main: 'index.js', defaultExtension: 'js' } },\n\n  // Assume npm: is set in `paths` in systemjs.config\n  // Map the angular testing umd bundles\n  map: {\n    '@angular/core/testing': 'npm:@angular/core/bundles/core-testing.umd.js',\n    '@angular/common/testing': 'npm:@angular/common/bundles/common-testing.umd.js',\n    '@angular/compiler/testing': 'npm:@angular/compiler/bundles/compiler-testing.umd.js',\n    '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>/testing': 'npm:@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>/bundles/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-testing.umd.js',\n    '@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic/testing': 'npm:@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic/bundles/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic-testing.umd.js',\n    '@angular/http/testing': 'npm:@angular/http/bundles/http-testing.umd.js',\n    '@angular/router/testing': 'npm:@angular/router/bundles/router-testing.umd.js',\n    '@angular/forms/testing': 'npm:@angular/forms/bundles/forms-testing.umd.js',\n  },\n});\n\nSystem.import('systemjs.config.js')\n  .then(importSystemJsExtras)\n  .then(initTestBed)\n  .then(initTesting);\n\n/** <a href=\"api/core/Optional\" class=\"code-anchor\">Optional</a> SystemJS configuration extras. Keep going w/o it */\nfunction importSystemJsExtras(){\n  return System.import('systemjs.config.extras.js')\n  .catch(function(reason) {\n    console.log(\n      'Warning: System.import could not load the optional \"systemjs.config.extras.js\". Did you omit it by accident? Continuing without it.'\n    );\n    console.log(reason);\n  });\n}\n\nfunction initTestBed(){\n  return Promise.all([\n    System.import('@angular/core/testing'),\n    System.import('@angular/platform-<a href=\"api/animations/browser\" class=\"code-anchor\">browser</a>-dynamic/testing')\n  ])\n\n  .then(function (providers) {\n    var coreTesting    = providers[0];\n    var browserTesting = providers[1];\n\n    coreTesting.<a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.initTestEnvironment(\n      browserTesting.<a href=\"api/platform-browser-dynamic/testing/BrowserDynamicTestingModule\" class=\"code-anchor\">BrowserDynamicTestingModule</a>,\n      browserTesting.<a href=\"api/platform-browser-dynamic/testing/platformBrowserDynamicTesting\" class=\"code-anchor\">platformBrowserDynamicTesting</a>());\n  })\n}\n\n// Import all spec files and start karma\nfunction initTesting () {\n  return Promise.all(\n    allSpecFiles.map(function (moduleName) {\n      return System.import(moduleName);\n    })\n  )\n  .then(__karma__.start, __karma__.error);\n}\n\n\n</code-example>\n<p translation-origin=\"off\">The shim first loads the SystemJS configuration, then Angular's test support libraries,\nand then the application's spec files themselves.</p>\n<p translation-result=\"\">这个shim文件首先加载了SystemJS的配置，然后是Angular的测试支持库，然后是应用本身的规约文件。</p>\n<p translation-origin=\"off\">Karma configuration should then be changed so that it uses the application root dir\nas the base directory, instead of <code>app</code>.</p>\n<p translation-result=\"\">然后需要修改Karma配置，来让它使用本应用的根目录作为基础目录(base directory)，而不是<code>app</code>。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"basepath\" title=\"karma.conf.js\">\nbasePath: './',\n\n</code-example>\n<p translation-origin=\"off\">Once done, you can load SystemJS and other dependencies, and also switch the configuration\nfor loading application files so that they are <em>not</em> included to the page by Karma. You'll let\nthe shim and SystemJS load them.</p>\n<p translation-result=\"\">一旦这些完成了，我们就能加载SystemJS和其它依赖，并切换配置文件来加载那些应用文件，而<em>不用</em>在Karma页面中包含它们。\n我们要让这个shim文件和SystemJS去加载它们。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"files\" title=\"karma.conf.js\">\n// System.js for module loading\n'node_modules/systemjs/dist/system.src.js',\n\n// Polyfills\n'node_modules/core-js/client/shim.js',\n\n// zone.js\n'node_modules/zone.js/dist/zone.js',\n'node_modules/zone.js/dist/long-stack-trace-zone.js',\n'node_modules/zone.js/dist/proxy.js',\n'node_modules/zone.js/dist/sync-test.js',\n'node_modules/zone.js/dist/jasmine-patch.js',\n'node_modules/zone.js/dist/async-test.js',\n'node_modules/zone.js/dist/fake-async-test.js',\n\n// RxJs.\n{ pattern: 'node_modules/rxjs/**/*.js', included: false, watched: false },\n{ pattern: 'node_modules/rxjs/**/*.js.map', included: false, watched: false },\n\n// Angular itself and the testing library\n{pattern: 'node_modules/@angular/**/*.js', included: false, watched: false},\n{pattern: 'node_modules/@angular/**/*.js.map', included: false, watched: false},\n\n{pattern: 'systemjs.config.js', included: false, watched: false},\n'karma-test-shim.js',\n\n{pattern: 'app/**/*.module.js', included: false, watched: true},\n{pattern: 'app/*!(.module|.spec).js', included: false, watched: true},\n{pattern: 'app/!(bower_components)/**/*!(.module|.spec).js', included: false, watched: true},\n{pattern: 'app/**/*.spec.js', included: false, watched: true},\n\n{pattern: '**/*.html', included: false, watched: true},\n\n</code-example>\n<p translation-origin=\"off\">Since the HTML templates of Angular components will be loaded as well, you must help\nKarma out a bit so that it can route them to the right paths:</p>\n<p translation-result=\"\">由于Angular组件中的HTML模板也同样要被加载，所以我们得帮Karma一把，帮它在正确的路径下找到这些模板：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/karma.conf.ajs.js\" region=\"html\" title=\"karma.conf.js\">\n// proxied base paths for loading assets\nproxies: {\n  // required for component assets fetched by Angular's compiler\n  \"/phone-detail\": '/base/app/phone-detail',\n  \"/phone-list\": '/base/app/phone-list'\n},\n\n</code-example>\n<p translation-origin=\"off\">The unit test files themselves also need to be switched to Angular when their production\ncounterparts are switched. The specs for the checkmark pipe are probably the most straightforward,\nas the pipe has no dependencies:</p>\n<p translation-result=\"\">如果产品代码被切换到了Angular，单元测试文件本身也需要切换过来。对勾(checkmark)管道的规约可能是最简单的，因为它没有任何依赖：</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/checkmark/checkmark.pipe.spec.ts\" title=\"app/core/checkmark/checkmark.pipe.spec.ts\">\nimport { CheckmarkPipe } from './checkmark.pipe';\n\ndescribe('CheckmarkPipe', function() {\n\n  it('should convert boolean values to unicode checkmark or cross', function () {\n    const checkmarkPipe = new CheckmarkPipe();\n    expect(checkmarkPipe.transform(true)).toBe('\\u2713');\n    expect(checkmarkPipe.transform(false)).toBe('\\u2718');\n  });\n});\n\n\n</code-example>\n<p translation-origin=\"off\">The unit test for the phone service is a bit more involved. You need to switch from the mocked-out\nAngularJS <code>$httpBackend</code> to a mocked-out Angular Http backend.</p>\n<p translation-result=\"\"><code>Phone</code>服务的测试会牵扯到一点别的。我们需要把模拟版的AngularJS <code>$httpBackend</code>服务切换到模拟板的Angular Http后端。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/core/phone/phone.service.spec.ts\" title=\"app/core/phone/phone.service.spec.ts\">\nimport { <a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport {\n  <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>,\n  <a href=\"api/http/BaseRequestOptions\" class=\"code-anchor\">BaseRequestOptions</a>,\n  <a href=\"api/http/ResponseOptions\" class=\"code-anchor\">ResponseOptions</a>,\n  <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>\n} from '@angular/http';\nimport { <a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>, <a href=\"api/http/testing/MockConnection\" class=\"code-anchor\">MockConnection</a> } from '@angular/http/testing';\nimport { Phone, PhoneData } from './phone.service';\n\ndescribe('Phone', function() {\n  let phone: Phone;\n  let phonesData: PhoneData[] = [\n    {name: 'Phone X', snippet: '', images: []},\n    {name: 'Phone Y', snippet: '', images: []},\n    {name: 'Phone Z', snippet: '', images: []}\n  ];\n  let mockBackend: <a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>;\n\n  beforeEach(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.configureTestingModule({\n      providers: [\n        Phone,\n        <a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>,\n        <a href=\"api/http/BaseRequestOptions\" class=\"code-anchor\">BaseRequestOptions</a>,\n        { provide: <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>,\n          useFactory: (backend: <a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>, options: <a href=\"api/http/BaseRequestOptions\" class=\"code-anchor\">BaseRequestOptions</a>) => new <a href=\"api/http/Http\" class=\"code-anchor\">Http</a>(backend, options),\n          deps: [<a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>, <a href=\"api/http/BaseRequestOptions\" class=\"code-anchor\">BaseRequestOptions</a>]\n        }\n      ]\n    });\n  });\n\n  beforeEach(<a href=\"api/core/testing/inject\" class=\"code-anchor\">inject</a>([<a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>, Phone], (_mockBackend_: <a href=\"api/http/testing/MockBackend\" class=\"code-anchor\">MockBackend</a>, _phone_: Phone) => {\n    mockBackend = _mockBackend_;\n    phone = _phone_;\n  }));\n\n  it('should fetch the phones data from `/phones/phones.<a href=\"api/common/JsonPipe\" class=\"code-anchor\">json</a>`', (done: () => void) => {\n    mockBackend.connections.subscribe((conn: <a href=\"api/http/testing/MockConnection\" class=\"code-anchor\">MockConnection</a>) => {\n      conn.mockRespond(new <a href=\"api/http/Response\" class=\"code-anchor\">Response</a>(new <a href=\"api/http/ResponseOptions\" class=\"code-anchor\">ResponseOptions</a>({body: JSON.stringify(phonesData)})));\n    });\n    phone.<a href=\"api/animations/query\" class=\"code-anchor\">query</a>().subscribe(result => {\n      expect(result).toEqual(phonesData);\n      done();\n    });\n  });\n\n});\n\n\n\n</code-example>\n<p translation-result=\"\">For the component specs , you can mock out the <code>Phone</code> service itself, and have it provide\ncanned phone data. You use Angular's component unit testing APIs for both components.\n对于组件的规约，我们可以模拟出<code>Phone</code>服务本身，并且让它提供电话的数据。我们可以对这些组件使用Angular的组件单元测试API。</p>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-detail/phone-detail.component.spec.ts\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\nimport { Observable } from 'rxjs/Rx';\n\nimport { async, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\n\nimport { PhoneDetailComponent } from './phone-detail.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\nimport { CheckmarkPipe } from '../core/checkmark/checkmark.pipe';\n\nfunction xyzPhoneData(): PhoneData {\n  return {\n    name: 'phone xyz',\n    snippet: '',\n    images: ['image/url1.png', 'image/url2.png']\n  };\n}\n\nclass MockPhone {\n  get(id: string): Observable&#x3C;PhoneData> {\n    return Observable.of(xyzPhoneData());\n  }\n}\n\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n\ndescribe('PhoneDetailComponent', () => {\n\n\n  beforeEach(async(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n  it('should fetch phone detail', () => {\n    const fixture = <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.createComponent(PhoneDetailComponent);\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelector('h1').textContent).toContain(xyzPhoneData().name);\n  });\n\n});\n\n\n</code-example>\n<code-example path=\"upgrade-phonecat-2-hybrid/app/phone-list/phone-list.component.spec.ts\" title=\"app/phone-list/phone-list.component.spec.ts\">\nimport { <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs/Rx';\nimport { async, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a> } from '@angular/common/testing';\n\nimport { PhoneListComponent } from './phone-list.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\nclass MockPhone {\n  <a href=\"api/animations/query\" class=\"code-anchor\">query</a>(): Observable&#x3C;PhoneData[]> {\n    return Observable.of([\n      {name: 'Nexus S', snippet: '', images: []},\n      {name: 'Motorola DROID', snippet: '', images: []}\n    ]);\n  }\n}\n\nlet fixture: <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>&#x3C;PhoneListComponent>;\n\ndescribe('PhoneList', () => {\n\n  beforeEach(async(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.configureTestingModule({\n      declarations: [ PhoneListComponent ],\n      providers: [\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },\n        { provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a> },\n        { provide: Phone, useClass: MockPhone },\n      ],\n      schemas: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.createComponent(PhoneListComponent);\n  });\n\n  it('should create \"phones\" model with 2 phones fetched from xhr', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(compiled.querySelectorAll('.phone-list-item').length).toBe(2);\n    expect(\n      compiled.querySelector('.phone-list-item:nth-child(1)').textContent\n    ).toContain('Motorola DROID');\n    expect(\n      compiled.querySelector('.phone-list-item:nth-child(2)').textContent\n    ).toContain('Nexus S');\n  });\n\n  xit('should set the default value of orderProp model', () => {\n    fixture.detectChanges();\n    let compiled = fixture.debugElement.nativeElement;\n    expect(\n      compiled.querySelector('select <a href=\"api/forms/NgSelectOption\" class=\"code-anchor\">option</a>:last-child').selected\n    ).toBe(true);\n  });\n\n});\n\n\n</code-example>\n<p translation-origin=\"off\">Finally, revisit both of the component tests when you switch to the Angular\nrouter. For the details component, provide a mock of Angular <code><a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a></code> object\ninstead of using the AngularJS <code>$routeParams</code>.</p>\n<p translation-result=\"\">最后，当我们切换到Angular路由时，我们需要重新过一遍这些组件测试。对详情组件来说，我们需要提供一个Angular\n<code>RouteParams</code>的mock对象，而不再用AngularJS中的<code>$routeParams</code>。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-detail/phone-detail.component.spec.ts\" region=\"activatedroute\" title=\"app/phone-detail/phone-detail.component.spec.ts\">\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\n\n/* . . . */\n\nclass ActivatedRouteMock {\n  constructor(public snapshot: any) {}\n}\n\n/* . . . */\n\n  beforeEach(async(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.configureTestingModule({\n      declarations: [ CheckmarkPipe, PhoneDetailComponent ],\n      providers: [\n        { provide: Phone, useClass: MockPhone },\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) }\n      ]\n    })\n    .compileComponents();\n  }));\n\n</code-example>\n<p translation-origin=\"off\">And for the phone list component, a few adjustments to the router make\nthe <code>RouteLink</code> directives work.</p>\n<p translation-result=\"\">对于电话列表组件，还要再做少量的调整，以便路由器能让<code>RouteLink</code>指令正常工作。</p>\n<code-example path=\"upgrade-phonecat-3-final/app/phone-list/phone-list.component.spec.ts\" region=\"routestuff\" title=\"app/phone-list/phone-list.component.spec.ts\">\nimport { <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> } from '@angular/core';\nimport { <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a> } from '@angular/router';\nimport { Observable } from 'rxjs/Rx';\nimport { async, <a href=\"api/core/testing/ComponentFixture\" class=\"code-anchor\">ComponentFixture</a>, <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a> } from '@angular/core/testing';\nimport { <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a> } from '@angular/common/testing';\n\nimport { PhoneListComponent } from './phone-list.component';\nimport { Phone, PhoneData } from '../core/phone/phone.service';\n\n/* . . . */\n\n  beforeEach(async(() => {\n    <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.configureTestingModule({\n      declarations: [ PhoneListComponent ],\n      providers: [\n        { provide: <a href=\"api/router/ActivatedRoute\" class=\"code-anchor\">ActivatedRoute</a>, useValue: new ActivatedRouteMock({ params: { 'phoneId': 1 } }) },\n        { provide: <a href=\"api/common/Location\" class=\"code-anchor\">Location</a>, useClass: <a href=\"api/common/testing/SpyLocation\" class=\"code-anchor\">SpyLocation</a> },\n        { provide: Phone, useClass: MockPhone },\n      ],\n      schemas: [ <a href=\"api/core/NO_ERRORS_SCHEMA\" class=\"code-anchor\">NO_ERRORS_SCHEMA</a> ]\n    })\n    .compileComponents();\n  }));\n\n  beforeEach(() => {\n    fixture = <a href=\"api/core/testing/TestBed\" class=\"code-anchor\">TestBed</a>.createComponent(PhoneListComponent);\n  });\n\n</code-example>\n\n</div>"
}